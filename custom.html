<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triple Nickel - Custom</title>
    <link rel="stylesheet" href="shared-sidebar.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        /* Override shared styles for full window layout */
        * {
            box-sizing: border-box;
        }
        
        html {
            height: 100%;
            overflow-x: hidden;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            overflow-y: auto;
            height: 100%;
            min-width: 320px;
            width: 100%;
            max-width: 100vw;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            margin-left: clamp(250px, 20vw, 300px);
            padding: 0 !important;
            min-height: 100vh;
            min-width: 0;
            display: flex;
            flex-direction: row;
            overflow-x: hidden;
        }

        /* Sidebar styles handled by shared-sidebar.css */
        
        .game-interface {
            flex: 1;
            padding: 15px;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .game-interface.expanded {
            margin-left: 0;
        }
        
        /* Responsive player grid */
        .players-grid {
            display: grid !important;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)) !important;
            gap: 15px !important;
            margin-bottom: 20px !important;
            width: 100% !important;
            max-width: none !important;
            min-width: 0 !important;
        }
        
        /* Make player cards maintain minimum size when side by side */
        .player-card {
            position: relative;
            width: 100% !important;
            max-width: none !important;
            min-width: 0 !important;
            flex-shrink: 0 !important;
        }
        
        /* Responsive header */
        .game-header {
            flex-wrap: wrap !important;
            gap: 10px !important;
            margin-bottom: 15px !important;
            justify-content: flex-end;
        }
        
        .action-buttons {
            flex-wrap: wrap !important;
            gap: 8px !important;
            justify-content: flex-end !important;
            margin-left: auto !important;
            padding-right: 60px !important;
        }
        
        .action-button {
            white-space: nowrap !important;
            min-width: fit-content !important;
        }
        
        /* Responsive settings panel grid */
        #settingsPanel {
            margin-bottom: 20px !important;
        }
        
        #settingsPanel .config-grid {
            display: grid !important;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)) !important;
            gap: 20px !important;
        }
        
        #customDistanceInputs {
            display: grid !important;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)) !important;
            gap: 15px !important;
        }
        
        /* Responsive game info */
        .game-info {
            margin-bottom: 15px !important;
        }
        
        /* Add player button area */
        .add-player {
            margin-top: auto;
            padding: 15px 0;
            text-align: center;
            min-width: 0;
        }

        /* Player management controls */
        .player-controls {
            margin-bottom: 20px;
        }

        .pagination-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(30, 41, 59, 0.4);
            border-radius: 10px;
            padding: 15px 20px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            flex-wrap: wrap;
            gap: 15px;
        }

        .pagination-info {
            display: flex;
            align-items: center;
            color: #e2e8f0;
            font-weight: 500;
        }

        .pagination-buttons {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .pagination-buttons button {
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .pagination-buttons button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .pagination-buttons button:disabled {
            background: #475569;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #pageInfo, #bottomPageInfo {
            color: #cbd5e1;
            font-weight: 500;
            min-width: 90px;
            text-align: center;
        }
        
        .pagination-right {
            display: flex;
            align-items: center;
            gap: 15px;
            justify-content: flex-end;
        }
        
        .pagination-dropdown {
            flex-shrink: 0;
        }
        
        /* Custom game specific styles */
        .custom-config {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid #475569;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .config-item {
            display: flex;
            flex-direction: column;
        }
        
        .config-label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 8px;
            color: #e2e8f0;
        }
        
        .config-input {
            background: #475569;
            border: 1px solid #64748b;
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
            outline: none;
        }
        
        .custom-scoring {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 8px;
            max-width: 600px;
        }

        /* Collapsible section styles */
        .collapsible-section {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid #475569;
            border-radius: 10px;
            padding: 0;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            cursor: pointer;
            user-select: none;
            transition: background 0.3s ease;
        }

        .collapsible-header:hover {
            background: rgba(71, 85, 105, 0.3);
        }

        .collapsible-header h4 {
            margin: 0;
            color: #e2e8f0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapsible-toggle {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
            color: #cbd5e1;
        }

        .collapsible-section.collapsed .collapsible-toggle {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            padding: 20px;
            display: block;
            transition: max-height 0.3s ease, padding 0.3s ease;
            max-height: 5000px;
        }

        .collapsible-section.collapsed .collapsible-content {
            max-height: 0;
            padding: 0 20px;
            overflow: hidden;
        }

        /* Responsive breakpoints */
        @media (min-width: 800px) {
            .players-grid {
                grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)) !important;
            }
        }

        @media (max-width: 799px) and (min-width: 450px) {
            .players-grid {
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)) !important;
            }
            
            .game-interface {
                padding: 10px !important;
            }
        }

        @media (max-width: 449px) {
            .players-grid {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
            
            .game-interface {
                padding: 8px !important;
            }
            
            .action-buttons {
                padding-right: 20px !important;
            }
            
            .game-header {
                flex-direction: column !important;
                align-items: stretch !important;
            }
        }

        @media (max-width: 1024px) {
            .container {
                margin-left: clamp(200px, 25vw, 250px);
            }
            
            .action-buttons {
                padding-right: 20px !important;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column !important;
                margin-left: 0;
            }
            
            .game-interface {
                width: 100% !important;
                flex: 1 1 auto !important;
                min-width: 0 !important;
            }
            
            .config-grid {
                grid-template-columns: 1fr !important;
            }
            
            #settingsPanel .config-grid {
                grid-template-columns: 1fr !important;
            }
            
            .pagination-controls {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 10px !important;
            }
            
            .pagination-right {
                justify-content: space-between !important;
                width: 100% !important;
            }
            
            .pagination-buttons {
                gap: 10px !important;
            }
        }

        @media (max-width: 480px) {
            .pagination-buttons {
                flex-direction: column !important;
                gap: 8px !important;
            }
            
            .pagination-buttons button {
                width: 100% !important;
                padding: 10px !important;
            }
        }
        
        /* Apply Changes button glow when settings have been modified */
        #applySettingsBtn.apply-glow {
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.8), 0 0 40px rgba(16, 185, 129, 0.4);
            animation: apply-glow-pulse 1.5s ease-in-out infinite;
        }
        @keyframes apply-glow-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.8), 0 0 40px rgba(16, 185, 129, 0.4); }
            50% { box-shadow: 0 0 28px rgba(16, 185, 129, 1), 0 0 50px rgba(16, 185, 129, 0.6); }
        }
    </style>
</head>
<body>
    <!-- Shared Navigation (same structure as Home/Resources for consistent mobile nav) -->
    <div id="shared-navigation"></div>
    
    <div class="container">
        <div id="gameInterface" class="game-interface">
            <div class="game-header">
                <div class="action-buttons">
                    <button class="action-button leaderboard-btn" onclick="openLeaderboardWindow()">üèÜ Leaderboard</button>
                    <button class="action-button stats-btn" onclick="showStats()">üìä Stats</button>
                    <button class="action-button settings-btn" onclick="toggleSettings()">‚öôÔ∏è Settings</button>
                    <button class="action-button settings-btn" onclick="exportData()">üíæ Export</button>
                    <button class="action-button" id="finalizeBtn" style="background: linear-gradient(45deg, #fbbf24, #f59e0b); display: none;" onclick="finalizeGame()">üèÅ Finalize Game</button>
                </div>
            </div>

            <div class="game-info">
                <div class="current-game" id="currentGameTitle">Custom</div>
                <div class="game-status" id="gameStatus">üéØ Custom Game ‚Ä¢ 5 Rounds ‚Ä¢ 3 Throws per Round ‚Ä¢ Max Score: 5</div>
                <div id="gameNameDisplay" style="color: #94a3b8; font-size: 1rem; margin-top: 5px; display: none;"></div>
                <div id="finalizedBanner" style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1e293b; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center; font-weight: bold; font-size: 1.1rem; display: none;">üîí GAME FINALIZED - RESULTS LOCKED üîí</div>
            </div>

            <!-- Settings Panel -->
            <div id="settingsPanel" style="background: rgba(30, 41, 59, 0.9); border: 1px solid #475569; border-radius: 15px; padding: 25px; margin-bottom: 30px; display: none;">
                <div style="font-size: 1.3rem; font-weight: bold; margin-bottom: 20px; display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span>‚öôÔ∏è</span>
                        <span>Custom Game Settings</span>
                    </div>
                    <button onclick="resetSettingsToDefaultsInPanel()" style="background: #64748b; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 500; transition: all 0.3s ease;">Reset</button>
                </div>
                
                <div id="gameStartedWarning" style="background: rgba(245, 101, 101, 0.1); border: 1px solid #ef4444; padding: 15px; border-radius: 10px; margin-bottom: 20px; display: none;">
                    <div style="color: #ef4444; font-weight: bold; margin-bottom: 5px;">‚ö†Ô∏è Game In Progress</div>
                    <div style="color: #fca5a5; font-size: 0.9rem;">Most settings are locked once scoring begins. Use "Reset Game" to change configuration.</div>
                </div>
                
                <!-- Basic Game Configuration -->
                <div class="custom-config">
                    <h4 style="margin-bottom: 15px; color: #e2e8f0; display: flex; align-items: center; gap: 10px;">
                        <span>üéØ</span>
                        <span>Basic Game Configuration</span>
                    </h4>
                    <div class="config-grid">
                        <div class="config-item">
                            <label class="config-label">Game Name</label>
                            <input type="text" id="gameNameInput" placeholder="Enter custom game name..." maxlength="50" class="config-input">
                        </div>
                        <div class="config-item">
                            <label class="config-label">Number of Rounds</label>
                            <input type="number" id="roundsInput" min="1" max="20" value="5" class="config-input">
                        </div>
                        <div class="config-item">
                            <label class="config-label">Throws per Round</label>
                            <input type="number" id="throwsInput" min="1" max="10" value="3" class="config-input">
                        </div>
                        <div class="config-item">
                            <label class="config-label">Max Score per Throw</label>
                            <input type="number" id="maxScoreInput" min="1" max="20" value="5" class="config-input">
                            <div style="margin-top: 8px; display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="hideScoreTilesCheckbox" onchange="toggleHideScoreTiles()" style="cursor: pointer;">
                                <label for="hideScoreTilesCheckbox" style="color: #94a3b8; font-size: 0.9rem; cursor: pointer; user-select: none;">Hide Score Tiles</label>
                            </div>
                        </div>
                        <div class="config-item">
                            <label class="config-label">Tiebreaker Mode</label>
                            <select id="tiebreakerSelect" class="config-input">
                                <option value="sudden-death">Sudden Death (1 throw each)</option>
                                <option value="sudden-death-round">Sudden Death Round (3 throws each)</option>
                                <option value="no-tiebreaker">No Tiebreaker (Allow ties)</option>
                            </select>
                        </div>
                        <div class="config-item">
                            <label class="config-label">Finalization Mode</label>
                            <select id="finalizationModeSelect" class="config-input">
                                <option value="auto" selected>Auto (finalize when all players complete)</option>
                                <option value="manual">Manual (finalize with button only)</option>
                            </select>
                        </div>
                        <div class="config-item">
                            <label class="config-label">Number of Variables</label>
                            <input type="number" id="numDistancesSelect" class="config-input" min="1" max="20" value="5" onchange="onNumDistancesChange()">
                        </div>
                        <div class="config-item">
                            <label class="config-label" style="display: flex; align-items: center; gap: 8px;">
                                <span>Play Mode</span>
                                <span style="display: flex; align-items: center; gap: 4px;">
                                    <input type="checkbox" id="distancesOnTopCheckbox" onchange="updateDistancesOnTop()" style="width: 14px; height: 14px; cursor: pointer;">
                                    <span>üîÑ</span>
                                </span>
                            </label>
                            <select id="playModeSelect" onchange="updatePlayMode()" class="config-input">
                                <option value="sequential" selected>Sequential (2m‚Üí3m‚Üí4m‚Üí5m‚Üí6m, repeat)</option>
                                <option value="consecutive">Consecutive (all rounds at 2m, then all at 3m, etc.)</option>
                            </select>
                        </div>
                        <div class="config-item">
                            <label class="config-label">Game Mode</label>
                            <select id="distancePresetSelect" onchange="updateDistancePreset()" class="config-input">
                                <option value="" selected disabled>Select a game mode...</option>
                                <option value="silhouette">Silhouette</option>
                                <option value="texas-t">Texas T</option>
                                <option value="custom">Custom (Set your own)</option>
                                <option value="" disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Custom Presets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
                            </select>
                        </div>
                        <div class="config-item">
                            <label class="config-label">Save Current Settings</label>
                            <div style="display: flex; flex-direction: row; gap: 8px; align-items: center; flex-wrap: nowrap;">
                                <button id="savePresetBtn" onclick="saveGamePreset()" style="background: #059669; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 500; transition: all 0.3s ease; min-width: 120px;">üíæ Save as Preset</button>
                                <button onclick="removeSelectedPreset()" style="background: #ef4444; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 500; transition: all 0.3s ease; min-width: 120px;">üóëÔ∏è Remove Preset</button>
                            </div>
                        </div>
                        <!-- Variable Labels Collapsible Section -->
                        <div class="collapsible-section collapsed" id="distanceLabelsSection" style="grid-column: 1 / -1; width: 100%;">
                            <div class="collapsible-header" onclick="toggleDistanceLabelsSection()">
                                <h4>
                                    <span>üìè</span>
                                    <span>Variable Labels</span>
                                </h4>
                                <span class="collapsible-toggle">‚ñº</span>
                            </div>
                            <div class="collapsible-content">
                                <div style="color: #94a3b8; font-size: 0.9rem; margin-bottom: 20px;">
                                    Set custom variable labels for each round. Examples: "2m", "10 feet", "Close Range", etc.
                                </div>
                                <div id="distanceLabelsGrid" class="config-grid">
                                    <!-- Distance label inputs will be generated dynamically -->
                                </div>
                            </div>
                        </div>
                        <div class="config-item" style="grid-column: 1 / -1; width: 100%;">
                            <label class="config-label">üìù Game Mode Notes</label>
                            
                            <!-- Read-only notes display (shown when notes exist) -->
                            <div id="gameNotesDisplay" style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 10px; color: #cbd5e1; font-size: 0.9rem; line-height: 1.5; display: none; white-space: pre-wrap; word-wrap: break-word; position: relative; width: 100%; box-sizing: border-box;">
                                <div style="color: #94a3b8; font-size: 0.8rem; margin-bottom: 8px; font-weight: 500;">üìù Notes for this game mode:</div>
                                <div id="gameNotesContent" style="padding-right: 80px;"></div>
                                <button id="editNotesBtn" onclick="editNotes()" style="position: absolute; top: 12px; right: 12px; background: #3b82f6; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.3s ease;">‚úèÔ∏è Edit</button>
                            </div>
                            
                            <!-- Editable textarea (shown when no notes exist) -->
                            <div id="gameNotesEditContainer" style="display: none; width: 100%; box-sizing: border-box;">
                                <textarea id="gameNotesInput" placeholder="Enter notes about this game mode (e.g., rules, strategies, special instructions)..." class="config-input" rows="4" style="width: 100%; resize: vertical; min-height: 120px; max-height: 400px; font-family: inherit; margin-bottom: 10px; box-sizing: border-box; padding: 12px;"></textarea>
                                <button id="saveNotesBtn" onclick="saveNotes()" style="background: #059669; border: none; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease;">üíæ Save Notes</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <button id="applySettingsBtn" onclick="applySettings()" style="background: #10b981; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease;">Apply Changes</button>
                    <button onclick="clearScores()" style="background: #f59e0b; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease;">Clear Scores</button>
                    <button onclick="clearPlayers()" style="background: #ef4444; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease;">Clear Players</button>
                    <button onclick="exportData()" style="background: #8b5cf6; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease;">Export Data</button>
                </div>
            </div>

            <!-- Custom Distance Configuration Panel (moved outside settings panel) -->
            <div id="customDistancePanel" style="display: none; background: rgba(30, 41, 59, 0.9); border: 1px solid #475569; border-radius: 15px; padding: 25px; margin-bottom: 30px;">
                <h4 style="margin-bottom: 15px; color: #e2e8f0; display: flex; align-items: center; gap: 10px;">
                    <span>üìè</span>
                    <span>Custom Distance Labels</span>
                </h4>
                <div style="color: #94a3b8; font-size: 0.9rem; margin-bottom: 20px;">
                    Set custom distance labels for each round. Examples: "2m", "10 feet", "Close Range", etc.
                </div>
                <div id="distanceLabelsGrid" class="config-grid">
                    <!-- Distance label inputs will be generated dynamically -->
                </div>
            </div>

            <!-- Player Management Controls -->
            <div class="player-controls">
                <div class="pagination-controls" id="paginationControls" style="display: none;">
                    <div class="pagination-info">
                        <span id="playerCount">0 players</span>
                    </div>
                    <div class="pagination-right">
                        <div class="pagination-dropdown">
                            <select id="playersPerPage" onchange="changePlayersPerPage()" style="padding: 5px; background: rgba(30, 41, 59, 0.8); color: white; border: 1px solid #475569; border-radius: 5px;">
                                <option value="20" selected>20 per page</option>
                                <option value="30">30 per page</option>
                                <option value="50">50 per page</option>
                                <option value="100">100 per page</option>
                                <option value="all">Show All</option>
                            </select>
                        </div>
                        <div class="pagination-buttons">
                            <button id="prevPageBtn" onclick="changePage(-1)" disabled>‚Üê Previous</button>
                            <span id="pageInfo">Page 1 of 1</span>
                            <button id="nextPageBtn" onclick="changePage(1)" disabled>Next ‚Üí</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="players-grid" id="playersGrid"></div>

            <!-- Bottom Pagination Controls -->
            <div class="pagination-controls" id="bottomPaginationControls" style="display: none; margin-top: 20px;">
                <div class="pagination-info">
                    <span id="bottomPlayerCount">0 players</span>
                </div>
                <div class="pagination-right">
                    <div class="pagination-dropdown">
                        <select id="bottomPlayersPerPage" onchange="changePlayersPerPage()" style="padding: 5px; background: rgba(30, 41, 59, 0.8); color: white; border: 1px solid #475569; border-radius: 5px;">
                            <option value="20" selected>20 per page</option>
                            <option value="30">30 per page</option>
                            <option value="50">50 per page</option>
                            <option value="100">100 per page</option>
                            <option value="all">Show All</option>
                        </select>
                    </div>
                    <div class="pagination-buttons">
                        <button id="bottomPrevPageBtn" onclick="changePage(-1)" disabled>‚Üê Previous</button>
                        <span id="bottomPageInfo">Page 1 of 1</span>
                        <button id="bottomNextPageBtn" onclick="changePage(1)" disabled>Next ‚Üí</button>
                    </div>
                </div>
            </div>

            <div class="add-player">
                <div style="display: flex; gap: 15px; justify-content: center; align-items: center; flex-wrap: wrap;">
                    <button class="add-player-btn" onclick="addPlayer()" id="addPlayerBtn">üë• Add Player</button>
                    <button class="add-player-btn" onclick="importFromManagement()" id="importPlayersBtn" style="background: linear-gradient(45deg, #8b5cf6, #a855f7);" title="Import players from Management.html (click 'Import to Custom' in Management first)">üì• Import Players</button>
                </div>
            </div>
        </div>

        <!-- Floating Leaderboard Window -->
        <div id="leaderboardWindow" class="leaderboard-window">
            <div class="leaderboard-header" id="leaderboardHeader">
                <div class="leaderboard-title">
                    <span>üèÜ</span>
                    <div>
                        <div style="font-size: 1.1rem;">Live Leaderboard</div>
                        <div style="font-size: 0.8rem; color: #94a3b8;" id="leaderboardSubtitle">Game Rankings</div>
                    </div>
                </div>
                <div class="leaderboard-controls">
                    <button class="leaderboard-btn-small" onclick="toggleLeaderboardSize()" title="Toggle Size">‚¨ú</button>
                    <button class="close-btn" onclick="toggleLeaderboard()">√ó</button>
                </div>
            </div>
            <div class="leaderboard-content" id="leaderboardContent">
                <!-- Leaderboard items will be populated here -->
            </div>
            <div class="resize-handle" id="resizeHandle"></div>
        </div>
    </div>

    <script src="shared-functions.js"></script>
    <script src="shared-sidebar.js"></script>
    <script>
        // Game state
        var gameState = {
            type: 'Custom',
            rounds: 5,
            throwsPerRound: 3,
            maxScore: 5,
            targetRings: [5, 4, 3, 2, 1, 0],
            distances: ['2 Meters', '3 Meters', '4 Meters', '5 Meters', '6 Meters'],
            distancePreset: '',
            numDistances: 5,
            playMode: 'sequential', // 'sequential' or 'consecutive'
            distancesOnTop: true, // true = Variable row on top, false = Rounds row on top (like walkback)
            isWalkback: false,
            isGolf: false,
            players: [],
            editingThrow: null,
            currentRound: 1,
            currentThrow: 1,
            viewingRound: 1,
            gameFinalized: false,
            gameName: '',
            tiebreakerMode: 'sudden-death',
            finalizationMode: 'auto', // 'auto' or 'manual'
            inTiebreaker: false,
            currentPage: 1,
            playersPerPage: 20,
            totalPages: 1,
            hideScoreTiles: false,
            notes: ''
        };

        // Global variables
        var playerId = 1;
        var leaderboardVisible = false;
        var leaderboardDragging = false;
        var leaderboardOffset = { x: 0, y: 0 };
        var settingsVisible = false;
        var leaderboardWindow = null; // Reference to the separate leaderboard window

        // Helper functions for event type display
        function getEventIcon(eventType) {
            switch(eventType) {
                case 'knife': return 'üîÑ';
                case 'tomahawk': return 'üîÑ';
                case 'quickdraw': return '‚ö°';
                case 'golf': return '‚õ≥';
                case 'custom': return 'üéØ';
                case 'sidegame': return 'üéØ';
                default: return 'üéØ';
            }
        }

        function getEventTypeLabel(eventType) {
            switch(eventType) {
                case 'knife': return 'Knife Walkback';
                case 'tomahawk': return 'Tomahawk Walkback';
                case 'quickdraw': return 'Quick Draw';
                case 'sidegame': return 'Side Game';
                default: return 'Event';
            }
        }

        // Add missing utility functions
        function hasGameStarted() {
            return gameState.players.some(function(player) {
                return player.scores.some(function(round) {
                    return round && round.some(function(distance) {
                        return distance && distance.some(function(throwScore) { 
                            return throwScore !== null; 
                        });
                    });
                });
            });
        }

        function isEntireGameComplete() {
            if (gameState.players.length === 0) return false;
            return gameState.players.every(function(player) { return player.gameComplete; });
        }

        function getRoundStatus(player, roundIndex) {
            var round = player.scores[roundIndex];
            if (!round) return 'empty';
            
            var totalThrows = 0;
            var completedThrows = 0;
            
            // Iterate through all distances in this round
            for (var d = 0; d < round.length; d++) {
                var distance = round[d];
                if (distance) {
                    // Iterate through all throws in this distance
                    for (var t = 0; t < distance.length; t++) {
                        totalThrows++;
                        if (distance[t] !== null) {
                            completedThrows++;
                        }
                    }
                }
            }
            
            if (completedThrows === 0) return 'empty';
            if (completedThrows === totalThrows) return 'completed';
            return 'partial';
        }

        function isDistanceComplete(player, roundIndex, distanceIndex) {
            if (!player.scores[roundIndex] || !player.scores[roundIndex][distanceIndex]) return false;
            
            return player.scores[roundIndex][distanceIndex].every(function(throwScore) {
                return throwScore !== null;
            });
        }

        function getScoreColorClass(score) {
            var scoreColors = {
                0: 'score-0', 1: 'score-1', 2: 'score-2', 3: 'score-3', 4: 'score-4', 5: 'score-5',
                6: 'score-6', 7: 'score-7', 8: 'score-8', 9: 'score-9', 10: 'score-10', 11: 'score-11',
                12: 'score-12', 13: 'score-13', 14: 'score-14', 15: 'score-15', 16: 'score-16', 17: 'score-17',
                18: 'score-18', 19: 'score-19', 20: 'score-20', 21: 'score-21', 22: 'score-22', 23: 'score-23',
                24: 'score-24', 25: 'score-25', 26: 'score-26', 27: 'score-27', 28: 'score-28', 29: 'score-29',
                30: 'score-30', 31: 'score-31', 32: 'score-32', 33: 'score-33', 34: 'score-34', 35: 'score-35',
                36: 'score-36', 37: 'score-37', 38: 'score-38', 39: 'score-39', 40: 'score-40', 41: 'score-41',
                42: 'score-42', 43: 'score-43', 44: 'score-44', 45: 'score-45', 46: 'score-46', 47: 'score-47',
                48: 'score-48', 49: 'score-49', 50: 'score-50'
            };
            
            return scoreColors[score] || 'score-other';
        }

        function getDefaultDistances(preset, numDistances) {
            var distances = [];
            
            switch(preset) {
                case 'amateur':
                    distances = ['2 Meters', '3 Meters', '4 Meters', '5 Meters', '6 Meters', '7 Meters', '8 Meters', '9 Meters', '10 Meters', '11 Meters', '12 Meters', '13 Meters', '14 Meters', '15 Meters', '16 Meters', '17 Meters', '18 Meters', '19 Meters', '20 Meters', '21 Meters'];
                    break;
                case 'professional':
                    distances = ['3 Meters', '4 Meters', '5 Meters', '6 Meters', '7 Meters', '8 Meters', '9 Meters', '10 Meters', '11 Meters', '12 Meters', '13 Meters', '14 Meters', '15 Meters', '16 Meters', '17 Meters', '18 Meters', '19 Meters', '20 Meters', '21 Meters', '22 Meters'];
                    break;
                case 'texas-t':
                    distances = ['Card 1', 'Card 2', 'Card 3', 'Card 4', 'Card 5'];
                    break;
                default:
                    distances = ['2 Meters', '3 Meters', '4 Meters', '5 Meters', '6 Meters', '7 Meters', '8 Meters', '9 Meters', '10 Meters', '11 Meters', '12 Meters', '13 Meters', '14 Meters', '15 Meters', '16 Meters', '17 Meters', '18 Meters', '19 Meters', '20 Meters', '21 Meters'];
                    break;
            }
            
            // Return only the requested number of distances
            var requestedNum = numDistances || gameState.numDistances || 5;
            return distances.slice(0, requestedNum);
        }

        function showTimedNotification(message, duration) {
            var notification = document.createElement('div');
            notification.style.cssText = 'position: fixed; top: 20%; right: 20px; background: linear-gradient(45deg, #f59e0b, #d97706); color: white; padding: 15px 25px; border-radius: 12px; font-size: 1rem; font-weight: bold; z-index: 10000; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3); border: 2px solid #fbbf24; max-width: 300px;';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(function() {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, duration);
        }

        function getTiebreakerDisplayName(tiebreakerMode) {
            switch(tiebreakerMode) {
                case 'sudden-death': return 'Sudden Death Tiebreaker';
                case 'sudden-death-round': return 'Sudden Death Round Tiebreaker';
                default: return 'Tiebreaker';
            }
        }

        function getTiebreakerModeName(tiebreakerMode) {
            switch(tiebreakerMode) {
                case 'sudden-death': return 'Sudden Death (1 throw each)';
                case 'sudden-death-round': return 'Sudden Death Round (3 throws each)';
                case 'no-tiebreaker': return 'No Tiebreaker (Allow ties)';
                default: return 'Standard';
            }
        }

        function updatePlayerName(playerId, newName) {
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                player.name = newName;
                
                if (leaderboardVisible) {
                    updateLeaderboard();
            updateLeaderboardWindow();
                }
                updateLeaderboardWindow();
                
                saveGameState(); // Auto-save after name change
            }
        }

        function calculateGameStatistics(gameState) {
            var stats = {
                highestScore: 0,
                highestScorePlayer: '',
                lowestScore: Infinity,
                lowestScorePlayer: '',
                averageScore: 0,
                totalBullseyes: 0,
                perfectRounds: 0,
                zeroRounds: 0
            };
            
            var totalScore = 0;
            
            gameState.players.forEach(function(player) {
                var playerTotal = player.total + (player.tiebreakerTotal || 0);
                
                if (playerTotal > stats.highestScore) {
                    stats.highestScore = playerTotal;
                    stats.highestScorePlayer = player.name;
                }
                
                if (playerTotal < stats.lowestScore) {
                    stats.lowestScore = playerTotal;
                    stats.lowestScorePlayer = player.name;
                }
                
                totalScore += playerTotal;
                stats.totalBullseyes += player.bullseyes;
                
                // Count perfect and zero distances
                player.scores.forEach(function(round) {
                    if (round) {
                        round.forEach(function(distance) {
                            if (distance) {
                                var distanceTotal = distance.reduce(function(sum, score) { return sum + (score || 0); }, 0);
                                var maxDistanceScore = gameState.throwsPerRound * gameState.maxScore;
                                
                                if (distanceTotal === maxDistanceScore) {
                                    stats.perfectRounds++;
                                } else if (distanceTotal === 0) {
                                    stats.zeroRounds++;
                                }
                            }
                        });
                    }
                });
            });
            
            stats.averageScore = gameState.players.length > 0 ? 
                (totalScore / gameState.players.length).toFixed(1) : 0;
            
            if (stats.lowestScore === Infinity) {
                stats.lowestScore = 0;
                stats.lowestScorePlayer = 'N/A';
            }
            
            return stats;
        }

        function createExportHeader(gameState) {
            var date = new Date();
            var exportText = '';
            
            // Header
            exportText += 'üéØ'.repeat(25) + '\n';
            exportText += 'TRIPLE NICKEL COMPREHENSIVE GAME REPORT\n';
            exportText += 'üéØ'.repeat(25) + '\n\n';
            
            // Game Information
            exportText += 'GAME INFORMATION:\n';
            exportText += '='.repeat(50) + '\n';
            exportText += 'Game Type: ' + gameState.type + '\n';
            exportText += 'Game Name: ' + (gameState.gameName || 'Unnamed Game') + '\n';
            exportText += 'Date: ' + date.toLocaleDateString() + '\n';
            exportText += 'Time: ' + date.toLocaleTimeString() + '\n';
            exportText += 'Total Players: ' + gameState.players.length + '\n';
            exportText += 'Rounds: ' + gameState.rounds + '\n';
            exportText += 'Throws per Round: ' + gameState.throwsPerRound + '\n';
            exportText += 'Max Score per Throw: ' + gameState.maxScore + '\n';
            exportText += 'Scoring System: ' + (gameState.isGolf ? 'Golf (Lower is Better)' : 'Standard (Higher is Better)') + '\n';
            exportText += 'Tiebreaker Mode: ' + getTiebreakerModeName(gameState.tiebreakerMode) + '\n';
            exportText += 'Game Status: ' + (gameState.gameFinalized ? 'FINALIZED' : gameState.inTiebreaker ? 'IN TIEBREAKER' : 'IN PROGRESS') + '\n';
            exportText += '\n';
            
            return exportText;
        }

        function downloadTextFile(content, filename) {
            var blob = new Blob([content], { type: 'text/plain' });
            var url = URL.createObjectURL(blob);
            var link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function createModal(id, title, content, buttons) {
            var overlay = document.createElement('div');
            overlay.id = id;
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;';
            
            var modal = document.createElement('div');
            modal.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #f59e0b; border-radius: 20px; padding: 40px; max-width: 600px; width: 90%; text-align: center; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);';
            
            var titleEl = document.createElement('div');
            titleEl.style.cssText = 'font-size: 1.8rem; font-weight: bold; color: #f59e0b; margin-bottom: 20px;';
            titleEl.textContent = title;
            modal.appendChild(titleEl);
            
            var contentEl = document.createElement('div');
            contentEl.innerHTML = content;
            modal.appendChild(contentEl);
            
            if (buttons && buttons.length > 0) {
                var buttonsDiv = document.createElement('div');
                buttonsDiv.style.cssText = 'display: flex; gap: 15px; justify-content: center; margin-top: 20px;';
                
                buttons.forEach(function(button) {
                    var btn = document.createElement('button');
                    btn.style.cssText = 'background: ' + (button.color || '#3b82f6') + '; border: none; color: white; padding: 12px 25px; border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;';
                    btn.textContent = button.text;
                    btn.onclick = button.onclick;
                    buttonsDiv.appendChild(btn);
                });
                
                modal.appendChild(buttonsDiv);
            }
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            return overlay;
        }

        function closeModal(modalId) {
            var modal = document.getElementById(modalId);
            if (modal) {
                modal.remove();
            }
        }

        function initializeCommonFeatures() {
            // Basic initialization - can be expanded as needed
            console.log('Common features initialized');
        }

        // Pagination functions
        function updatePaginationControls() {
            try {
                const totalPlayers = gameState.players ? gameState.players.length : 0;
                
                // Always calculate pagination values first
                console.log('üîÑ updatePaginationControls - Total players:', totalPlayers);
                
                // Calculate pagination
                const playersPerPage = gameState.playersPerPage === 'all' ? totalPlayers : parseInt(gameState.playersPerPage);
                console.log('üîÑ Players per page:', playersPerPage, 'Type:', typeof playersPerPage, 'gameState.playersPerPage:', gameState.playersPerPage);
                
                gameState.totalPages = gameState.playersPerPage === 'all' ? 1 : Math.ceil(totalPlayers / playersPerPage);
                console.log('üîÑ Total pages calculated:', gameState.totalPages, 'Total players:', totalPlayers, 'Calculation:', totalPlayers, '/', playersPerPage, '=', totalPlayers / playersPerPage);
                
                // Validate current page
                if (gameState.currentPage > gameState.totalPages && gameState.totalPages > 0) {
                    gameState.currentPage = gameState.totalPages;
                }
                if (gameState.currentPage < 1) {
                    gameState.currentPage = 1;
                }
                
                // Get pagination controls elements (both top and bottom)
                const paginationControls = document.getElementById('paginationControls');
                const bottomPaginationControls = document.getElementById('bottomPaginationControls');
                
                // Show/hide pagination controls based on player count
                // Once there are 21+ players, always show pagination controls regardless of dropdown setting
                const shouldShowPagination = totalPlayers >= 21 && gameState.playersPerPage !== 'all';
                
                if (shouldShowPagination) {
                    if (paginationControls) {
                        paginationControls.style.display = 'block';
                    }
                    if (bottomPaginationControls) {
                        bottomPaginationControls.style.display = 'block';
                    }
                    console.log('üîÑ Pagination controls shown - Players:', totalPlayers, 'Per page:', gameState.playersPerPage);
                } else {
                    if (paginationControls) {
                        paginationControls.style.display = 'none';
                    }
                    if (bottomPaginationControls) {
                        bottomPaginationControls.style.display = 'none';
                    }
                    console.log('üîÑ Pagination controls hidden - Players:', totalPlayers, 'Per page:', gameState.playersPerPage);
                }
                
                // Update pagination info and controls
                const playerCountText = totalPlayers + ' player' + (totalPlayers !== 1 ? 's' : '');
                
                // Update player counts
                const playerCountEl = document.getElementById('playerCount');
                const bottomPlayerCountEl = document.getElementById('bottomPlayerCount');
                if (playerCountEl) playerCountEl.textContent = playerCountText;
                if (bottomPlayerCountEl) bottomPlayerCountEl.textContent = playerCountText;
                
                // Update page info
                const pageText = 'Page ' + gameState.currentPage + ' of ' + gameState.totalPages;
                const pageInfoEl = document.getElementById('pageInfo');
                const bottomPageInfoEl = document.getElementById('bottomPageInfo');
                if (pageInfoEl) pageInfoEl.textContent = pageText;
                if (bottomPageInfoEl) bottomPageInfoEl.textContent = pageText;
                
                // Update button states
                const prevDisabled = gameState.currentPage <= 1;
                const nextDisabled = gameState.currentPage >= gameState.totalPages;
                
                const prevBtn = document.getElementById('prevPageBtn');
                const nextBtn = document.getElementById('nextPageBtn');
                const bottomPrevBtn = document.getElementById('bottomPrevPageBtn');
                const bottomNextBtn = document.getElementById('bottomNextPageBtn');
                
                if (prevBtn) prevBtn.disabled = prevDisabled;
                if (nextBtn) nextBtn.disabled = nextDisabled;
                if (bottomPrevBtn) bottomPrevBtn.disabled = prevDisabled;
                if (bottomNextBtn) bottomNextBtn.disabled = nextDisabled;
                
                // Update dropdown values
                const playersPerPageEl = document.getElementById('playersPerPage');
                const bottomPlayersPerPageEl = document.getElementById('bottomPlayersPerPage');
                if (playersPerPageEl) {
                    playersPerPageEl.value = gameState.playersPerPage;
                    console.log('üîÑ Top dropdown value set to:', gameState.playersPerPage);
                }
                if (bottomPlayersPerPageEl) {
                    bottomPlayersPerPageEl.value = gameState.playersPerPage;
                    console.log('üîÑ Bottom dropdown value set to:', gameState.playersPerPage);
                }
            } catch (error) {
                console.error('Error updating pagination controls:', error);
            }
        }
        
        function changePage(direction) {
            const totalPlayers = gameState.players ? gameState.players.length : 0;
            const playersPerPage = parseInt(gameState.playersPerPage) || 20;
            
            // Calculate new page
            const newPage = gameState.currentPage + direction;
            
            // Validate page bounds
            if (newPage < 1 || newPage > gameState.totalPages) {
                showTimedNotification('Cannot go to page ' + newPage + '. Valid range: 1 to ' + gameState.totalPages, 2000);
                return;
            }
            
            gameState.currentPage = newPage;
            
            // Calculate expected start and end indices
            const startIndex = (gameState.currentPage - 1) * playersPerPage;
            const endIndex = Math.min(startIndex + playersPerPage, totalPlayers);
            
            showTimedNotification('Page ' + gameState.currentPage + ': Showing players ' + (startIndex + 1) + '-' + endIndex + ' of ' + totalPlayers, 2000);
            
            updatePaginationControls();
            renderPlayers();
        }
        
        function changePlayersPerPage() {
            console.log('üîÑ changePlayersPerPage called');
            
            // Check which dropdown was changed and get the new value
            const topDropdown = document.getElementById('playersPerPage');
            const bottomDropdown = document.getElementById('bottomPlayersPerPage');
            
            let newValue;
            if (topDropdown && topDropdown.value !== gameState.playersPerPage) {
                newValue = topDropdown.value;
                // Sync bottom dropdown
                if (bottomDropdown) {
                    bottomDropdown.value = newValue;
                }
            } else if (bottomDropdown && bottomDropdown.value !== gameState.playersPerPage) {
                newValue = bottomDropdown.value;
                // Sync top dropdown
                if (topDropdown) {
                    topDropdown.value = newValue;
                }
            } else {
                // Fallback to top dropdown value
                newValue = topDropdown ? topDropdown.value : '20';
            }
            
            console.log('üîÑ New value:', newValue);
            
            gameState.playersPerPage = newValue;
            gameState.currentPage = 1; // Reset to first page
            console.log('üîÑ Updated gameState.playersPerPage to:', gameState.playersPerPage);
            
            updatePaginationControls();
            renderPlayers();
        }
        
        function getPaginatedPlayers() {
            try {
                const totalPlayers = gameState.players ? gameState.players.length : 0;
                
                if (gameState.playersPerPage === 'all' || totalPlayers === 0) {
                    return gameState.players || [];
                }
                
                const playersPerPage = parseInt(gameState.playersPerPage);
                const startIndex = (gameState.currentPage - 1) * playersPerPage;
                const endIndex = Math.min(startIndex + playersPerPage, totalPlayers);
                
                return gameState.players.slice(startIndex, endIndex);
            } catch (error) {
                console.error('Error getting paginated players:', error);
                return gameState.players || [];
            }
        }

        // Initialize pagination dropdown on page load
        function initializePaginationDropdown() {
            console.log('üîÑ initializePaginationDropdown called');
            const topDropdown = document.getElementById('playersPerPage');
            const bottomDropdown = document.getElementById('bottomPlayersPerPage');
            
            if (topDropdown) {
                topDropdown.value = gameState.playersPerPage.toString();
                console.log('üîÑ Top pagination dropdown initialized to:', gameState.playersPerPage);
            }
            
            if (bottomDropdown) {
                bottomDropdown.value = gameState.playersPerPage.toString();
                console.log('üîÑ Bottom pagination dropdown initialized to:', gameState.playersPerPage);
            }
        }

        // Custom sidebar toggle function for game-interface
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const gameInterface = document.querySelector('.game-interface');
            const toggle = document.getElementById('sidebarToggle');
            
            if (sidebar && gameInterface && toggle) {
                sidebar.classList.toggle('collapsed');
                gameInterface.classList.toggle('expanded');
                
                // Update toggle button text
                if (sidebar.classList.contains('collapsed')) {
                    toggle.textContent = '‚ò∞';
                } else {
                    toggle.textContent = '‚úï';
                }
            }
        }

        // Auto-save functionality
        function saveGameState() {
            try {
                const saveData = {
                    gameState: gameState,
                    playerId: playerId,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('customGameState', JSON.stringify(saveData));
            } catch (error) {
                console.error('Error saving game state:', error);
            }
        }

        function loadGameState() {
            try {
                const savedData = localStorage.getItem('customGameState');
                if (savedData) {
                    const parsed = JSON.parse(savedData);
                    if (parsed.gameState) {
                        // Restore game state
                        gameState = parsed.gameState;
                        playerId = parsed.playerId || 1;
                        
                        // Ensure all required properties exist
                        if (!gameState.targetRings) {
                            gameState.targetRings = [5, 4, 3, 2, 1, 0];
                        }
                        if (!gameState.distances || gameState.distances.length === 0) {
                            gameState.distances = getDefaultDistances(gameState.distancePreset || 'amateur', gameState.numDistances || 5);
                        }
                        if (gameState.currentPage === undefined) {
                            gameState.currentPage = 1;
                        }
                        if (gameState.playersPerPage === undefined) {
                            gameState.playersPerPage = 20;
                        }
                        if (gameState.totalPages === undefined) {
                            gameState.totalPages = 1;
                        }
                        
                        // Update UI
                        renderPlayers();
                        updateGameDisplay();
                        updateDistancePreset();
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error loading game state:', error);
            }
            return false;
        }

        // Initialize on page load
        window.onload = function() {
            initializeSidebar(); // Initialize shared sidebar
            initializeCommonFeatures();
            
            // Try to load saved game state first
            var stateLoaded = loadGameState();
            
            // Only add first player if no saved state was loaded
            if (!stateLoaded || gameState.players.length === 0) {
                addPlayer(); // Add first player
            }
            
            updateGameDisplay();
            updateDistancePreset(); // Initialize distance display
            loadCustomPresets(); // Load saved custom presets
            
            // Add event listener for notes input to save to gameState
            var notesInput = document.getElementById('gameNotesInput');
            if (notesInput) {
                notesInput.addEventListener('input', function() {
                    gameState.notes = this.value;
                });
            }
            
            // Initialize pagination controls after a short delay to ensure DOM is ready
            setTimeout(function() {
                initializePaginationDropdown();
                updatePaginationControls();
            }, 100);
            
            // Try to reconnect to leaderboard if it was open
            setTimeout(function() {
                refreshLeaderboardIfOpen();
            }, 500);
            
            // Glow Apply Changes when any setting is changed in the settings panel
            var settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel) {
                settingsPanel.addEventListener('change', function(e) {
                    if (e.target.matches('input, select, textarea')) markSettingsChanged();
                });
                settingsPanel.addEventListener('input', function(e) {
                    if (e.target.matches('input, select, textarea')) markSettingsChanged();
                });
            }
        };

        function addPlayer() {
            if (gameState.gameFinalized) {
                createModal('finalizedWarning', '‚ö†Ô∏è Cannot Add Players', 
                    '<p style="color: #e2e8f0; font-size: 1.1rem; line-height: 1.6;">Cannot add players after the game has been finalized!</p>',
                    [{
                        text: 'OK',
                        color: '#3b82f6',
                        onclick: function() { closeModal('finalizedWarning'); }
                    }]
                );
                return;
            }
            
            // Check if game has started and finalization mode is auto
            if (hasGameStarted() && gameState.finalizationMode === 'auto') {
                createModal('autoModeWarning', '‚ö†Ô∏è Cannot Add Players', 
                    '<p style="color: #e2e8f0; font-size: 1.1rem; line-height: 1.6; margin-bottom: 15px;">Adding players after the game has started is not allowed when <strong style="color: #f59e0b;">Finalization Mode</strong> is set to <strong style="color: #f59e0b;">"Auto"</strong>.</p>' +
                    '<p style="color: #94a3b8; font-size: 1rem; line-height: 1.6;">To add players mid-game, please start a new game with Finalization Mode set to <strong style="color: #10b981;">"Manual"</strong>.</p>',
                    [{
                        text: 'Got It',
                        color: '#3b82f6',
                        onclick: function() { closeModal('autoModeWarning'); }
                    }]
                );
                return;
            }
            
            var player = {
                id: playerId++,
                name: 'Player ' + (gameState.players.length + 1),
                scores: Array(gameState.rounds).fill(null).map(function() { 
                    return Array(gameState.numDistances).fill(null).map(function() { 
                        return Array(gameState.throwsPerRound).fill(null); 
                    });
                }),
                total: 0,
                average: 0,
                bullseyes: 0,
                percentage: 0,
                currentRound: 1,
                currentThrow: 1,
                currentDistance: 1,
                viewingRound: 1,
                viewingDistance: 1,
                gameComplete: false
            };
            
            gameState.players.push(player);
            renderPlayers();
            updateGameDisplay();
            
            if (leaderboardVisible) {
                updateLeaderboard();
            updateLeaderboardWindow();
            }
            
            saveGameState(); // Auto-save after adding player
            showTimedNotification('üë• ' + player.name + ' added to the game!', 2000);
        }

        function removePlayer(playerId) {
            if (gameState.gameFinalized) {
                alert('Cannot remove players after game has been finalized!');
                return;
            }
            
            if (gameState.inTiebreaker) {
                alert('Cannot remove players during a tiebreaker!');
                return;
            }
            
            var playerIndex = gameState.players.findIndex(function(p) { return p.id === playerId; });
            if (playerIndex === -1) return;
            
            var player = gameState.players[playerIndex];
            
            // Check if player has any scores
            var hasScores = player.scores.some(function(round) {
                return round && round.some(function(distance) {
                    return distance && distance.some(function(score) { return score !== null; });
                });
            });
            
            var confirmMessage = hasScores ? 
                'Remove ' + player.name + '? This will permanently delete all their scores!' :
                'Remove ' + player.name + ' from the game?';
            
            showClearPlayersConfirm(confirmMessage, function() {
                // Remove the player
                gameState.players.splice(playerIndex, 1);
                
                // Clear any editing state for this player
                if (gameState.editingThrow && gameState.editingThrow.playerId === playerId) {
                    gameState.editingThrow = null;
                }
                
                renderPlayers();
                updateGameDisplay();
                
                if (leaderboardVisible) {
                    updateLeaderboard();
            updateLeaderboardWindow();
                }
                updateLeaderboardWindow();
                
                showTimedNotification('üë§ ' + player.name + ' removed from the game', 2000);
                
                // If no players left, show helpful message
                if (gameState.players.length === 0) {
                    showTimedNotification('üë• No players remaining. Add a player to continue!', 3000);
                }
                
                saveGameState(); // Auto-save after removing player
            });
        }

        function renderPlayers() {
            var grid = document.getElementById('playersGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            console.log('üéØ Current page:', gameState.currentPage, 'Players per page:', gameState.playersPerPage);
            
            // Get paginated players (disable pagination during tiebreakers for clarity)
            var allPlayersToShow = gameState.players || [];
            var playersToShow = allPlayersToShow;
            
            // Apply pagination only if we have players and not in tiebreaker
            if (!gameState.inTiebreaker && allPlayersToShow && allPlayersToShow.length > 0 && gameState.playersPerPage !== 'all') {
                var playersPerPage = parseInt(gameState.playersPerPage) || 20;
                var startIndex = (gameState.currentPage - 1) * playersPerPage;
                var endIndex = Math.min(startIndex + playersPerPage, allPlayersToShow.length);
                
                // Only apply pagination if we have valid indices
                if (startIndex >= 0 && endIndex > startIndex && startIndex < allPlayersToShow.length) {
                    playersToShow = allPlayersToShow.slice(startIndex, endIndex);
                } else {
                    console.error('Invalid pagination indices: ' + startIndex + ' to ' + endIndex);
                    playersToShow = allPlayersToShow;
                }
            }
            console.log('üéØ Players to show after pagination:', playersToShow ? playersToShow.length : 0);
            
            // Safety check removed - let pagination handle empty results naturally
            
            playersToShow.forEach(function(player) {
                var playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                
                renderRegularPlayer(playerCard, player);
                
                grid.appendChild(playerCard);
            });
            
            // Update pagination controls after rendering players
            updatePaginationControls();
        }

        function renderRegularPlayer(playerCard, player) {
            // Check if this player is in tiebreaker
            var isInTiebreaker = gameState.inTiebreaker && gameState.tiedPlayers && gameState.tiedPlayers.indexOf(player) !== -1;
            var isEliminatedFromTiebreaker = gameState.inTiebreaker && gameState.tiedPlayers && gameState.tiedPlayers.indexOf(player) === -1 && player.gameComplete;
            
            if (isInTiebreaker) {
                renderTiebreakerPlayer(playerCard, player);
                return;
            }
            
            var displayRound = player.viewingRound;
            var displayDistance = player.viewingDistance || 1;
            var displayThrow = player.currentThrow;
            
            if (gameState.editingThrow && gameState.editingThrow.playerId === player.id) {
                displayRound = gameState.editingThrow.round;
                displayDistance = gameState.editingThrow.distance || player.viewingDistance || 1;
                displayThrow = gameState.editingThrow.throw;
            }
            
            var currentRoundScores = (player.scores[displayRound - 1] && player.scores[displayRound - 1][displayDistance - 1]) || Array(gameState.throwsPerRound).fill(null);
            var currentRoundTotal = currentRoundScores.reduce(function(sum, score) { return sum + (score || 0); }, 0);

            var selectedScore = null;
            if (gameState.editingThrow && gameState.editingThrow.playerId === player.id) {
                selectedScore = currentRoundScores[gameState.editingThrow.throw - 1];
            } else if (displayRound === player.currentRound && displayDistance === player.currentDistance) {
                selectedScore = currentRoundScores[player.currentThrow - 1];
            }

            var isViewingPastRound = player.viewingRound < player.currentRound;
            var isViewingFutureRound = player.viewingRound > player.currentRound;

            // Score buttons for custom game (only if not hidden)
            var scoreButtonsHtml = '';
            if (!gameState.hideScoreTiles) {
                scoreButtonsHtml = gameState.targetRings.map(function(score) {
                    var isSelected = selectedScore === score;
                    
                    // Get color for each score
                    var colorMap = {
                        0: '#ef4444',   1: '#f87171',   2: '#f97316',   3: '#eab308',   4: '#22c55e',
                        5: '#10b981',   6: '#14b8a6',   7: '#0ea5e9',   8: '#3b82f6',   9: '#6366f1',
                        10: '#8b5cf6',  11: '#ec4899',  12: '#f43f5e',  13: '#dc2626',  14: '#7c3aed',
                        15: '#d946ef',  16: '#06b6d4',  17: '#059669',  18: '#84cc16',  19: '#f59e0b',
                        20: '#fbbf24',  21: '#fb923c',  22: '#fdba74',  23: '#fcd34d',  24: '#fde047',
                        25: '#a3e635',  26: '#86efac',  27: '#6ee7b7',  28: '#5eead4',  29: '#67e8f9',
                        30: '#7dd3fc',  31: '#93c5fd',  32: '#a5b4fc',  33: '#c4b5fd',  34: '#d8b4fe',
                        35: '#f0abfc',  36: '#f9a8d4',  37: '#fda4af',  38: '#fca5a5',  39: '#fbbf24',
                        40: '#fb7185',  41: '#f472b6',  42: '#e879f9',  43: '#c084fc',  44: '#a78bfa',
                        45: '#818cf8',  46: '#60a5fa',  47: '#38bdf8',  48: '#22d3ee',  49: '#2dd4bf',
                        50: '#34d399'
                    };
                    
                    var backgroundColor = colorMap[score] || '#6b7280';
                    var buttonStyle = 'background: ' + backgroundColor + '; color: white; padding: 15px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 1rem;';
                    
                    if (isSelected) {
                        buttonStyle += ' box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); transform: scale(1.05);';
                    }
                    
                    buttonStyle += ' &:hover { transform: scale(1.1); }';
                    
                    return '<button style="' + buttonStyle + '" onclick="addScore(' + player.id + ', ' + score + ')">' + score + '</button>';
                }).join('');
            }
            
            // Add manual score input for custom scores (always visible)
            var manualInputHtml = '<div style="grid-column: span 6; margin-top: 10px; display: flex; gap: 10px; align-items: center;">' +
                '<input type="number" id="manualScore' + player.id + '" placeholder="Enter score" min="0" max="99" ' +
                'style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 1rem; outline: none; flex: 1;" ' +
                'onkeypress="if(event.key===\'Enter\') addManualScore(' + player.id + ')">' +
                '<button onclick="addManualScore(' + player.id + ')" ' +
                'style="background: linear-gradient(45deg, #8b5cf6, #7c3aed); border: none; color: white; padding: 10px 20px; border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;">' +
                '‚úì Add</button></div>';
            
            scoreButtonsHtml += manualInputHtml;

            var roundNavButtons = Array(gameState.rounds).fill(null).map(function(_, roundIndex) {
                var roundNum = roundIndex + 1;
                var status = getRoundStatus(player, roundIndex);
                var isViewing = roundNum === player.viewingRound;
                
                var className = 'round-nav-btn ';
                if (isViewing) {
                    className += 'current';
                } else {
                    className += status;
                }
                
                return '<button class="' + className + '" onclick="navigateToRound(' + player.id + ', ' + roundNum + ')" title="Round ' + roundNum + '">R' + roundNum + '</button>';
            }).join('');

            // Distance navigation buttons for current round
            var distanceNavButtons = Array(gameState.numDistances).fill(null).map(function(_, distanceIndex) {
                var distanceNum = distanceIndex + 1;
                var isViewing = distanceNum === (player.viewingDistance || 1) && displayRound === player.viewingRound;
                var isComplete = isDistanceComplete(player, displayRound - 1, distanceIndex);
                var isCurrent = distanceNum === (player.currentDistance || 1) && displayRound === player.currentRound;
                
                var className = 'round-nav-btn ';
                if (isViewing) {
                    className += 'current';
                } else if (isComplete) {
                    className += 'completed';
                } else if (isCurrent) {
                    className += 'partial';
                } else {
                    className += 'empty';
                }
                
                // Use distance label if available, otherwise distance number
                var label = gameState.distances[distanceIndex] ? 
                    (gameState.distances[distanceIndex].includes('Meters') ? 
                        gameState.distances[distanceIndex].replace(' Meters', 'M').replace(' meters', 'm') :
                        (gameState.distances[distanceIndex].length > 8 ? 
                            gameState.distances[distanceIndex].substring(0, 6) + '...' :
                            gameState.distances[distanceIndex]
                        )
                    ) : ('D' + distanceNum);
                
                return '<button class="' + className + '" onclick="navigateToDistance(' + player.id + ', ' + displayRound + ', ' + distanceNum + ')" title="' + 
                    (gameState.distances[distanceIndex] ? gameState.distances[distanceIndex] : 'Distance ' + distanceNum) + '">' + label + '</button>';
            }).join('');

            var throwDisplayHtml = Array(gameState.throwsPerRound).fill(null).map(function(_, throwIndex) {
                var score = currentRoundScores[throwIndex];
                var isCurrent = throwIndex === player.currentThrow - 1 && displayRound === player.currentRound && !gameState.editingThrow;
                var isEditing = gameState.editingThrow && 
                                gameState.editingThrow.playerId === player.id && 
                                gameState.editingThrow.round === displayRound && 
                                gameState.editingThrow.throw === throwIndex + 1;
                
                var className = 'throw-box ';
                var backgroundColor = '';
                
                if (isEditing) {
                    className += 'editing';
                } else                 if (score !== null) {
                    className += 'completed';
                    var scoreColorClass = getScoreColorClass(score);
                    var colorMap = {
                        'score-0': '#ef4444',   'score-1': '#f87171',   'score-2': '#f97316',   'score-3': '#eab308',
                        'score-4': '#22c55e',   'score-5': '#10b981',   'score-6': '#14b8a6',   'score-7': '#0ea5e9',
                        'score-8': '#3b82f6',   'score-9': '#6366f1',   'score-10': '#8b5cf6',  'score-11': '#ec4899',
                        'score-12': '#f43f5e',  'score-13': '#dc2626',  'score-14': '#7c3aed',  'score-15': '#d946ef',
                        'score-16': '#06b6d4',  'score-17': '#059669',  'score-18': '#84cc16',  'score-19': '#f59e0b',
                        'score-20': '#fbbf24',  'score-21': '#fb923c',  'score-22': '#fdba74',  'score-23': '#fcd34d',
                        'score-24': '#fde047',  'score-25': '#a3e635',  'score-26': '#86efac',  'score-27': '#6ee7b7',
                        'score-28': '#5eead4',  'score-29': '#67e8f9',  'score-30': '#7dd3fc',  'score-31': '#93c5fd',
                        'score-32': '#a5b4fc',  'score-33': '#c4b5fd',  'score-34': '#d8b4fe',  'score-35': '#f0abfc',
                        'score-36': '#f9a8d4',  'score-37': '#fda4af',  'score-38': '#fca5a5',  'score-39': '#fbbf24',
                        'score-40': '#fb7185',  'score-41': '#f472b6',  'score-42': '#e879f9',  'score-43': '#c084fc',
                        'score-44': '#a78bfa',  'score-45': '#818cf8',  'score-46': '#60a5fa',  'score-47': '#38bdf8',
                        'score-48': '#22d3ee',  'score-49': '#2dd4bf',  'score-50': '#34d399',
                        'score-other': '#6b7280' // Gray for anything above 50
                    };
                    var bgColor = colorMap[scoreColorClass] || '#6b7280';
                    
                    // Use white text for all colored backgrounds for better contrast
                    backgroundColor = 'background: ' + bgColor + '; color: white;';
                } else if (isCurrent) {
                    className += 'current';  
                } else {
                    className += 'empty';
                }
                
                var throwNum = throwIndex + 1;
                var roundNum = displayRound;
                
                var clickHandler = score !== null ? 
                    'editThrow(' + player.id + ', ' + roundNum + ', ' + throwNum + ')' : 
                    'navigateToThrow(' + player.id + ', ' + roundNum + ', ' + throwNum + ')';
                
                var tooltip = score !== null ? 
                    'Click to edit this throw (Score: ' + score + ')' : 
                    'Click to navigate to Throw ' + throwNum;
                
                return '<div class="' + className + '" onclick="' + clickHandler + '" title="' + tooltip + '" style="padding: 15px; border-radius: 8px; text-align: center; font-weight: bold; cursor: pointer; transition: all 0.3s ease; position: relative; ' + backgroundColor + ' color: white;">' + (score !== null ? score : throwNum) + '</div>';
            }).join('');
            
            // Calculate total score including tiebreaker
            var totalScore = player.total + (player.tiebreakerTotal || 0);
            
            playerCard.innerHTML = '<div class="player-header">' +
                '<div class="player-name-section">' +
                '<input type="text" class="player-name" value="' + player.name + '" onchange="updatePlayerName(' + player.id + ', this.value)">' +
                '<button onclick="removePlayer(' + player.id + ')" style="background: #ef4444; border: none; color: white; width: 24px; height: 24px; border-radius: 50%; font-size: 0.9rem; font-weight: bold; cursor: pointer; margin-left: 10px; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;" title="Remove Player" onmouseover="this.style.background=\'#dc2626\'" onmouseout="this.style.background=\'#ef4444\'">√ó</button>' +
                '</div>' +
                '<div class="player-stats">' +
                '<div class="total-score">' + totalScore + '</div>' +
                '<div class="score-details">' +
                'Avg: ' + player.average + '<br>Percent: ' + (player.percentage || 0) + '%<br>' +
                '<span class="purple">Score: ' + totalScore + '/' + (gameState.rounds * gameState.numDistances * gameState.throwsPerRound * gameState.maxScore) + '</span>' +
                (player.tiebreakerTotal ? '<br><span class="blue">‚ö° Tiebreaker: +' + player.tiebreakerTotal + '</span>' : '') +
                '</div></div></div>' +
                (isEliminatedFromTiebreaker ? '<div style="background: rgba(239, 68, 68, 0.1); border: 1px solid #ef4444; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center; color: #ef4444; font-weight: 500; font-size: 0.9rem;">‚ùå Eliminated from Tiebreaker</div>' : '') +
                (gameState.inTiebreaker && !isInTiebreaker && !isEliminatedFromTiebreaker ? '<div style="background: rgba(59, 130, 246, 0.1); border: 1px solid #3b82f6; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center; color: #3b82f6; font-weight: 500; font-size: 0.9rem;">‚è∏Ô∏è Waiting for Tiebreaker to Complete</div>' : '') +
                '<div style="margin-bottom: 15px; padding: 10px; background: rgba(15, 23, 42, 0.5); border-radius: 8px; border: 1px solid #475569;">' +
                (gameState.distancesOnTop ?
                    '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;"><span style="font-size: 0.8rem; color: #94a3b8; font-weight: 500;">Variable:</span><div style="display: flex; gap: 5px; flex-wrap: wrap;">' + distanceNavButtons + '</div></div>' +
                    '<div style="display: flex; align-items: center; gap: 10px;"><span style="font-size: 0.8rem; color: #94a3b8; font-weight: 500;">Rounds:</span><div style="display: flex; gap: 5px; flex-wrap: wrap;">' + roundNavButtons + '</div></div>' :
                    '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;"><span style="font-size: 0.8rem; color: #94a3b8; font-weight: 500;">Rounds:</span><div style="display: flex; gap: 5px; flex-wrap: wrap;">' + roundNavButtons + '</div></div>' +
                    '<div style="display: flex; align-items: center; gap: 10px;"><span style="font-size: 0.8rem; color: #94a3b8; font-weight: 500;">Variable:</span><div style="display: flex; gap: 5px; flex-wrap: wrap;">' + distanceNavButtons + '</div></div>') +
                '</div>' +
                (isViewingPastRound ? '<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center; color: #a855f7; font-weight: 500; font-size: 0.9rem;">üìú Viewing Past Round - ' + 
                    (gameState.distances[displayRound - 1] ? gameState.distances[displayRound - 1] + ' (Round ' + displayRound + ')' : 'Round ' + displayRound) + '</div>' : '') +
                (isViewingFutureRound ? '<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center; color: #a855f7; font-weight: 500; font-size: 0.9rem;">üîÆ Viewing Future Round - ' + 
                    (gameState.distances[displayRound - 1] ? gameState.distances[displayRound - 1] + ' (Round ' + displayRound + ')' : 'Round ' + displayRound) + '</div>' : '') +
                '<div class="score-input">' +
                '<label class="score-label">' +
                (player.gameComplete ? 
                    'üèÜ GAME COMPLETE - Click any throw below to edit' :
                    gameState.editingThrow && gameState.editingThrow.playerId === player.id ? 
                        '‚úèÔ∏è EDITING - Round ' + displayRound + ', ' + (gameState.distances[(player.viewingDistance || 1) - 1] || 'Distance ' + (player.viewingDistance || 1)) + ', Throw ' + displayThrow :
                        'Round ' + displayRound + ', ' + (gameState.distances[(player.viewingDistance || 1) - 1] || 'Distance ' + (player.viewingDistance || 1)) + (displayRound === player.currentRound ? ', Throw ' + player.currentThrow : '')) +
                '</label>' +
                '<div class="score-buttons" ' + ((player.gameComplete && gameState.gameFinalized) || gameState.inTiebreaker ? 'style="display: none;"' : player.gameComplete ? 'style="display: none;"' : '') + '>' +
                scoreButtonsHtml + '</div>' +
                (player.gameComplete ? '<div style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1e293b; padding: 20px; border-radius: 12px; text-align: center; font-weight: bold; font-size: 1.1rem; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);">üèÜ GAME COMPLETED! üèÜ<br><span style="font-size: 0.9rem; margin-top: 8px; display: block;">Final Score: ' + totalScore + ' points</span>' + (gameState.gameFinalized ? '<br><span style="font-size: 0.8rem; color: #7c2d12;">üîí Results Locked</span>' : '') + '</div>' : '') +
                '</div>' +
                '<div style="margin-bottom: 20px;">' +
                '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">' +
                '<span style="font-size: 0.9rem; font-weight: 500;">' +
                'Round ' + displayRound + ' - ' + (gameState.distances[(player.viewingDistance || 1) - 1] || 'Distance ' + (player.viewingDistance || 1)) +
                '</span>' +
                '<span style="font-size: 0.8rem; color: #94a3b8;">Total: ' + currentRoundTotal + '</span>' +
                '</div>' +
                '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">' +
                throwDisplayHtml + '</div></div>';
        }

        function renderTiebreakerPlayer(playerCard, player) {
            var throwsPerRound = gameState.tiebreakerMode === 'sudden-death' ? 1 : gameState.throwsPerRound;
            var currentRoundScores = [];
            
            if (player.tiebreakerScores && player.tiebreakerScores[gameState.tiebreakerRound - 1]) {
                currentRoundScores = player.tiebreakerScores[gameState.tiebreakerRound - 1];
            }
            
            // Ensure array is proper length
            while (currentRoundScores.length < throwsPerRound) {
                currentRoundScores.push(null);
            }
            
            var selectedScore = null;
            if (!player.tiebreakerComplete && currentRoundScores[player.tiebreakerCurrentThrow - 1] !== undefined) {
                selectedScore = currentRoundScores[player.tiebreakerCurrentThrow - 1];
            }

            // Score buttons for tiebreaker (only if not hidden)
            var scoreButtonsHtml = '';
            if (!gameState.hideScoreTiles) {
                scoreButtonsHtml = gameState.targetRings.map(function(score) {
                    var isSelected = selectedScore === score;
                    
                    // Get color for each score
                    var colorMap = {
                        0: '#ef4444',   1: '#f87171',   2: '#f97316',   3: '#eab308',   4: '#22c55e',
                        5: '#10b981',   6: '#14b8a6',   7: '#0ea5e9',   8: '#3b82f6',   9: '#6366f1',
                        10: '#8b5cf6',  11: '#ec4899',  12: '#f43f5e',  13: '#dc2626',  14: '#7c3aed',
                        15: '#d946ef',  16: '#06b6d4',  17: '#059669',  18: '#84cc16',  19: '#f59e0b',
                        20: '#fbbf24',  21: '#fb923c',  22: '#fdba74',  23: '#fcd34d',  24: '#fde047',
                        25: '#a3e635',  26: '#86efac',  27: '#6ee7b7',  28: '#5eead4',  29: '#67e8f9',
                        30: '#7dd3fc',  31: '#93c5fd',  32: '#a5b4fc',  33: '#c4b5fd',  34: '#d8b4fe',
                        35: '#f0abfc',  36: '#f9a8d4',  37: '#fda4af',  38: '#fca5a5',  39: '#fbbf24',
                        40: '#fb7185',  41: '#f472b6',  42: '#e879f9',  43: '#c084fc',  44: '#a78bfa',
                        45: '#818cf8',  46: '#60a5fa',  47: '#38bdf8',  48: '#22d3ee',  49: '#2dd4bf',
                        50: '#34d399'
                    };
                    
                    var backgroundColor = colorMap[score] || '#6b7280';
                    var buttonStyle = 'background: ' + backgroundColor + '; color: white; padding: 15px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 1rem;';
                    
                    if (isSelected) {
                        buttonStyle += ' box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); transform: scale(1.05);';
                    }
                    
                    buttonStyle += ' &:hover { transform: scale(1.1); }';
                    
                    return '<button style="' + buttonStyle + '" onclick="addScore(' + player.id + ', ' + score + ')">' + score + '</button>';
                }).join('');
            }
            
            // Add manual score input (always visible)
            var manualInputHtml = '<div style="grid-column: span 6; margin-top: 10px; display: flex; gap: 10px; align-items: center;">' +
                '<input type="number" id="manualScore' + player.id + '" placeholder="Enter score" min="0" max="99" ' +
                'style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 1rem; outline: none; flex: 1;" ' +
                'onkeypress="if(event.key===\'Enter\') addManualScore(' + player.id + ')">' +
                '<button onclick="addManualScore(' + player.id + ')" ' +
                'style="background: linear-gradient(45deg, #8b5cf6, #7c3aed); border: none; color: white; padding: 10px 20px; border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;">' +
                '‚úì Add</button></div>';
            
            scoreButtonsHtml += manualInputHtml;

            var throwDisplayHtml = '';
            for (var i = 0; i < throwsPerRound; i++) {
                var score = currentRoundScores[i];
                var isCurrent = i === player.tiebreakerCurrentThrow - 1 && !player.tiebreakerComplete;
                
                var className = 'throw-box ';
                var backgroundColor = '';
                
                if (score !== null && score !== undefined) {
                    className += 'completed';
                    var scoreColorClass = getScoreColorClass(score);
                    var colorMap = {
                        'score-0': '#ef4444',   'score-1': '#f87171',   'score-2': '#f97316',   'score-3': '#eab308',
                        'score-4': '#22c55e',   'score-5': '#10b981',   'score-6': '#14b8a6',   'score-7': '#0ea5e9',
                        'score-8': '#3b82f6',   'score-9': '#6366f1',   'score-10': '#8b5cf6',  'score-11': '#ec4899',
                        'score-12': '#f43f5e',  'score-13': '#dc2626',  'score-14': '#7c3aed',  'score-15': '#d946ef',
                        'score-16': '#06b6d4',  'score-17': '#059669',  'score-18': '#84cc16',  'score-19': '#f59e0b',
                        'score-20': '#fbbf24',  'score-21': '#fb923c',  'score-22': '#fdba74',  'score-23': '#fcd34d',
                        'score-24': '#fde047',  'score-25': '#a3e635',  'score-26': '#86efac',  'score-27': '#6ee7b7',
                        'score-28': '#5eead4',  'score-29': '#67e8f9',  'score-30': '#7dd3fc',  'score-31': '#93c5fd',
                        'score-32': '#a5b4fc',  'score-33': '#c4b5fd',  'score-34': '#d8b4fe',  'score-35': '#f0abfc',
                        'score-36': '#f9a8d4',  'score-37': '#fda4af',  'score-38': '#fca5a5',  'score-39': '#fbbf24',
                        'score-40': '#fb7185',  'score-41': '#f472b6',  'score-42': '#e879f9',  'score-43': '#c084fc',
                        'score-44': '#a78bfa',  'score-45': '#818cf8',  'score-46': '#60a5fa',  'score-47': '#38bdf8',
                        'score-48': '#22d3ee',  'score-49': '#2dd4bf',  'score-50': '#34d399',
                        'score-other': '#6b7280' // Gray for anything above 50
                    };
                    var bgColor = colorMap[scoreColorClass] || '#6b7280';
                    backgroundColor = 'background: ' + bgColor + '; color: white;';
                } else if (isCurrent) {
                    className += 'current';  
                } else {
                    className += 'empty';
                }
                
                throwDisplayHtml += '<div class="' + className + '" style="padding: 15px; border-radius: 8px; text-align: center; font-weight: bold; cursor: pointer; transition: all 0.3s ease; position: relative; ' + backgroundColor + ' color: white;">' + (score !== null && score !== undefined ? score : (i + 1)) + '</div>';
            }
            
            var totalScore = player.total + (player.tiebreakerTotal || 0);
            
            playerCard.innerHTML = '<div class="player-header">' +
                '<div class="player-name-section">' +
                '<input type="text" class="player-name" value="' + player.name + '" onchange="updatePlayerName(' + player.id + ', this.value)">' +
                '<button onclick="removePlayer(' + player.id + ')" style="background: #ef4444; border: none; color: white; width: 24px; height: 24px; border-radius: 50%; font-size: 0.9rem; font-weight: bold; cursor: pointer; margin-left: 10px; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;" title="Remove Player" onmouseover="this.style.background=\'#dc2626\'" onmouseout="this.style.background=\'#ef4444\'">√ó</button>' +
                '</div>' +
                '<div class="player-stats">' +
                '<div class="total-score">' + totalScore + '</div>' +
                '<div class="score-details">' +
                'Avg: ' + player.average + '<br>Percent: ' + (player.percentage || 0) + '%<br>' +
                '<span class="purple">Score: ' + totalScore + '/' + (gameState.rounds * gameState.numDistances * gameState.throwsPerRound * gameState.maxScore) + '</span>' +
                '<br><span class="blue">‚ö° Tiebreaker: +' + (player.tiebreakerTotal || 0) + '</span>' +
                '</div></div></div>' +
                '<div style="background: linear-gradient(135deg, #dc2626, #b91c1c); color: white; padding: 15px; border-radius: 10px; margin-bottom: 15px; text-align: center; font-weight: bold; font-size: 1rem; border: 2px solid #fbbf24;">‚ö° TIEBREAKER ROUND ' + gameState.tiebreakerRound + ' ‚ö°<br><span style="font-size: 0.9rem; margin-top: 5px; display: block;">' + getTiebreakerDisplayName(gameState.tiebreakerMode) + '</span></div>' +
                '<div class="score-input">' +
                '<label class="score-label">' +
                (player.tiebreakerComplete ? 
                    '‚úÖ TIEBREAKER ROUND ' + gameState.tiebreakerRound + ' COMPLETE' :
                    '‚ö° TIEBREAKER - Round ' + gameState.tiebreakerRound + ', Throw ' + player.tiebreakerCurrentThrow) +
                '</label>' +
                '<div class="score-buttons" ' + (player.tiebreakerComplete ? 'style="display: none;"' : '') + '>' +
                scoreButtonsHtml + '</div>' +
                (player.tiebreakerComplete ? '<div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 15px; border-radius: 10px; text-align: center; font-weight: bold; font-size: 1rem;">‚úÖ Round ' + gameState.tiebreakerRound + ' Complete!<br><span style="font-size: 0.9rem; margin-top: 5px; display: block;">Waiting for other players...</span></div>' : '') +
                '</div>' +
                '<div style="margin-bottom: 20px;">' +
                '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">' +
                '<span style="font-size: 0.9rem; font-weight: 500;">Tiebreaker Round ' + gameState.tiebreakerRound + '</span>' +
                '<span style="font-size: 0.8rem; color: #94a3b8;">Total: ' + (player.tiebreakerTotal || 0) + '</span>' +
                '</div>' +
                '<div style="display: grid; grid-template-columns: repeat(' + throwsPerRound + ', 1fr); gap: 8px;">' +
                throwDisplayHtml + '</div></div>';
        }

        function addScore(playerId, score) {
            // Handle tiebreaker scoring
            if (gameState.inTiebreaker) {
                var player = gameState.players.find(function(p) { return p.id === playerId; });
                if (player && gameState.tiedPlayers.indexOf(player) !== -1) {
                    addTiebreakerScore(playerId, score);
                    return;
                }
                // If not a tied player, don't allow scoring during tiebreaker
                return;
            }
            
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (!player) return;

            var roundIndex, distanceIndex, throwIndex;
            var wasEditingExistingScore = false;

            if (gameState.editingThrow && gameState.editingThrow.playerId === playerId) {
                roundIndex = gameState.editingThrow.round - 1;
                distanceIndex = (gameState.editingThrow.distance || player.viewingDistance || 1) - 1;
                throwIndex = gameState.editingThrow.throw - 1;
                wasEditingExistingScore = player.scores[roundIndex] && player.scores[roundIndex][distanceIndex] && player.scores[roundIndex][distanceIndex][throwIndex] !== null;
                gameState.editingThrow = null;
            } else {
                roundIndex = player.currentRound - 1;
                distanceIndex = player.currentDistance - 1;
                throwIndex = player.currentThrow - 1;
            }

            if (!player.scores[roundIndex]) {
                player.scores[roundIndex] = Array(gameState.numDistances).fill(null).map(function() { return Array(gameState.throwsPerRound).fill(null); });
            }
            if (!player.scores[roundIndex][distanceIndex]) {
                player.scores[roundIndex][distanceIndex] = Array(gameState.throwsPerRound).fill(null);
            }

            player.scores[roundIndex][distanceIndex][throwIndex] = score;
            
            var total = 0;
            var completedThrows = 0;
            var bullseyes = 0;
            
            player.scores.forEach(function(round) {
                if (round) {
                    round.forEach(function(distance) {
                        if (distance) {
                            distance.forEach(function(throwScore) {
                                if (throwScore !== null) {
                                    total += throwScore;
                                    completedThrows++;
                                    
                                    if (throwScore === gameState.maxScore) {
                                        bullseyes++;
                                    }
                                }
                            });
                        }
                    });
                }
            });
            
            player.total = total;
            player.average = completedThrows > 0 ? parseFloat((total / completedThrows).toFixed(2)) : 0;
            player.bullseyes = bullseyes;
            
            var maxPossibleScore = gameState.rounds * gameState.numDistances * gameState.throwsPerRound * gameState.maxScore;
            player.percentage = maxPossibleScore > 0 ? parseFloat(((total / maxPossibleScore) * 100).toFixed(1)) : 0;

            if (!wasEditingExistingScore && roundIndex === player.currentRound - 1 && distanceIndex === player.currentDistance - 1 && throwIndex === player.currentThrow - 1) {
                if (gameState.playMode === 'consecutive') {
                    // Consecutive mode: complete all rounds at current distance before moving to next distance
                    if (player.currentThrow < gameState.throwsPerRound) {
                        player.currentThrow++;
                    } else {
                        // Reset throw counter
                        player.currentThrow = 1;
                        
                        if (player.currentRound < gameState.rounds) {
                            // Move to next round at same distance
                            player.currentRound++;
                            player.viewingRound = player.currentRound;
                        } else if (player.currentDistance < gameState.numDistances) {
                            // All rounds at this distance complete, move to next distance
                            player.currentDistance++;
                            player.currentRound = 1;
                            player.viewingDistance = player.currentDistance;
                            player.viewingRound = player.currentRound;
                            
                            var distanceName = gameState.distances[player.currentDistance - 1] || 'Distance ' + player.currentDistance;
                            showTimedNotification('üéØ ' + player.name + ' advanced to ' + distanceName + '!', 3000);
                        } else {
                            // Game complete
                            player.gameComplete = true;
                            showTimedNotification('üèÜ ' + player.name + ' completed the game! Click any throw to edit.', 4000);
                            
                            if (isEntireGameComplete()) {
                                setTimeout(function() {
                                    promptGameFinalization();
                                }, 1500);
                            }
                        }
                    }
                } else {
                    // Sequential mode: complete all distances in current round before moving to next round
                    if (player.currentThrow < gameState.throwsPerRound) {
                        player.currentThrow++;
                    } else {
                        // Reset throw counter
                        player.currentThrow = 1;
                        
                        if (player.currentDistance < gameState.numDistances) {
                            // Move to next distance in same round
                            player.currentDistance++;
                            player.viewingDistance = player.currentDistance;
                            
                            var distanceName = gameState.distances[player.currentDistance - 1] || 'Distance ' + player.currentDistance;
                        } else if (player.currentRound < gameState.rounds) {
                            // All distances in this round complete, move to next round
                            player.currentRound++;
                            player.currentDistance = 1;
                            player.viewingRound = player.currentRound;
                            player.viewingDistance = player.currentDistance;
                            
                            showTimedNotification('üéØ ' + player.name + ' advanced to Round ' + player.currentRound + '!', 3000);
                        } else {
                            // Game complete
                            player.gameComplete = true;
                            showTimedNotification('üèÜ ' + player.name + ' completed the game! Click any throw to edit.', 4000);
                            
                            if (isEntireGameComplete()) {
                                setTimeout(function() {
                                    promptGameFinalization();
                                }, 1500);
                            }
                        }
                    }
                }
            }

            renderPlayers();
            if (leaderboardVisible) {
                updateLeaderboard();
            updateLeaderboardWindow();
            }
            
            saveGameState(); // Auto-save after every score entry
        }

        function addManualScore(playerId) {
            var input = document.getElementById('manualScore' + playerId);
            var score = parseInt(input.value);
            
            if (isNaN(score)) {
                alert('Please enter a valid number!');
                input.focus();
                return;
            }
            
            if (score < 0) {
                alert('Score cannot be negative!');
                input.focus();
                return;
            }
            
            if (score > 99) {
                alert('Score cannot exceed 99!');
                input.focus();
                return;
            }
            
            addScore(playerId, score);
            input.value = '';
        }

        function navigateToThrow(playerId, roundNumber, throwNumber) {
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                player.currentRound = roundNumber;
                player.currentThrow = throwNumber;
                player.viewingRound = roundNumber;
                gameState.editingThrow = null;
                updateGameDisplay();
                renderPlayers();
            }
        }

        function navigateToRound(playerId, roundNumber) {
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                player.viewingRound = roundNumber;
                player.viewingDistance = player.viewingDistance || 1; // Ensure distance is set
                gameState.viewingRound = roundNumber;
                gameState.editingThrow = null;
                updateGameDisplay();
                renderPlayers();
            }
        }

        function navigateToDistance(playerId, roundNumber, distanceNumber) {
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                player.viewingRound = roundNumber;
                player.viewingDistance = distanceNumber;
                gameState.viewingRound = roundNumber;
                gameState.editingThrow = null;
                updateGameDisplay();
                renderPlayers();
            }
        }

        function editThrow(playerId, roundNumber, throwNumber) {
            if (gameState.gameFinalized) {
                alert('Cannot edit scores - game has been finalized and results are locked!');
                return;
            }
            
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                gameState.editingThrow = {
                    playerId: playerId,
                    round: roundNumber,
                    distance: player.viewingDistance || 1,
                    throw: throwNumber
                };
                player.viewingRound = roundNumber;
                gameState.viewingRound = roundNumber;
                renderPlayers();
            }
        }

        function toggleSettings() {
            settingsVisible = !settingsVisible;
            var panel = document.getElementById('settingsPanel');
            if (settingsVisible) {
                panel.style.display = 'block';
                updateSettingsPanel();
                
                // Update custom distance panel visibility based on current preset
                var customPanel = document.getElementById('customDistancePanel');
                if (customPanel) {
                    if (gameState.distancePreset === 'custom') {
                        customPanel.style.display = 'block';
                    } else {
                        customPanel.style.display = 'none';
                    }
                }
            } else {
                panel.style.display = 'none';
                
                // Always hide custom distance panel when closing settings
                var customPanel = document.getElementById('customDistancePanel');
                if (customPanel) {
                    customPanel.style.display = 'none';
                }
            }
        }

        function toggleDistanceLabelsSection() {
            var section = document.getElementById('distanceLabelsSection');
            if (section) {
                var isCollapsed = section.classList.contains('collapsed');
                section.classList.toggle('collapsed');
                
                // If opening the section, generate inputs based on current numDistances
                if (isCollapsed) {
                    generateDistanceLabelInputs();
                }
            }
        }

        function toggleHideScoreTiles() {
            var checkbox = document.getElementById('hideScoreTilesCheckbox');
            if (checkbox) {
                gameState.hideScoreTiles = checkbox.checked;
                renderAllPlayers();
            }
        }

        function updateSettingsPanel() {
            var gameStarted = hasGameStarted();
            
            // Update the settings panel with current values
            document.getElementById('gameNameInput').value = gameState.gameName || '';
            document.getElementById('roundsInput').value = gameState.rounds;
            document.getElementById('throwsInput').value = gameState.throwsPerRound;
            document.getElementById('maxScoreInput').value = gameState.maxScore;
            document.getElementById('tiebreakerSelect').value = gameState.tiebreakerMode || 'sudden-death';
            document.getElementById('finalizationModeSelect').value = gameState.finalizationMode || 'auto';
            document.getElementById('numDistancesSelect').value = gameState.numDistances || 5;
            document.getElementById('playModeSelect').value = gameState.playMode || 'sequential';
            document.getElementById('distancePresetSelect').value = gameState.distancePreset !== undefined ? gameState.distancePreset : '';
            if (gameState.distancesOnTop === undefined || gameState.distancesOnTop === null) {
                gameState.distancesOnTop = (gameState.playMode === 'sequential');
            }
            var distancesOnTopCheckbox = document.getElementById('distancesOnTopCheckbox');
            if (distancesOnTopCheckbox) distancesOnTopCheckbox.checked = gameState.distancesOnTop;
            var hideScoreTilesCheckbox = document.getElementById('hideScoreTilesCheckbox');
            if (hideScoreTilesCheckbox) {
                hideScoreTilesCheckbox.checked = gameState.hideScoreTiles || false;
            }
            
            // Update notes display - this will show read-only or edit mode based on whether notes exist
            updateNotesDisplay();
            
            // Show/hide warning and disable inputs if game has started
            var warning = document.getElementById('gameStartedWarning');
            if (warning) {
                warning.style.display = gameStarted ? 'block' : 'none';
            }
            
            // Disable/enable inputs based on game state
            var inputs = ['gameNameInput', 'roundsInput', 'throwsInput', 'maxScoreInput', 'tiebreakerSelect', 'finalizationModeSelect', 'numDistancesSelect', 'playModeSelect', 'distancePresetSelect', 'gameNotesInput'];
            inputs.forEach(function(inputId) {
                var input = document.getElementById(inputId);
                if (input) {
                    input.disabled = gameStarted;
                    input.style.opacity = gameStarted ? '0.5' : '1';
                    input.style.cursor = gameStarted ? 'not-allowed' : 'auto';
                }
            });
            
            // Update apply button
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn) {
                applyBtn.disabled = gameStarted;
                applyBtn.style.opacity = gameStarted ? '0.5' : '1';
                applyBtn.style.cursor = gameStarted ? 'not-allowed' : 'pointer';
                if (gameStarted) applyBtn.classList.remove('apply-glow');
            }
            
            // Update save preset button
            var savePresetBtn = document.getElementById('savePresetBtn');
            if (savePresetBtn) {
                savePresetBtn.disabled = gameStarted;
                savePresetBtn.style.opacity = gameStarted ? '0.5' : '1';
                savePresetBtn.style.cursor = gameStarted ? 'not-allowed' : 'pointer';
            }
            
            // Remove preset button is always enabled since it doesn't affect game state
            
            // Sync custom distance panel visibility from gameState (do NOT call updateDistancePreset
            // here or it would re-trigger the preset loader and cause recursion when switching modes)
            var customPanel = document.getElementById('customDistancePanel');
            if (customPanel) {
                var dp = gameState.distancePreset || '';
                if (dp === 'texas-t' || dp === 'silhouette' || dp === 'custom' || (dp && dp.startsWith('custom_'))) {
                    customPanel.style.display = 'block';
                } else if (dp === '' || dp === 'amateur' || dp === 'professional') {
                    customPanel.style.display = 'none';
                }
            }
            
            // Update notes display
            updateNotesDisplay();
            
            // Always refresh variable label inputs so they show the current preset's labels
            // (e.g. when user had Variable Labels expanded and switched from Silhouette to Texas T)
            generateDistanceLabelInputs();
        }
        
        // Function to update the notes display based on current preset
        function updateNotesDisplay() {
            var notesDisplay = document.getElementById('gameNotesDisplay');
            var notesContent = document.getElementById('gameNotesContent');
            var notesEditContainer = document.getElementById('gameNotesEditContainer');
            var notesInput = document.getElementById('gameNotesInput');
            
            if (!notesDisplay || !notesContent || !notesEditContainer) {
                console.warn('Notes display elements not found');
                return;
            }
            
            // Check if we have a custom preset selected - check dropdown first, then gameState
            var presetSelect = document.getElementById('distancePresetSelect');
            var preset = presetSelect ? presetSelect.value : '';
            
            console.log('updateNotesDisplay - preset from dropdown:', preset);
            console.log('updateNotesDisplay - gameState.distancePreset:', gameState.distancePreset);
            console.log('updateNotesDisplay - gameState.currentPresetName:', gameState.currentPresetName);
            
            // If dropdown doesn't have a custom preset, check gameState for stored preset info
            if (!preset || !preset.startsWith('custom_')) {
                // Check if gameState has a stored preset name
                if (gameState.currentPresetName) {
                    preset = 'custom_' + gameState.currentPresetName;
                    // Update dropdown to match
                    if (presetSelect) {
                        presetSelect.value = preset;
                    }
                    console.log('updateNotesDisplay - Using currentPresetName:', preset);
                } else if (gameState.distancePreset && gameState.distancePreset.startsWith('custom_')) {
                    // Use gameState.distancePreset if it's a custom preset
                    preset = gameState.distancePreset;
                    if (presetSelect) {
                        presetSelect.value = preset;
                    }
                    console.log('updateNotesDisplay - Using distancePreset:', preset);
                }
            }
            
            var hasNotes = false;
            var notesText = '';
            
            // If a custom preset is selected, try to load its notes
            if (preset && preset.startsWith('custom_')) {
                var presetName = preset.substring(7);
                console.log('updateNotesDisplay - Loading notes for preset:', presetName);
                var customPresets = JSON.parse(localStorage.getItem('customGamePresets') || '{}');
                var presetData = customPresets[presetName];
                
                console.log('updateNotesDisplay - Preset data:', presetData);
                console.log('updateNotesDisplay - Preset notes:', presetData ? presetData.notes : 'no preset data');
                
                if (presetData && presetData.notes && presetData.notes.trim()) {
                    hasNotes = true;
                    notesText = presetData.notes;
                    gameState.notes = presetData.notes;
                    console.log('updateNotesDisplay - Found notes in preset:', notesText);
                } else if (gameState.notes && gameState.notes.trim()) {
                    hasNotes = true;
                    notesText = gameState.notes;
                    console.log('updateNotesDisplay - Using gameState notes:', notesText);
                }
            } else if (preset === 'silhouette') {
                // Silhouette preset has a default note
                hasNotes = true;
                notesText = 'Each thrower gets one attempt at each target';
                gameState.notes = notesText;
                console.log('updateNotesDisplay - Using Silhouette default notes:', notesText);
            } else if (preset === 'texas-t') {
                // Texas T preset has a default note
                hasNotes = true;
                notesText = 'Texas T - 1 Spin\nHigh Block\nPlace 3 vertical cards and 2 horizontal cards in center of target. (Make the Letter "T")\nThrow 5 knives, then 5 hawks, beginning with the bottom card and working your way to the top. Then throw at the Left card, then the right card.\n\nScoring\nCenter Cut Correct Card-3 Points\nEdge Cut Correct Card -2 Points\nWood only or incorrect card - 1 Point';
                gameState.notes = notesText;
                console.log('updateNotesDisplay - Using Texas T default notes:', notesText);
            } else if (gameState.notes && gameState.notes.trim()) {
                // If no custom preset selected but we have notes in gameState, show them
                hasNotes = true;
                notesText = gameState.notes;
                console.log('updateNotesDisplay - Using gameState notes (no preset):', notesText);
            }
            
            console.log('updateNotesDisplay - hasNotes:', hasNotes, 'notesText:', notesText);
            
            // Show/hide appropriate UI based on whether notes exist
            if (hasNotes) {
                // Show read-only display with notes
                notesContent.textContent = notesText;
                notesDisplay.style.display = 'block';
                notesEditContainer.style.display = 'none';
                console.log('updateNotesDisplay - Showing read-only display');
            } else {
                // Show editable textarea (no notes exist)
                notesDisplay.style.display = 'none';
                notesEditContainer.style.display = 'block';
                if (notesInput) {
                    notesInput.value = '';
                }
                console.log('updateNotesDisplay - Showing edit container');
            }
        }
        
        // Function to switch to edit mode
        function editNotes() {
            var notesDisplay = document.getElementById('gameNotesDisplay');
            var notesEditContainer = document.getElementById('gameNotesEditContainer');
            var notesInput = document.getElementById('gameNotesInput');
            var notesContent = document.getElementById('gameNotesContent');
            
            if (!notesDisplay || !notesEditContainer || !notesInput) return;
            
            // Hide read-only display, show edit container
            notesDisplay.style.display = 'none';
            notesEditContainer.style.display = 'block';
            
            // Populate textarea with current notes
            if (notesContent) {
                notesInput.value = notesContent.textContent || gameState.notes || '';
            }
            
            // Focus the textarea
            notesInput.focus();
        }
        
        // Function to save notes
        function saveNotes() {
            var notesInput = document.getElementById('gameNotesInput');
            var notesEditContainer = document.getElementById('gameNotesEditContainer');
            
            if (!notesInput) return;
            
            var notes = notesInput.value.trim();
            gameState.notes = notes;
            
            // Check if we have a custom preset selected
            var presetSelect = document.getElementById('distancePresetSelect');
            var preset = presetSelect ? presetSelect.value : '';
            
            // If a custom preset is selected, save notes to that preset
            if (preset && preset.startsWith('custom_')) {
                var presetName = preset.substring(7);
                var customPresets = JSON.parse(localStorage.getItem('customGamePresets') || '{}');
                
                if (customPresets[presetName]) {
                    // Update the preset with new notes
                    customPresets[presetName].notes = notes;
                    localStorage.setItem('customGamePresets', JSON.stringify(customPresets));
                    showTimedNotification('üíæ Notes saved for ' + presetName, 2000);
                }
            }
            
            // Update display to show read-only view
            updateNotesDisplay();
        }

        // Called when user changes Number of Variables: refresh Variable Labels grid immediately
        // so new inputs are visible for labeling; actual game/player update happens on Apply
        function onNumDistancesChange() {
            if (hasGameStarted()) {
                alert('Cannot change number of variables after game has started! Reset the game to change this setting.');
                document.getElementById('numDistancesSelect').value = gameState.numDistances;
                return;
            }
            var raw = parseInt(document.getElementById('numDistancesSelect').value, 10);
            if (raw < 1 || isNaN(raw)) {
                document.getElementById('numDistancesSelect').value = gameState.numDistances || 5;
                return;
            }
            if (raw > 20) {
                document.getElementById('numDistancesSelect').value = 20;
            }
            // Refresh Variable Labels grid so new variable input(s) appear immediately
            generateDistanceLabelInputs();
            markSettingsChanged();
        }

        function updateNumDistances() {
            // Legacy: apply number of variables immediately (e.g. from preset load). Use onNumDistancesChange for user edits.
            if (hasGameStarted()) {
                document.getElementById('numDistancesSelect').value = gameState.numDistances;
                return;
            }
            var newNumDistances = parseInt(document.getElementById('numDistancesSelect').value, 10) || gameState.numDistances;
            if (newNumDistances === gameState.numDistances) return;
            gameState.numDistances = newNumDistances;
            var preset = document.getElementById('distancePresetSelect').value;
            if (preset && preset !== 'custom' && preset !== '') {
                gameState.distances = getDefaultDistances(preset, newNumDistances);
            } else {
                if (gameState.distances.length > newNumDistances) {
                    gameState.distances = gameState.distances.slice(0, newNumDistances);
                } else {
                    while (gameState.distances.length < newNumDistances) {
                        gameState.distances.push((gameState.distances.length + 2) + ' Meters');
                    }
                }
            }
            generateDistanceLabelInputs();
            gameState.players.forEach(function(player) {
                player.scores = Array(gameState.rounds).fill(null).map(function() { 
                    return Array(gameState.numDistances).fill(null).map(function() { 
                        return Array(gameState.throwsPerRound).fill(null); 
                    });
                });
                player.total = 0;
                player.average = 0;
                player.bullseyes = 0;
                player.percentage = 0;
                player.currentRound = 1;
                player.currentThrow = 1;
                player.currentDistance = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
            });
            updateGameDisplay();
            renderPlayers();
            if (leaderboardVisible) {
                updateLeaderboard();
                updateLeaderboardWindow();
            }
            showTimedNotification('üìè Number of distances updated to ' + newNumDistances + '!', 2000);
        }

        function updateDistancesOnTop() {
            var checkbox = document.getElementById('distancesOnTopCheckbox');
            if (checkbox) {
                gameState.distancesOnTop = checkbox.checked;
                renderPlayers();
            }
        }
        
        function updatePlayMode() {
            if (hasGameStarted()) {
                alert('Cannot change play mode after game has started! Reset the game to change this setting.');
                document.getElementById('playModeSelect').value = gameState.playMode;
                return;
            }
            
            var newPlayMode = document.getElementById('playModeSelect').value;
            if (newPlayMode === gameState.playMode) return;
            
            gameState.playMode = newPlayMode;
            
            // Set default checkbox state based on play mode (like walkback)
            gameState.distancesOnTop = (newPlayMode === 'sequential');
            var distancesOnTopCheckbox = document.getElementById('distancesOnTopCheckbox');
            if (distancesOnTopCheckbox) distancesOnTopCheckbox.checked = gameState.distancesOnTop;
            
            // Reset all players to starting position since play mode affects progression
            gameState.players.forEach(function(player) {
                player.currentRound = 1;
                player.currentThrow = 1;
                player.currentDistance = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
            });
            
            updateGameDisplay();
            renderPlayers();
            if (leaderboardVisible) {
                updateLeaderboard();
            updateLeaderboardWindow();
            }
            
            var modeDisplay = newPlayMode === 'consecutive' ? 'Consecutive Rounds' : 'Sequential Distance';
            showTimedNotification('üéØ Play mode updated to ' + modeDisplay + '!', 2000);
        }

        function updateDistancePreset() {
            var presetSelect = document.getElementById('distancePresetSelect');
            
            if (!presetSelect) {
                console.error('distancePresetSelect element not found!');
                return;
            }
            
            var preset = presetSelect.value;
            console.log('Distance preset changed to:', preset);
            
            // Check if this is a custom preset (starts with "custom_")
            if (preset && preset.startsWith('custom_')) {
                var presetName = preset.substring(7); // Remove "custom_" prefix
                loadCustomPreset(presetName);
                return;
            }
            
            // Check if this is the Silhouette preset
            if (preset === 'silhouette') {
                loadSilhouettePreset();
                return;
            }
            
            // Check if this is the Texas T preset
            if (preset === 'texas-t') {
                loadTexasTPreset();
                return;
            }
            
            // Get the custom distance panel
            var customPanel = document.getElementById('customDistancePanel');
            
            if (!customPanel) {
                console.error('customDistancePanel element not found!');
                return;
            }
            
            // Show/hide custom distance inputs (legacy panel outside settings)
            if (preset === 'custom') {
                console.log('Showing custom distance panel');
                customPanel.style.display = 'block';
                
                // Clear custom preset state when switching to manual custom mode
                if (!hasGameStarted()) {
                    gameState.distancePreset = 'custom';
                    gameState.currentPresetName = '';
                    gameState.notes = '';
                    updateNotesDisplay();
                }
                
                // Force a short delay to ensure DOM is ready, then generate inputs
                setTimeout(function() {
                    console.log('Calling generateDistanceLabelInputs...');
                    generateDistanceLabelInputs();
                }, 100);
            } else if (preset === '' || preset === null) {
                // Empty selection - just clear the state
                if (!hasGameStarted()) {
                    gameState.distancePreset = '';
                    gameState.currentPresetName = '';
                    gameState.notes = '';
                    updateNotesDisplay();
                }
            } else {
                console.log('Hiding custom distance panel');
                customPanel.style.display = 'none';
                
                // Only update distances if game hasn't started (to prevent losing data)
                if (!hasGameStarted()) {
                    // Update gameState with new preset distances
                    gameState.distances = getDefaultDistances(preset, gameState.numDistances);
                    
                    // Update distance label inputs if the collapsible section is visible
                    var distanceLabelsSection = document.getElementById('distanceLabelsSection');
                    if (distanceLabelsSection && !distanceLabelsSection.classList.contains('collapsed')) {
                        generateDistanceLabelInputs();
                    }
                    gameState.distancePreset = preset;
                    
                    // Clear custom preset state
                    gameState.currentPresetName = '';
                    
                    // Clear notes for non-custom presets
                    gameState.notes = '';
                    updateNotesDisplay();
                    
                    // Re-render players to update the round labels immediately
                    renderPlayers();
                    updateGameDisplay();
                    
                    showTimedNotification('üìè Distance preset updated to ' + (preset === 'amateur' ? 'Amateur' : 'Professional') + '!', 2000);
                }
            }
        }

        function loadSilhouettePreset() {
            if (hasGameStarted()) {
                alert('Cannot load preset after game has started! Reset the game to change settings.');
                document.getElementById('distancePresetSelect').value = 'custom';
                return;
            }
            
            // Apply Silhouette preset settings
            gameState.rounds = 1;
            gameState.throwsPerRound = 15;
            gameState.maxScore = 1;
            gameState.numDistances = 1;
            gameState.distances = ['2 Meters'];
            gameState.distancePreset = 'silhouette';
            gameState.currentPresetName = ''; // Clear custom preset name
            gameState.playMode = 'consecutive';
            gameState.tiebreakerMode = 'sudden-death';
            gameState.finalizationMode = 'manual';
            gameState.gameName = 'Silhouette';
            gameState.notes = 'Each thrower gets one attempt at each target'; // Default note for Silhouette preset
            
            // Update target rings based on max score
            gameState.targetRings = [];
            for (var i = gameState.maxScore; i >= 0; i--) {
                gameState.targetRings.push(i);
            }
            
            // Update ALL UI inputs directly
            var gameNameInput = document.getElementById('gameNameInput');
            if (gameNameInput) {
                gameNameInput.value = 'Silhouette';
            }
            
            var roundsInput = document.getElementById('roundsInput');
            if (roundsInput) {
                roundsInput.value = 1;
            }
            
            var throwsInput = document.getElementById('throwsInput');
            if (throwsInput) {
                throwsInput.value = 15;
            }
            
            var maxScoreInput = document.getElementById('maxScoreInput');
            if (maxScoreInput) {
                maxScoreInput.value = 1;
            }
            
            var tiebreakerSelect = document.getElementById('tiebreakerSelect');
            if (tiebreakerSelect) {
                tiebreakerSelect.value = 'sudden-death';
            }
            
            var finalizationModeSelect = document.getElementById('finalizationModeSelect');
            if (finalizationModeSelect) {
                finalizationModeSelect.value = 'manual';
            }
            
            var numDistancesSelect = document.getElementById('numDistancesSelect');
            if (numDistancesSelect) {
                numDistancesSelect.value = 1;
            }
            
            var playModeSelect = document.getElementById('playModeSelect');
            if (playModeSelect) {
                playModeSelect.value = 'consecutive';
            }
            
            // Clear custom preset state and notes
            gameState.currentPresetName = '';
            gameState.notes = '';
            updateNotesDisplay();
            
            // Reset all players' scores arrays to match new settings
            gameState.players.forEach(function(player) {
                player.scores = Array(gameState.rounds).fill(null).map(function() { 
                    return Array(gameState.numDistances).fill(null).map(function() { 
                        return Array(gameState.throwsPerRound).fill(null); 
                    });
                });
                player.total = 0;
                player.average = 0;
                player.bullseyes = 0;
                player.percentage = 0;
                player.currentRound = 1;
                player.currentThrow = 1;
                player.currentDistance = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
            });
            
            // Update UI to reflect loaded settings (if panel is visible)
            if (settingsVisible) {
                updateSettingsPanel();
            }
            
            // Show custom distance panel and generate inputs
            var customPanel = document.getElementById('customDistancePanel');
            if (customPanel) {
                customPanel.style.display = 'block';
            }
            
            // Always generate distance label inputs to populate them with saved values
            generateDistanceLabelInputs();
            
            updateGameDisplay();
            renderPlayers();
            if (leaderboardVisible) {
                updateLeaderboard();
                updateLeaderboardWindow();
            }
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn) applyBtn.classList.remove('apply-glow');
            
            showTimedNotification('üéØ Loaded Silhouette preset!', 2000);
        }

        function loadTexasTPreset() {
            if (hasGameStarted()) {
                alert('Cannot load preset after game has started! Reset the game to change settings.');
                document.getElementById('distancePresetSelect').value = 'custom';
                return;
            }
            
            // Apply Texas T preset settings
            gameState.rounds = 2;
            gameState.throwsPerRound = 5;
            gameState.maxScore = 3;
            gameState.numDistances = 5;
            gameState.distances = ['Card 1', 'Card 2', 'Card 3', 'Card 4', 'Card 5'];
            gameState.distancePreset = 'texas-t';
            gameState.currentPresetName = ''; // Clear custom preset name
            gameState.playMode = 'consecutive';
            gameState.tiebreakerMode = 'sudden-death';
            gameState.finalizationMode = 'manual';
            gameState.gameName = 'Texas T';
            gameState.notes = 'Texas T - 1 Spin\nHigh Block\nPlace 3 vertical cards and 2 horizontal cards in center of target. (Make the Letter "T")\nThrow 5 knives, then 5 hawks, beginning with the bottom card and working your way to the top. Then throw at the Left card, then the right card.\n\nScoring\nCenter Cut Correct Card-3 Points\nEdge Cut Correct Card -2 Points\nWood only or incorrect card - 1 Point';
            gameState.hideScoreTiles = false;
            
            // Update target rings based on max score
            gameState.targetRings = [];
            for (var i = gameState.maxScore; i >= 0; i--) {
                gameState.targetRings.push(i);
            }
            
            // Update ALL UI inputs directly
            var gameNameInput = document.getElementById('gameNameInput');
            if (gameNameInput) {
                gameNameInput.value = 'Texas T';
            }
            
            var roundsInput = document.getElementById('roundsInput');
            if (roundsInput) {
                roundsInput.value = 2;
            }
            
            var throwsInput = document.getElementById('throwsInput');
            if (throwsInput) {
                throwsInput.value = 5;
            }
            
            var maxScoreInput = document.getElementById('maxScoreInput');
            if (maxScoreInput) {
                maxScoreInput.value = 3;
            }
            
            var tiebreakerSelect = document.getElementById('tiebreakerSelect');
            if (tiebreakerSelect) {
                tiebreakerSelect.value = 'sudden-death';
            }
            
            var finalizationModeSelect = document.getElementById('finalizationModeSelect');
            if (finalizationModeSelect) {
                finalizationModeSelect.value = 'manual';
            }
            
            var numDistancesSelect = document.getElementById('numDistancesSelect');
            if (numDistancesSelect) {
                numDistancesSelect.value = 5;
            }
            
            var playModeSelect = document.getElementById('playModeSelect');
            if (playModeSelect) {
                playModeSelect.value = 'consecutive';
            }
            
            var hideScoreTilesCheckbox = document.getElementById('hideScoreTilesCheckbox');
            if (hideScoreTilesCheckbox) {
                hideScoreTilesCheckbox.checked = false;
            }
            
            // Clear custom preset state and notes
            gameState.currentPresetName = '';
            updateNotesDisplay();
            
            // Reset all players' scores arrays to match new settings
            gameState.players.forEach(function(player) {
                player.scores = Array(gameState.rounds).fill(null).map(function() { 
                    return Array(gameState.numDistances).fill(null).map(function() { 
                        return Array(gameState.throwsPerRound).fill(null); 
                    });
                });
                player.total = 0;
                player.average = 0;
                player.bullseyes = 0;
                player.percentage = 0;
                player.currentRound = 1;
                player.currentThrow = 1;
                player.currentDistance = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
            });
            
            // Update UI to reflect loaded settings (if panel is visible)
            if (settingsVisible) {
                updateSettingsPanel();
            }
            
            // Show custom distance panel and generate inputs
            var customPanel = document.getElementById('customDistancePanel');
            if (customPanel) {
                customPanel.style.display = 'block';
            }
            
            // Always generate distance label inputs to populate them with saved values
            generateDistanceLabelInputs();
            
            updateGameDisplay();
            renderPlayers();
            if (leaderboardVisible) {
                updateLeaderboard();
                updateLeaderboardWindow();
            }
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn) applyBtn.classList.remove('apply-glow');
            
            showTimedNotification('üéØ Loaded Texas T preset!', 2000);
        }

        function generateDistanceLabelInputs() {
            var grid = document.getElementById('distanceLabelsGrid');
            
            if (!grid) {
                console.error('distanceLabelsGrid element not found!');
                return;
            }
            
            // Use the Number of Variables input value so when user adds a variable the new
            // input appears immediately in the Variable Labels section (applied to game on Apply)
            var inputEl = document.getElementById('numDistancesSelect');
            var fromInput = inputEl ? parseInt(inputEl.value, 10) : NaN;
            var numDistances = (fromInput >= 1 && fromInput <= 20) ? fromInput : (gameState.numDistances || 5);
            var distancePreset = gameState.distancePreset || '';
            
            // Clear existing content
            grid.innerHTML = '';
            
            // Get preset distances if a preset is selected (not custom)
            var presetDistances = [];
            if (distancePreset && distancePreset !== 'custom' && distancePreset !== '') {
                presetDistances = getDefaultDistances(distancePreset, numDistances);
            }
            
            // Get current distances from gameState
            var currentDistances = gameState.distances || [];
            
            // Create input fields for each distance
            for (var i = 0; i < numDistances; i++) {
                var inputDiv = document.createElement('div');
                inputDiv.className = 'config-item';
                inputDiv.style.cssText = 'display: flex; flex-direction: column;';
                
                var label = document.createElement('label');
                label.className = 'config-label';
                label.textContent = (i + 1);
                
                var input = document.createElement('input');
                input.type = 'text';
                input.id = 'distance' + (i + 1);
                input.className = 'config-input';
                input.placeholder = 'e.g., ' + (i + 2) + ' Meters';
                input.maxLength = 20;
                
                // Use current distance if available, otherwise use preset default, otherwise use generic default
                if (currentDistances[i]) {
                    input.value = currentDistances[i];
                } else if (presetDistances[i]) {
                    input.value = presetDistances[i];
                } else {
                    // Default to something like "2 Meters", "3 Meters", etc.
                    input.value = (i + 2) + ' Meters';
                }
                
                // Add event listener to update distances in real-time
                (function(index) {
                    input.addEventListener('input', function(e) {
                        var value = e.target.value.trim();
                        if (value) {
                            gameState.distances[index] = value;
                        } else {
                            // If empty, use preset default or generic default
                            if (presetDistances[index]) {
                                gameState.distances[index] = presetDistances[index];
                            } else {
                                gameState.distances[index] = (index + 2) + ' Meters';
                            }
                        }
                        // Ensure distances array is properly sized
                        while (gameState.distances.length < numDistances) {
                            var defaultIdx = gameState.distances.length;
                            if (presetDistances[defaultIdx]) {
                                gameState.distances.push(presetDistances[defaultIdx]);
                            } else {
                                gameState.distances.push((defaultIdx + 2) + ' Meters');
                            }
                        }
                        // Re-render players to show updated distance labels immediately
                        renderPlayers();
                    });
                })(i);
                
                inputDiv.appendChild(label);
                inputDiv.appendChild(input);
                grid.appendChild(inputDiv);
            }
            
            // Ensure distances array matches numDistances
            while (gameState.distances.length < numDistances) {
                var defaultIdx = gameState.distances.length;
                if (presetDistances[defaultIdx]) {
                    gameState.distances.push(presetDistances[defaultIdx]);
                } else {
                    gameState.distances.push((defaultIdx + 2) + ' Meters');
                }
            }
            if (gameState.distances.length > numDistances) {
                gameState.distances = gameState.distances.slice(0, numDistances);
            }
        }

        function markSettingsChanged() {
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn && !applyBtn.disabled) {
                applyBtn.classList.add('apply-glow');
            }
        }
        
        function resetSettingsToDefaultsInPanel() {
            if (hasGameStarted()) {
                alert('Cannot reset settings after game has started! Reset the game to change settings.');
                return;
            }
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn) applyBtn.classList.remove('apply-glow');
            var newRounds = 5;
            var newThrows = 3;
            var newMaxScore = 5;
            var newNumDistances = 5;
            var newPlayMode = 'sequential';
            var newDistancePreset = 'custom';
            var newTiebreakerMode = 'sudden-death';
            var newFinalizationMode = 'auto';
            var newGameName = '';
            gameState.distancesOnTop = true;
            gameState.rounds = newRounds;
            gameState.throwsPerRound = newThrows;
            gameState.maxScore = newMaxScore;
            gameState.numDistances = newNumDistances;
            gameState.playMode = newPlayMode;
            gameState.distancePreset = newDistancePreset;
            gameState.tiebreakerMode = newTiebreakerMode;
            gameState.finalizationMode = newFinalizationMode;
            gameState.gameName = newGameName;
            gameState.notes = '';
            gameState.hideScoreTiles = false;
            gameState.currentPresetName = '';
            gameState.targetRings = [];
            for (var i = newMaxScore; i >= 0; i--) {
                gameState.targetRings.push(i);
            }
            gameState.distances = getDefaultDistances('amateur', newNumDistances);
            gameState.players.forEach(function(player) {
                player.scores = Array(newRounds).fill(null).map(function() {
                    return Array(newNumDistances).fill(null).map(function() {
                        return Array(newThrows).fill(null);
                    });
                });
                player.total = 0;
                player.average = 0;
                player.bullseyes = 0;
                player.percentage = 0;
                player.currentRound = 1;
                player.currentThrow = 1;
                player.currentDistance = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
                player.tiebreakerScores = [];
                player.tiebreakerTotal = 0;
                player.tiebreakerComplete = false;
                player.tiebreakerCurrentThrow = 1;
            });
            document.getElementById('gameNameInput').value = newGameName;
            document.getElementById('roundsInput').value = newRounds;
            document.getElementById('throwsInput').value = newThrows;
            document.getElementById('maxScoreInput').value = newMaxScore;
            document.getElementById('tiebreakerSelect').value = newTiebreakerMode;
            document.getElementById('finalizationModeSelect').value = newFinalizationMode;
            document.getElementById('numDistancesSelect').value = newNumDistances;
            document.getElementById('playModeSelect').value = newPlayMode;
            document.getElementById('distancePresetSelect').value = newDistancePreset;
            var distancesOnTopCheckbox = document.getElementById('distancesOnTopCheckbox');
            if (distancesOnTopCheckbox) distancesOnTopCheckbox.checked = gameState.distancesOnTop;
            var hideScoreTilesCheckbox = document.getElementById('hideScoreTilesCheckbox');
            if (hideScoreTilesCheckbox) hideScoreTilesCheckbox.checked = false;
            var gameNotesInput = document.getElementById('gameNotesInput');
            if (gameNotesInput) gameNotesInput.value = '';
            updateGameDisplay();
            renderPlayers();
            updateSettingsPanel();
            updateDistancePreset();
            updateNotesDisplay();
            var distanceLabelsSection = document.getElementById('distanceLabelsSection');
            if (distanceLabelsSection && !distanceLabelsSection.classList.contains('collapsed')) {
                generateDistanceLabelInputs();
            }
            if (leaderboardVisible) {
                updateLeaderboard();
                updateLeaderboardWindow();
            }
            showTimedNotification('Settings reset to defaults.', 2000);
        }
        
        function applySettings() {
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn) applyBtn.classList.remove('apply-glow');
            if (hasGameStarted()) {
                alert('Cannot change game settings after scoring has begun! Reset the game to change settings.');
                return;
            }
            
            var newGameName = document.getElementById('gameNameInput').value.trim();
            var newRounds = parseInt(document.getElementById('roundsInput').value);
            var newThrows = parseInt(document.getElementById('throwsInput').value);
            var newMaxScore = parseInt(document.getElementById('maxScoreInput').value);
            var newTiebreakerMode = document.getElementById('tiebreakerSelect').value;
            var newFinalizationMode = document.getElementById('finalizationModeSelect').value;
            var newNumDistances = parseInt(document.getElementById('numDistancesSelect').value);
            var newPlayMode = document.getElementById('playModeSelect').value;
            var newDistancePreset = document.getElementById('distancePresetSelect').value;
            
            // Collect distance labels from inputs if available, otherwise use preset defaults
            var newDistances = [];
            var hasCustomLabels = false;
            
            // Check if distance label inputs exist and have values
            for (var i = 1; i <= newNumDistances; i++) {
                var input = document.getElementById('distance' + i);
                if (input && input.value.trim()) {
                    newDistances.push(input.value.trim());
                    hasCustomLabels = true;
                } else {
                    // If no custom input, use preset default
                    var presetDistances = getDefaultDistances(newDistancePreset, newNumDistances);
                    newDistances.push(presetDistances[i - 1] || ('Distance ' + i));
                }
            }
            
            // If no custom labels were found, use preset defaults
            if (!hasCustomLabels && newDistancePreset !== 'custom') {
                newDistances = getDefaultDistances(newDistancePreset, newNumDistances);
            }
            
            // Update basic settings
            gameState.gameName = newGameName;
            gameState.rounds = newRounds;
            gameState.throwsPerRound = newThrows;
            gameState.maxScore = newMaxScore;
            gameState.tiebreakerMode = newTiebreakerMode;
            gameState.finalizationMode = newFinalizationMode;
            gameState.numDistances = newNumDistances;
            gameState.playMode = newPlayMode;
            gameState.distancePreset = newDistancePreset;
            gameState.distances = newDistances;
            var distancesOnTopCheckbox = document.getElementById('distancesOnTopCheckbox');
            gameState.distancesOnTop = distancesOnTopCheckbox ? distancesOnTopCheckbox.checked : (newPlayMode === 'sequential');
            
            // Update target rings based on max score
            gameState.targetRings = [];
            for (var i = newMaxScore; i >= 0; i--) {
                gameState.targetRings.push(i);
            }
            
            // Reset all players' scores arrays to match new settings (rounds x numDistances x throws)
            gameState.players.forEach(function(player) {
                player.scores = Array(newRounds).fill(null).map(function() { 
                    return Array(newNumDistances).fill(null).map(function() { 
                        return Array(newThrows).fill(null); 
                    });
                });
                player.total = 0;
                player.average = 0;
                player.bullseyes = 0;
                player.percentage = 0;
                player.currentRound = 1;
                player.currentThrow = 1;
                player.currentDistance = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
            });
            
            updateGameDisplay();
            renderPlayers();
            if (leaderboardVisible) {
                updateLeaderboard();
            updateLeaderboardWindow();
            }
            
            // Show/hide custom distance panel based on preset
            var customPanel = document.getElementById('customDistancePanel');
            if (customPanel) {
                if (newDistancePreset === 'custom') {
                    customPanel.style.display = 'block';
                } else {
                    customPanel.style.display = 'none';
                }
            }
            
            // Update Variable Labels section so it shows correct number of inputs after Apply
            var distanceLabelsSection = document.getElementById('distanceLabelsSection');
            if (distanceLabelsSection && !distanceLabelsSection.classList.contains('collapsed')) {
                generateDistanceLabelInputs();
            }
            
            saveGameState(); // Auto-save after settings change
            showTimedNotification('‚öôÔ∏è Settings applied successfully!', 2000);
            
            // Close settings panel after applying
            var settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel) settingsPanel.style.display = 'none';
            settingsVisible = false;
        }

        function resetGame() {
            if (confirm('Are you sure you want to reset the current game? All scores and settings will be reset to defaults.')) {
                gameState.rounds = 5;
                gameState.throwsPerRound = 3;
                gameState.maxScore = 5;
                gameState.targetRings = [5, 4, 3, 2, 1, 0];
                gameState.tiebreakerMode = 'sudden-death';
                gameState.finalizationMode = 'auto';
                gameState.gameName = '';
                gameState.numDistances = 5;
                gameState.playMode = 'sequential';
                gameState.distancePreset = 'amateur';
                gameState.distances = getDefaultDistances('amateur', 5);
                
                gameState.players.forEach(function(player) {
                    player.scores = Array(gameState.rounds).fill(null).map(function() { 
                        return Array(gameState.throwsPerRound).fill(null); 
                    });
                    player.total = 0;
                    player.average = 0;
                    player.bullseyes = 0;
                    player.percentage = 0;
                    player.currentRound = 1;
                    player.currentThrow = 1;
                    player.currentDistance = 1;
                    player.viewingRound = 1;
                    player.viewingDistance = 1;
                    player.gameComplete = false;
                    // Clear tiebreaker data
                    player.tiebreakerScores = [];
                    player.tiebreakerTotal = 0;
                    player.tiebreakerComplete = false;
                    player.tiebreakerCurrentThrow = 1;
                });
                
                gameState.editingThrow = null;
                gameState.gameFinalized = false;
                gameState.inTiebreaker = false;
                gameState.tiebreakerRound = 0;
                gameState.tiedPlayers = [];
                
                if (settingsVisible) {
                    updateSettingsPanel();
                }
                
                updateGameDisplay();
                renderPlayers();
                if (leaderboardVisible) {
                    updateLeaderboard();
            updateLeaderboardWindow();
                }
                updateLeaderboardWindow();
                
                saveGameState(); // Auto-save after reset
                showTimedNotification('üîÑ Game and settings reset to defaults!', 2000);
            }
        }

        function updateGameDisplay() {
            // Use game name if available, otherwise use type
            var displayTitle = gameState.gameName || gameState.type;
            var gameTitle = gameState.inTiebreaker ? displayTitle + ' - ' + getTiebreakerDisplayName(gameState.tiebreakerMode) : displayTitle;
            document.getElementById('currentGameTitle').textContent = gameTitle;
            
            // Update document title with game name
            if (gameState.gameName) {
                document.title = 'Triple Nickel - ' + gameState.gameName;
            } else {
                document.title = 'Triple Nickel - Custom';
            }
            
            var gameNameDisplay = gameState.gameName ? ' ‚Ä¢ ' + gameState.gameName : '';
            var tiebreakerInfo = gameState.inTiebreaker ? ' ‚Ä¢ TIEBREAKER ROUND ' + gameState.tiebreakerRound : '';
            var playModeDisplay = gameState.playMode === 'consecutive' ? ' ‚Ä¢ Consecutive Rounds' : ' ‚Ä¢ Sequential Distance';
            var totalThrows = gameState.rounds * gameState.numDistances * gameState.throwsPerRound;
            document.getElementById('gameStatus').textContent = 'üéØ ' + gameState.type + ' Game' + gameNameDisplay + tiebreakerInfo + ' ‚Ä¢ ' + gameState.rounds + ' Rounds ‚Ä¢ ' + gameState.numDistances + ' Distances ‚Ä¢ ' + totalThrows + ' Total Throws' + playModeDisplay + ' ‚Ä¢ Max Score: ' + gameState.maxScore;
            
            // Show game name display if there's a custom name
            var gameNameDisplayEl = document.getElementById('gameNameDisplay');
            if (gameState.gameName && gameNameDisplayEl) {
                gameNameDisplayEl.textContent = 'Game Name: ' + gameState.gameName;
                gameNameDisplayEl.style.display = 'block';
            } else if (gameNameDisplayEl) {
                gameNameDisplayEl.style.display = 'none';
            }
            
            // Show finalized banner if game is finalized
            var finalizedBanner = document.getElementById('finalizedBanner');
            if (finalizedBanner) {
                finalizedBanner.style.display = gameState.gameFinalized ? 'block' : 'none';
            }
            
            // Update finalize button visibility
            updateFinalizeButtonVisibility();
        }

        function finalizeGame() {
            // If in manual mode and tiebreaker is needed, start it first
            if (gameState.finalizationMode === 'manual' && !gameState.inTiebreaker && gameState.tiebreakerMode !== 'no-tiebreaker' && hasTiedPlayers()) {
                if (confirm('There is a tie! Would you like to start a tiebreaker before finalizing?')) {
                    startTiebreaker();
                    return;
                }
            }
            
            gameState.gameFinalized = true;
            updateGameDisplay();
            renderPlayers();
            
            // Archive the game results if this is a tournament event
            updateTournamentEventStatus();
            
            saveGameState(); // Auto-save after finalization
            // Show victory screen first
            showVictoryScreen();
            
            setTimeout(function() {
                if (confirm('Game results have been finalized!\n\nWould you like to export the results now?')) {
                    exportData();
                }
            }, 4000); // Wait longer since victory screen is showing
        }

        function showVictoryScreen() {
            // Sort players by final score
            var sortedPlayers = gameState.players.slice().sort(function(a, b) {
                var aTotal = a.total + (a.tiebreakerTotal || 0);
                var bTotal = b.total + (b.tiebreakerTotal || 0);
                return bTotal - aTotal;
            });
            
            var winner = sortedPlayers[0];
            var isMultipleWinners = sortedPlayers.length > 1 && 
                (winner.total + (winner.tiebreakerTotal || 0)) === 
                (sortedPlayers[1].total + (sortedPlayers[1].tiebreakerTotal || 0));
            
            // Create victory screen content
            var content = '<div style="text-align: center; color: white; padding: 20px;">';
            
            // Animated title
            content += '<div style="font-size: 3rem; font-weight: bold; margin-bottom: 20px; background: linear-gradient(45deg, #fbbf24, #f59e0b, #dc2626); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; animation: pulse 2s infinite;">üèÜ GAME COMPLETE! üèÜ</div>';
            
            if (isMultipleWinners) {
                content += '<div style="font-size: 1.8rem; margin-bottom: 30px; color: #fbbf24;">ü§ù IT\'S A TIE! ü§ù</div>';
                // Show all tied winners
                var tiedScore = winner.total + (winner.tiebreakerTotal || 0);
                var winners = sortedPlayers.filter(function(p) {
                    return (p.total + (p.tiebreakerTotal || 0)) === tiedScore;
                });
                winners.forEach(function(p, index) {
                    content += '<div style="font-size: 1.4rem; margin: 10px 0; padding: 15px; background: linear-gradient(45deg, #fbbf24, #f59e0b); border-radius: 15px; color: #1e293b; font-weight: bold;">';
                    content += 'ü•á ' + p.name + ' - ' + (p.total + (p.tiebreakerTotal || 0)) + ' points</div>';
                });
            } else {
                content += '<div style="font-size: 2.2rem; margin-bottom: 20px; color: #fbbf24;">üëë CHAMPION üëë</div>';
                content += '<div style="font-size: 1.8rem; margin-bottom: 15px; font-weight: bold; background: linear-gradient(45deg, #fbbf24, #f59e0b); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">' + winner.name + '</div>';
                content += '<div style="font-size: 1.4rem; margin-bottom: 30px; color: #e2e8f0;">Final Score: ' + (winner.total + (winner.tiebreakerTotal || 0)) + ' points</div>';
            }
            
            // Show top 3 podium
            content += '<div style="margin: 30px 0;">';
            content += '<div style="font-size: 1.2rem; font-weight: bold; margin-bottom: 15px; color: #e2e8f0;">üèÜ FINAL STANDINGS üèÜ</div>';
            
            for (var i = 0; i < Math.min(3, sortedPlayers.length); i++) {
                var player = sortedPlayers[i];
                var medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : 'ü•â';
                var bgColor = i === 0 ? 'linear-gradient(45deg, #fbbf24, #f59e0b)' : 
                             i === 1 ? 'linear-gradient(45deg, #e5e7eb, #9ca3af)' : 
                             'linear-gradient(45deg, #f59e0b, #d97706)';
                
                content += '<div style="margin: 10px 0; padding: 15px; background: ' + bgColor + '; border-radius: 12px; color: #1e293b; font-weight: bold; font-size: 1.1rem;">';
                content += medal + ' #' + (i + 1) + ' - ' + player.name + ' - ' + (player.total + (player.tiebreakerTotal || 0)) + ' points';
                if (player.tiebreakerTotal) {
                    content += ' (Base: ' + player.total + ' + TB: ' + player.tiebreakerTotal + ')';
                }
                content += '</div>';
            }
            
            // Show remaining players if more than 3
            if (sortedPlayers.length > 3) {
                content += '<div style="margin-top: 20px; padding: 15px; background: rgba(59, 130, 246, 0.1); border-radius: 10px; border: 1px solid #3b82f6;">';
                content += '<div style="font-weight: bold; margin-bottom: 10px; color: #3b82f6;">Other Players:</div>';
                for (var i = 3; i < sortedPlayers.length; i++) {
                    var player = sortedPlayers[i];
                    content += '<div style="margin: 5px 0; color: #e2e8f0;">#' + (i + 1) + ' - ' + player.name + ' - ' + (player.total + (player.tiebreakerTotal || 0)) + ' points</div>';
                }
                content += '</div>';
            }
            content += '</div>';
            
            // Tiebreaker info if applicable
            if (gameState.players.some(function(p) { return p.tiebreakerTotal; })) {
                content += '<div style="margin-top: 20px; padding: 15px; background: rgba(220, 38, 38, 0.1); border-radius: 10px; border: 1px solid #dc2626;">';
                content += '<div style="color: #dc2626; font-weight: bold; margin-bottom: 5px;">‚ö° Tiebreaker Details</div>';
                content += '<div style="color: #fca5a5; font-size: 0.9rem;">This game required ' + (gameState.tiebreakerRound || 0) + ' tiebreaker round(s) to determine the winner!</div>';
                content += '</div>';
            }
            
            content += '</div>';
            
            // Add CSS animation for the victory screen
            var style = document.createElement('style');
            style.textContent = `
                @keyframes pulse {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.05); }
                }
                @keyframes fadeInUp {
                    from { opacity: 0; transform: translateY(30px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                .victory-animation {
                    animation: fadeInUp 0.8s ease-out;
                }
            `;
            document.head.appendChild(style);
            
            var buttons = [
                {
                    text: 'üìÅ Export Results',
                    color: '#8b5cf6',
                    onclick: function() {
                        closeModal('victoryModal');
                        exportData();
                    }
                },
                {
                    text: 'üîÑ New Game',
                    color: '#ef4444', 
                    onclick: function() {
                        closeModal('victoryModal');
                        resetGame();
                    }
                },
                {
                    text: '‚ú® Close',
                    color: '#10b981',
                    onclick: function() {
                        closeModal('victoryModal');
                        showTimedNotification('üèÜ Game Finalized! Results are now locked.', 3000);
                    }
                }
            ];
            
            // Create modal with victory animation class
            var modal = createModal('victoryModal', '', content, buttons);
            modal.querySelector('div').classList.add('victory-animation');
        }

        function updateFinalizeButtonVisibility() {
            var finalizeBtn = document.getElementById('finalizeBtn');
            if (!finalizeBtn) return;
            
            // Show button if:
            // 1. Manual mode and all players complete, OR
            // 2. Any time in manual mode (to allow manual finalization)
            if (gameState.finalizationMode === 'manual' && !gameState.gameFinalized) {
                finalizeBtn.style.display = 'inline-block';
            } else {
                finalizeBtn.style.display = 'none';
            }
        }

        function promptGameFinalization() {
            // Check finalization mode
            if (gameState.finalizationMode === 'manual') {
                // Manual mode - show notification and finalize button, but don't auto-finalize
                showTimedNotification('üèÜ ALL PLAYERS FINISHED! Click "Finalize Game" button when ready.', 4000);
                updateFinalizeButtonVisibility();
                return;
            }
            
            // Auto mode - proceed with automatic finalization
            // Check if there's a tie and tiebreaker is enabled
            if (gameState.tiebreakerMode !== 'no-tiebreaker' && hasTiedPlayers()) {
                showTimedNotification('üèÜ ALL PLAYERS FINISHED! Checking for ties...', 2000);
                
                setTimeout(function() {
                    startTiebreaker();
                }, 1500);
            } else {
                showTimedNotification('üèÜ ALL PLAYERS FINISHED! Preparing victory celebration! üèÜ', 3000);
                
                setTimeout(function() {
                    finalizeGame();
                }, 1500);
            }
        }

        function updateTournamentEventStatus() {
            try {
                // Only proceed if there's a game name set
                if (!gameState.gameName || gameState.gameName.trim() === '') {
                    console.log('‚ö†Ô∏è No game name set - skipping tournament event update');
                    return false;
                }
                
                // Load tournament events
                var events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
                
                if (events.length === 0) {
                    console.log('‚ö†Ô∏è No tournament events found');
                    return false;
                }
                
                // Find matching event by game name
                var matchingEvent = events.find(function(event) {
                    return event.name === gameState.gameName;
                });
                
                if (matchingEvent) {
                    // Update event status to completed
                    matchingEvent.status = 'completed';
                    matchingEvent.dateCompleted = new Date().toISOString();
                    
                    // Prepare players data with final positions
                    var sortedPlayers = gameState.players.slice().sort(function(a, b) {
                        var aTotal = a.total + (a.tiebreakerTotal || 0);
                        var bTotal = b.total + (b.tiebreakerTotal || 0);
                        return bTotal - aTotal;
                    });
                    
                    var playersData = sortedPlayers.map(function(player, index) {
                        return {
                            id: player.id,
                            name: player.name,
                            className: player.className || 'N/A',
                            divisionName: player.divisionName || 'N/A',
                            total: player.total,
                            tiebreakerTotal: player.tiebreakerTotal || 0,
                            finalPosition: index + 1,
                            scores: player.scores || [],
                            tiebreakerScores: player.tiebreakerScores || [],
                            isEliminated: false
                        };
                    });
                    
                    // Add game results to the event
                    matchingEvent.gameResults = {
                        gameName: gameState.gameName,
                        gameType: 'Custom Side Game',
                        finalizedDate: new Date().toISOString(),
                        players: playersData,
                        gameSettings: {
                            rounds: gameState.rounds,
                            throwsPerRound: gameState.throwsPerRound,
                            maxScore: gameState.maxScore,
                            tiebreakerMode: gameState.tiebreakerMode,
                            finalizationMode: gameState.finalizationMode
                        },
                        gameFinalized: true,
                        tiebreakerUsed: gameState.players.some(function(p) { return p.tiebreakerTotal > 0; })
                    };
                    
                    // Save the updated events back to localStorage
                    localStorage.setItem('tournamentEvents', JSON.stringify(events));
                    
                    // Also save to permanent archive storage
                    try {
                        var archivedEvents = JSON.parse(localStorage.getItem('archivedEvents') || '[]');
                        
                        // Check if this exact game instance is already archived (avoid duplicates)
                        var currentPlayerIds = gameState.players.map(function(p) { return p.id; }).sort();
                        var existingIndex = archivedEvents.findIndex(function(archived) {
                            var archivedPlayerIds = (archived.gameResults?.players || []).map(function(p) { return p.id; }).sort();
                            return archived.name === matchingEvent.name && 
                                   archived.tournamentName === localStorage.getItem('tournamentName') &&
                                   archived.dateCompleted === matchingEvent.dateCompleted &&
                                   JSON.stringify(archivedPlayerIds) === JSON.stringify(currentPlayerIds);
                        });
                        
                        // Create archive entry with tournament context
                        var archiveEntry = {
                            name: matchingEvent.name,
                            type: matchingEvent.type,
                            status: matchingEvent.status,
                            dateCompleted: matchingEvent.dateCompleted,
                            gameResults: matchingEvent.gameResults,
                            tournamentName: localStorage.getItem('tournamentName') || 'Unknown Tournament',
                            archivedDate: new Date().toISOString()
                        };
                        
                        if (existingIndex !== -1) {
                            // Update existing archive entry
                            archivedEvents[existingIndex] = archiveEntry;
                        } else {
                            // Add new archive entry
                            archivedEvents.push(archiveEntry);
                        }
                        
                        localStorage.setItem('archivedEvents', JSON.stringify(archivedEvents));
                        console.log('üì¶ Event "' + matchingEvent.name + '" archived permanently');
                    } catch (archiveError) {
                        console.error('Error archiving event:', archiveError);
                    }
                    
                    console.log('‚úÖ Tournament event "' + matchingEvent.name + '" marked as completed (matched game: "' + gameState.gameName + '")');
                    
                    // Show notification about the status update
                    showTimedNotification('üèÜ Tournament event "' + matchingEvent.name + '" marked as completed and archived', 4000);
                    return true;
                } else {
                    console.log('‚ö†Ô∏è No matching event found for game name: "' + gameState.gameName + '"');
                    console.log('Available events:', events.map(function(e) { return e.name; }));
                    return false;
                }
            } catch (error) {
                console.error('Error updating tournament event status:', error);
                return false;
            }
        }

        function hasTiedPlayers() {
            if (gameState.players.length < 2) return false;
            
            // Group players by total score
            var scoreGroups = {};
            gameState.players.forEach(function(player) {
                var totalScore = player.total + (player.tiebreakerTotal || 0);
                if (!scoreGroups[totalScore]) {
                    scoreGroups[totalScore] = [];
                }
                scoreGroups[totalScore].push(player);
            });
            
            // Check if any score group has more than one player
            for (var score in scoreGroups) {
                if (scoreGroups[score].length > 1) {
                    return true;
                }
            }
            
            return false;
        }

        function startTiebreaker() {
            // Find tied players (players with the same highest score)
            var sortedPlayers = gameState.players.slice().sort(function(a, b) {
                var aTotal = a.total + (a.tiebreakerTotal || 0);
                var bTotal = b.total + (b.tiebreakerTotal || 0);
                return bTotal - aTotal;
            });
            
            var highestScore = sortedPlayers[0].total + (sortedPlayers[0].tiebreakerTotal || 0);
            var tiedPlayers = sortedPlayers.filter(function(player) {
                var playerTotal = player.total + (player.tiebreakerTotal || 0);
                return playerTotal === highestScore;
            });
            
            if (tiedPlayers.length < 2) {
                // No actual tie, finalize game
                finalizeGame();
                return;
            }
            
            // Start tiebreaker
            gameState.inTiebreaker = true;
            gameState.tiebreakerRound = 1;
            gameState.tiedPlayers = tiedPlayers;
            
            // Initialize tiebreaker scores
            tiedPlayers.forEach(function(player) {
                if (!player.tiebreakerScores) {
                    player.tiebreakerScores = [];
                }
                if (!player.tiebreakerTotal) {
                    player.tiebreakerTotal = 0;
                }
                player.tiebreakerComplete = false;
                player.tiebreakerCurrentThrow = 1;
            });
            
            updateGameDisplay();
            renderPlayers();
            
            var tiebreakerName = getTiebreakerDisplayName(gameState.tiebreakerMode);
            showTimedNotification('‚ö° TIE DETECTED! Starting ' + tiebreakerName + ' with ' + tiedPlayers.length + ' players!', 4000);
            
            if (leaderboardVisible) {
                updateLeaderboard();
            updateLeaderboardWindow();
            }
            
            saveGameState(); // Auto-save after starting tiebreaker
        }

        function addTiebreakerScore(playerId, score) {
            if (!gameState.inTiebreaker) return;
            
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (!player || gameState.tiedPlayers.indexOf(player) === -1) return;
            
            if (!player.tiebreakerScores) {
                player.tiebreakerScores = [];
            }
            if (!player.tiebreakerScores[gameState.tiebreakerRound - 1]) {
                player.tiebreakerScores[gameState.tiebreakerRound - 1] = [];
            }
            
            var throwsPerRound = gameState.tiebreakerMode === 'sudden-death' ? 1 : gameState.throwsPerRound;
            var currentRoundScores = player.tiebreakerScores[gameState.tiebreakerRound - 1];
            
            // Add score to current throw
            var throwIndex = player.tiebreakerCurrentThrow - 1;
            currentRoundScores[throwIndex] = score;
            
            // Update tiebreaker total
            player.tiebreakerTotal = 0;
            player.tiebreakerScores.forEach(function(round) {
                if (round) {
                    round.forEach(function(throwScore) {
                        if (throwScore !== null && throwScore !== undefined) {
                            player.tiebreakerTotal += throwScore;
                        }
                    });
                }
            });
            
            // Advance to next throw or complete round
            if (player.tiebreakerCurrentThrow < throwsPerRound) {
                player.tiebreakerCurrentThrow++;
            } else {
                player.tiebreakerComplete = true;
                showTimedNotification('üéØ ' + player.name + ' completed tiebreaker round ' + gameState.tiebreakerRound + '!', 2000);
            }
            
            // Check if all tied players completed this round
            var allComplete = gameState.tiedPlayers.every(function(p) { return p.tiebreakerComplete; });
            
            if (allComplete) {
                setTimeout(function() {
                    checkTiebreakerResults();
                }, 1000);
            }
            
            renderPlayers();
            if (leaderboardVisible) {
                updateLeaderboard();
            updateLeaderboardWindow();
            }
            
            saveGameState(); // Auto-save after tiebreaker score entry
        }

        function checkTiebreakerResults() {
            // Check if tie is broken
            var sortedTiedPlayers = gameState.tiedPlayers.slice().sort(function(a, b) {
                var aTotal = a.total + (a.tiebreakerTotal || 0);
                var bTotal = b.total + (b.tiebreakerTotal || 0);
                return bTotal - aTotal;
            });
            
            var winnerScore = sortedTiedPlayers[0].total + (sortedTiedPlayers[0].tiebreakerTotal || 0);
            var winners = sortedTiedPlayers.filter(function(player) {
                var playerTotal = player.total + (player.tiebreakerTotal || 0);
                return playerTotal === winnerScore;
            });
            
            if (winners.length === 1) {
                // Tie is broken!
                var winner = winners[0];
                showTimedNotification('üèÜ TIE BROKEN! ' + winner.name + ' wins the tiebreaker!', 4000);
                
                setTimeout(function() {
                    finalizeGame();
                }, 2000);
            } else if (winners.length < gameState.tiedPlayers.length) {
                // Some players eliminated, continue with remaining tied players
                gameState.tiedPlayers = winners;
                continueToNextTiebreakerRound();
            } else {
                // Still tied, continue to next round
                continueToNextTiebreakerRound();
            }
        }

        function continueToNextTiebreakerRound() {
            gameState.tiebreakerRound++;
            
            // Reset completion status for next round
            gameState.tiedPlayers.forEach(function(player) {
                player.tiebreakerComplete = false;
                player.tiebreakerCurrentThrow = 1;
            });
            
            updateGameDisplay();
            renderPlayers();
            
            showTimedNotification('‚ö° Still tied! Continue to tiebreaker round ' + gameState.tiebreakerRound + '!', 3000);
            
            if (leaderboardVisible) {
                updateLeaderboard();
            updateLeaderboardWindow();
            }
            
            saveGameState(); // Auto-save after continuing to next tiebreaker round
        }

        function showStats() {
            if (gameState.players.length === 0) {
                alert('No players added yet!');
                return;
            }
            
            // Sort players by total score for display
            var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                var aTotal = a.total + (a.tiebreakerTotal || 0);
                var bTotal = b.total + (b.tiebreakerTotal || 0);
                return bTotal - aTotal; 
            });
            
            var content = '<div style="color: #e2e8f0; line-height: 1.6; max-height: 70vh; overflow-y: auto;">';
            content += '<div style="font-size: 1.2rem; font-weight: bold; margin-bottom: 20px; color: #fbbf24;">üìä Player Statistics</div>';
            
            // Player stats table
            sortedPlayers.forEach(function(player, index) {
                var rank = index + 1;
                var medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '#' + rank;
                var totalScore = player.total + (player.tiebreakerTotal || 0);
                
                // Calculate completion
                var completedThrows = 0;
                var totalThrows = gameState.rounds * gameState.numDistances * gameState.throwsPerRound;
                player.scores.forEach(function(round) {
                    if (round) {
                        round.forEach(function(distance) {
                            if (distance) {
                                distance.forEach(function(score) {
                                    if (score !== null) completedThrows++;
                                });
                            }
                        });
                    }
                });
                var completionPercent = totalThrows > 0 ? Math.round((completedThrows / totalThrows) * 100) : 0;
                
                content += '<div style="background: rgba(30, 41, 59, 0.8); border: 1px solid #475569; border-radius: 10px; padding: 15px; margin-bottom: 12px;">';
                
                // Player header
                content += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
                content += '<div style="display: flex; align-items: center; gap: 10px;">';
                content += '<span style="font-size: 1.2rem; min-width: 35px;">' + medal + '</span>';
                content += '<span style="font-size: 1.1rem; font-weight: bold; color: white;">' + player.name + '</span>';
                content += '</div>';
                content += '<div style="text-align: right;">';
                content += '<div style="font-size: 1.4rem; font-weight: bold; color: #fbbf24;">' + totalScore + '</div>';
                if (player.tiebreakerTotal) {
                    content += '<div style="font-size: 0.8rem; color: #ef4444;">(' + player.total + ' + ' + player.tiebreakerTotal + ' TB)</div>';
                }
                content += '</div>';
                content += '</div>';
                
                // Stats grid
                content += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; font-size: 0.9rem;">';
                content += '<div style="text-align: center; padding: 8px; background: rgba(59, 130, 246, 0.1); border-radius: 6px;">';
                content += '<div style="color: #3b82f6; font-weight: bold; font-size: 0.7rem;">AVERAGE</div>';
                content += '<div style="font-weight: bold;">' + player.average + '</div>';
                content += '</div>';
                
                content += '<div style="text-align: center; padding: 8px; background: rgba(34, 197, 94, 0.1); border-radius: 6px;">';
                content += '<div style="color: #22c55e; font-weight: bold; font-size: 0.7rem;">EFFICIENCY</div>';
                content += '<div style="font-weight: bold;">' + (player.percentage || 0) + '%</div>';
                content += '</div>';
                
                content += '<div style="text-align: center; padding: 8px; background: rgba(107, 114, 128, 0.1); border-radius: 6px;">';
                content += '<div style="color: #9ca3af; font-weight: bold; font-size: 0.7rem;">COMPLETE</div>';
                content += '<div style="font-weight: bold;">' + completionPercent + '%</div>';
                content += '</div>';
                
                content += '</div>';
                content += '</div>';
            });
            
            content += '</div>';
            
            var buttons = [
                {
                    text: 'Close',
                    color: '#3b82f6',
                    onclick: function() {
                        closeModal('statsModal');
                    }
                }
            ];
            
            createModal('statsModal', 'üìä Player Statistics', content, buttons);
        }

        function exportData() {
            if (gameState.players.length === 0) {
                createModal('noDataWarning', '‚ö†Ô∏è No Data to Export', 
                    '<p style="color: #e2e8f0; font-size: 1.1rem; line-height: 1.6;">There are no players or scores to export!</p>',
                    [{
                        text: 'OK',
                        color: '#3b82f6',
                        onclick: function() { closeModal('noDataWarning'); }
                    }]
                );
                return;
            }
            
            var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                return b.total - a.total;
            });
            
            var date = new Date();
            var gameTitle = gameState.gameName || 'Custom Game';
            var maxPossibleScore = gameState.rounds * gameState.numDistances * gameState.throwsPerRound * gameState.maxScore;
            var maxScoreLabel = gameState.maxScore === 5 ? 'Bullseyes' : 'Max Scores';
            
            // Build HTML content (continuing in next part due to length)
            var htmlContent = buildCustomGameHTML(sortedPlayers, date, gameTitle, maxPossibleScore, maxScoreLabel);
            
            var blob = new Blob([htmlContent], { type: 'text/html' });
            var url = URL.createObjectURL(blob);
            var link = document.createElement('a');
            link.href = url;
            link.download = 'custom-game-results-' + date.toISOString().split('T')[0] + '.html';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showTimedNotification('üìÅ Beautiful HTML report exported successfully!', 3000);
        }
        
        function buildCustomGameHTML(sortedPlayers, date, gameTitle, maxPossibleScore, maxScoreLabel) {
            var playModeDisplay = gameState.playMode === 'consecutive' ? 'Consecutive Rounds' : 'Sequential Distance';
            
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Game Results - ${gameTitle}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #e2e8f0;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .report-container {
            max-width: 1200px;
            margin: 0 auto;
            background: #1e293b;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            overflow: hidden;
            border: 1px solid #334155;
        }
        .header {
            background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 30%, #3730a3 50%, #1e3a8a 70%, #0f172a 100%);
            color: #e2e8f0;
            padding: 50px;
            text-align: center;
            position: relative;
            border-bottom: 5px solid #fbbf24;
        }
        .header::before {
            content: 'üéØ';
            font-size: 5rem;
            position: absolute;
            top: 30px;
            left: 50px;
            opacity: 0.3;
        }
        .header::after {
            content: 'üèÜ';
            font-size: 5rem;
            position: absolute;
            top: 30px;
            right: 50px;
            opacity: 0.3;
        }
        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            color: #f1f5f9;
        }
        .header h2 {
            font-size: 1.5rem;
            color: #fbbf24;
            margin-bottom: 20px;
        }
        .game-info {
            background: rgba(15, 23, 42, 0.6);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            border: 1px solid #334155;
        }
        .info-item {
            text-align: center;
        }
        .info-label {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-bottom: 5px;
            color: #94a3b8;
        }
        .info-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #fbbf24;
        }
        .content {
            padding: 40px;
            background: #1e293b;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h3 {
            font-size: 1.8rem;
            color: #f1f5f9;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #fbbf24;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .podium {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 30px;
            margin-bottom: 50px;
            padding: 140px 40px 20px 40px;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 30%, #334155 70%, #1e293b 100%);
            border-radius: 30px;
            border: 4px solid #475569;
            min-height: 500px;
            position: relative;
        }
        .podium-card {
            background: transparent;
            text-align: center;
            position: relative;
            min-width: 280px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }
        .rank-1 {
            order: 2;
            z-index: 3;
            height: 420px;
            margin-top: -50px;
        }
        .rank-1::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 160px;
            height: 160px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 30%, #fbbf24 70%, #d97706 100%);
            border-radius: 20px 20px 0 0;
            border: 5px solid #f59e0b;
            box-shadow: 0 15px 50px rgba(251, 191, 36, 0.6);
        }
        .rank-1::after {
            content: 'ü•á';
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 4rem;
            z-index: 2;
        }
        .rank-2 {
            order: 1;
            z-index: 2;
            height: 340px;
        }
        .rank-2::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 120px;
            background: linear-gradient(135deg, #c0c0c0 0%, #a8a8a8 50%, #c0c0c0 100%);
            border-radius: 15px 15px 0 0;
            border: 4px solid #9ca3af;
            box-shadow: 0 10px 35px rgba(192, 192, 192, 0.4);
        }
        .rank-2::after {
            content: 'ü•à';
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 3rem;
            z-index: 2;
        }
        .rank-3 {
            order: 3;
            z-index: 1;
            height: 280px;
        }
        .rank-3::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 80px;
            background: linear-gradient(135deg, #cd7f32 0%, #a0522d 50%, #cd7f32 100%);
            border-radius: 12px 12px 0 0;
            border: 3px solid #8b4513;
            box-shadow: 0 8px 25px rgba(205, 127, 50, 0.4);
        }
        .rank-3::after {
            content: 'ü•â';
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2.5rem;
            z-index: 2;
        }
        .podium-player-info {
            position: relative;
            z-index: 3;
            margin-bottom: 20px;
        }
        .podium-player-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: #f1f5f9;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .podium-player-score {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fbbf24;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .podium-player-stats {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-top: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: linear-gradient(135deg, #334155 0%, #475569 100%);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            margin-bottom: 30px;
            border: 2px solid #64748b;
        }
        thead {
            background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 50%, #0f172a 100%);
            color: #e2e8f0;
        }
        th, td {
            padding: 18px 20px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #e2e8f0;
        }
        th {
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.95rem;
            letter-spacing: 1px;
        }
        tbody tr:nth-child(even) {
            background: rgba(45, 55, 72, 0.7);
        }
        tbody tr:nth-child(odd) {
            background: rgba(51, 65, 85, 0.7);
        }
        .rank-cell {
            font-weight: bold;
            font-size: 1.3rem;
            text-align: center;
            color: #fbbf24;
        }
        .score-cell {
            font-weight: bold;
            font-size: 1.4rem;
            color: #fbbf24;
            text-align: center;
        }
        .player-detail {
            background: #2d3748;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid #4a5568;
        }
        .player-detail h4 {
            font-size: 1.5rem;
            color: #fbbf24;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-box {
            background: rgba(15, 23, 42, 0.6);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #475569;
        }
        .stat-label {
            font-size: 0.85rem;
            color: #94a3b8;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #3b82f6;
        }
        .round-breakdown {
            background: rgba(15, 23, 42, 0.4);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        .round-breakdown h5 {
            color: #cbd5e1;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        .distance-row {
            padding: 8px;
            margin: 5px 0;
            background: rgba(51, 65, 85, 0.5);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .distance-label {
            color: #94a3b8;
            font-weight: 500;
        }
        .distance-scores {
            color: #e2e8f0;
            font-family: monospace;
        }
        .distance-total {
            color: #fbbf24;
            font-weight: bold;
            margin-left: 15px;
        }
        .perfect-badge {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 10px;
        }
        @media print {
            body { background: white; color: black; }
            .report-container { box-shadow: none; }
        }
    </style>
</head>
<body>
    <div class="report-container">
        <div class="header">
            <h1>${gameTitle}</h1>
            <h2>Custom Game Results</h2>
            <div class="game-info">
                <div class="info-item">
                    <div class="info-label">Date</div>
                    <div class="info-value">${date.toLocaleDateString()}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Players</div>
                    <div class="info-value">${gameState.players.length}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Rounds</div>
                    <div class="info-value">${gameState.rounds}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Distances</div>
                    <div class="info-value">${gameState.numDistances}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Throws per Round</div>
                    <div class="info-value">${gameState.throwsPerRound}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Max Score</div>
                    <div class="info-value">${gameState.maxScore}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Play Mode</div>
                    <div class="info-value">${playModeDisplay}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Max Possible</div>
                    <div class="info-value">${maxPossibleScore}</div>
                </div>
            </div>
        </div>
        
        <div class="content">
            ${buildPodiumHTML(sortedPlayers)}
            ${buildStandingsTableHTML(sortedPlayers)}
            ${buildPlayerDetailsHTML(sortedPlayers)}
        </div>
    </div>
</body>
</html>`;
        }
        
        function buildPodiumHTML(sortedPlayers) {
            if (sortedPlayers.length === 0) return '';
            
            var html = '<div class="section"><h3>üèÜ Top 3 Finishers</h3><div class="podium">';
            
            for (var i = 0; i < Math.min(3, sortedPlayers.length); i++) {
                var player = sortedPlayers[i];
                var rank = i + 1;
                var rankClass = 'rank-' + rank;
                
                html += `
                    <div class="podium-card ${rankClass}">
                        <div class="podium-player-info">
                            <div class="podium-player-name">${player.name}</div>
                            <div class="podium-player-score">${player.total + (player.tiebreakerTotal || 0)}</div>
                            <div class="podium-player-stats">
                                Avg: ${player.average}<br>
                                Efficiency: ${player.percentage}%
                            </div>
                        </div>
                    </div>
                `;
            }
            
            html += '</div></div>';
            return html;
        }
        
        function buildStandingsTableHTML(sortedPlayers) {
            var html = '<div class="section"><h3>üìä Final Standings</h3><table><thead><tr>';
            html += '<th>Rank</th><th>Player</th><th>Score</th><th>Average</th><th>Efficiency</th>';
            html += '<th>Status</th></tr></thead><tbody>';
            
            sortedPlayers.forEach(function(player, index) {
                var rank = index + 1;
                var medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '';
                var totalScore = player.total + (player.tiebreakerTotal || 0);
                var status = player.gameComplete ? '‚úÖ Complete' : '‚è≥ In Progress';
                
                html += '<tr>';
                html += '<td class="rank-cell">' + medal + ' #' + rank + '</td>';
                html += '<td>' + player.name + '</td>';
                html += '<td class="score-cell">' + totalScore + '</td>';
                html += '<td>' + player.average + '</td>';
                html += '<td>' + player.percentage + '%</td>';
                html += '<td>' + status + '</td>';
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            return html;
        }
        
        function buildPlayerDetailsHTML(sortedPlayers) {
            var html = '<div class="section"><h3>üìã Detailed Player Statistics</h3>';
            
            sortedPlayers.forEach(function(player, index) {
                var rank = index + 1;
                var medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '#' + rank;
                var totalScore = player.total + (player.tiebreakerTotal || 0);
                
                // Calculate stats
                var completedThrows = 0;
                var totalThrows = gameState.rounds * gameState.numDistances * gameState.throwsPerRound;
                var roundTotals = [];
                var bestRound = 0;
                var worstRound = gameState.throwsPerRound * gameState.maxScore;
                var perfectRounds = 0;
                
                player.scores.forEach(function(round) {
                    if (round) {
                        round.forEach(function(distance) {
                            if (distance) {
                                var distanceTotal = 0;
                                distance.forEach(function(score) {
                                    if (score !== null) {
                                        completedThrows++;
                                        distanceTotal += score;
                                    }
                                });
                                if (distance.filter(function(s) { return s !== null; }).length > 0) {
                                    roundTotals.push(distanceTotal);
                                    if (distanceTotal > bestRound) bestRound = distanceTotal;
                                    if (distanceTotal < worstRound) worstRound = distanceTotal;
                                    if (distanceTotal === gameState.throwsPerRound * gameState.maxScore) perfectRounds++;
                                }
                            }
                        });
                    }
                });
                
                var completionPercent = totalThrows > 0 ? ((completedThrows / totalThrows) * 100).toFixed(1) : 0;
                var averageRound = roundTotals.length > 0 ? (roundTotals.reduce(function(a, b) { return a + b; }, 0) / roundTotals.length).toFixed(1) : 0;
                
                html += '<div class="player-detail">';
                html += '<h4>' + medal + ' ' + player.name + '</h4>';
                html += '<div class="stats-grid">';
                html += '<div class="stat-box"><div class="stat-label">Final Score</div><div class="stat-value" style="color: #fbbf24;">' + totalScore + '</div></div>';
                html += '<div class="stat-box"><div class="stat-label">Completion</div><div class="stat-value">' + completionPercent + '%</div></div>';
                html += '<div class="stat-box"><div class="stat-label">Average per Throw</div><div class="stat-value">' + player.average + '</div></div>';
                html += '<div class="stat-box"><div class="stat-label">Average per Round</div><div class="stat-value">' + averageRound + '</div></div>';
                html += '<div class="stat-box"><div class="stat-label">Best Round</div><div class="stat-value" style="color: #10b981;">' + bestRound + '</div></div>';
                html += '<div class="stat-box"><div class="stat-label">Perfect Rounds</div><div class="stat-value" style="color: #a855f7;">' + perfectRounds + '</div></div>';
                html += '</div>';
                
                // Round breakdown
                html += '<div class="round-breakdown"><h5>Round-by-Round Breakdown</h5>';
                player.scores.forEach(function(round, roundIndex) {
                    html += '<div style="margin-bottom: 15px;"><strong>Round ' + (roundIndex + 1) + ':</strong>';
                    if (round) {
                        round.forEach(function(distance, distanceIndex) {
                            var distanceLabel = gameState.distances[distanceIndex] || ('Distance ' + (distanceIndex + 1));
                            if (distance) {
                                var distanceScores = distance.map(function(score) { return score !== null ? score : '-'; }).join(', ');
                                var distanceTotal = distance.reduce(function(sum, score) { return sum + (score || 0); }, 0);
                                var isPerfect = distanceTotal === gameState.throwsPerRound * gameState.maxScore;
                                html += '<div class="distance-row">';
                                html += '<span class="distance-label">' + distanceLabel + '</span>';
                                html += '<span class="distance-scores">[' + distanceScores + ']</span>';
                                html += '<span class="distance-total">' + distanceTotal + ' pts</span>';
                                if (isPerfect) html += '<span class="perfect-badge">PERFECT!</span>';
                                html += '</div>';
                            }
                        });
                    }
                    html += '</div>';
                });
                html += '</div>';
                
                html += '</div>';
            });
            
            html += '</div>';
            return html;
        }

        function updateLeaderboard() {
            var content = document.getElementById('leaderboardContent');
            if (!content) return;
            
            content.innerHTML = '';
            
            // Add status banners
            if (gameState.gameFinalized) {
                var finalizedBanner = document.createElement('div');
                finalizedBanner.style.cssText = 'background: linear-gradient(135deg, #dc2626, #991b1b); color: white; padding: 20px; border-radius: 12px; text-align: center; font-weight: bold; font-size: 1.2rem; margin-bottom: 20px; border: 2px solid #fbbf24; box-shadow: 0 8px 25px rgba(220, 38, 38, 0.3);';
                finalizedBanner.innerHTML = 'üîí FINALIZED RESULTS - SCORES LOCKED üîí<br><span style="font-size: 0.9rem; margin-top: 8px; display: block; opacity: 0.9;">Results are permanently saved</span>';
                content.appendChild(finalizedBanner);
            } else if (gameState.inTiebreaker) {
                var tiebreakerBanner = document.createElement('div');
                tiebreakerBanner.style.cssText = 'background: linear-gradient(135deg, #ef4444, #dc2626); color: white; padding: 20px; border-radius: 12px; text-align: center; font-weight: bold; font-size: 1.2rem; margin-bottom: 20px; border: 2px solid #fbbf24; box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);';
                tiebreakerBanner.innerHTML = 'üî• TIEBREAKER ROUND ' + gameState.tiebreakerRound + ' üî•<br><span style="font-size: 0.9rem; margin-top: 8px; display: block;">' + (gameState.tiedPlayers ? gameState.tiedPlayers.length : 0) + ' players tied - breaking the tie!</span>';
                content.appendChild(tiebreakerBanner);
            } else if (isEntireGameComplete()) {
                var completeBanner = document.createElement('div');
                completeBanner.style.cssText = 'background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1e293b; padding: 20px; border-radius: 12px; text-align: center; font-weight: bold; font-size: 1.2rem; margin-bottom: 20px; border: 2px solid #10b981; box-shadow: 0 8px 25px rgba(251, 191, 36, 0.4);';
                completeBanner.innerHTML = 'üèÜ CUSTOM GAME COMPLETE - FINAL RESULTS üèÜ<br><span style="font-size: 0.9rem; margin-top: 8px; display: block;">All players have finished!</span>';
                content.appendChild(completeBanner);
            }
            
            if (gameState.players.length === 0) {
                var emptyState = document.createElement('div');
                emptyState.style.cssText = 'text-align: center; padding: 40px 20px; color: #94a3b8; font-size: 1.1rem;';
                emptyState.innerHTML = 'üë• No players added yet<br><span style="font-size: 0.9rem; opacity: 0.7; margin-top: 10px; display: block;">Add players to see live rankings</span>';
                content.appendChild(emptyState);
                return;
            }

            // Sort players by total score including tiebreaker (highest first for regular games)
            var sortedPlayers = gameState.players.slice().sort(function(a, b) {
                var aTotal = a.total + (a.tiebreakerTotal || 0);
                var bTotal = b.total + (b.tiebreakerTotal || 0);
                return bTotal - aTotal;
            });

            sortedPlayers.forEach(function(player, index) {
                var rank = index + 1;
                var trophy = rank === 1 ? 'üèÜ' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : 'üéØ';
                var rankClass = rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : rank === 3 ? 'rank-3' : 'rank-other';
                
                var item = document.createElement('div');
                item.className = 'leaderboard-item';
                item.style.padding = '20px 15px';
                
                if (rank === 1 && (isEntireGameComplete() || gameState.gameFinalized)) {
                    item.style.background = 'linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(245, 158, 11, 0.1))';
                    item.style.border = '2px solid #fbbf24';
                    item.style.boxShadow = '0 4px 15px rgba(251, 191, 36, 0.3)';
                }
                
                // Check if player is in tiebreaker or eliminated
                var isInTiebreaker = gameState.inTiebreaker && gameState.tiedPlayers && gameState.tiedPlayers.indexOf(player) !== -1;
                var isEliminatedFromTiebreaker = gameState.inTiebreaker && gameState.tiedPlayers && gameState.tiedPlayers.indexOf(player) === -1 && player.gameComplete;
                
                if (gameState.inTiebreaker && !isInTiebreaker) {
                    item.style.opacity = '0.5';
                    item.style.filter = 'grayscale(70%)';
                }
                
                var totalScore = player.total + (player.tiebreakerTotal || 0);
                var scoreBreakdown = '';
                if (player.tiebreakerTotal) {
                    scoreBreakdown = '<br><span style="font-size: 0.7rem; color: #ef4444;">(' + player.total + ' + ' + player.tiebreakerTotal + ' TB)</span>';
                }
                
                item.innerHTML = 
                    '<div style="font-size: 2rem; margin-right: 15px; width: 50px; text-align: center;">' + trophy + '</div>' +
                    '<div style="font-size: 1.5rem; font-weight: bold; width: 40px; text-align: center; margin-right: 15px; color: ' + 
                    (rank === 1 ? '#ffd700' : rank === 2 ? '#c0c0c0' : rank === 3 ? '#cd7f32' : '#64748b') + ';">#' + rank + '</div>' +
                    '<div style="flex: 1;">' +
                        '<div style="font-size: 1.2rem; font-weight: bold; color: white; margin-bottom: 5px;">' + player.name + (rank === 1 && (isEntireGameComplete() || gameState.gameFinalized) ? ' üéâ' : '') + '</div>' +
                        '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px; font-size: 0.8rem; color: #94a3b8;">' +
                            '<div style="display: flex; justify-content: space-between;"><span style="color: #64748b;">Average:</span><span style="font-weight: bold; color: #3b82f6;">' + player.average + '</span></div>' +
                            '<div style="display: flex; justify-content: space-between;"><span style="color: #64748b;">Efficiency:</span><span style="font-weight: bold; color: #06b6d4;">' + (player.percentage || 0) + '%</span></div>' +
                        '</div>' +
                    '</div>' +
                    '<div style="font-size: 2.5rem; font-weight: bold; color: ' + 
                    (rank === 1 ? '#ffd700' : rank === 2 ? '#c0c0c0' : rank === 3 ? '#cd7f32' : 'white') + 
                    '; text-align: center; min-width: 100px; display: flex; flex-direction: column; align-items: center; justify-content: center;">' +
                        '<div>' + totalScore + scoreBreakdown + '</div>' +
                        '<div style="font-size: 0.4em; color: #94a3b8; font-weight: normal; margin-top: 4px;">POINTS</div>' +
                    '</div>';
                content.appendChild(item);
            });
            
            // Update leaderboard subtitle
            var subtitle = document.getElementById('leaderboardSubtitle');
            if (subtitle) {
                if (gameState.inTiebreaker) {
                    var tiedCount = gameState.tiedPlayers ? gameState.tiedPlayers.length : 0;
                    subtitle.textContent = 'Tiebreaker Round ' + gameState.tiebreakerRound + ' - ' + tiedCount + ' players';
                } else {
                    var completedPlayers = gameState.players.filter(function(p) { return p.gameComplete; }).length;
                    subtitle.textContent = completedPlayers + '/' + gameState.players.length + ' players completed';
                }
            }
        }

        // Helper function to determine optimal window position for multi-monitor setups
        function getMultiMonitorWindowPosition() {
            var screenWidth = window.screen.width;
            var screenHeight = window.screen.height;
            var availWidth = window.screen.availWidth;
            var availHeight = window.screen.availHeight;
            
            // Check if we have multi-monitor setup
            var hasMultiMonitor = availWidth > screenWidth || window.screen.isExtended;
            
            if (hasMultiMonitor || availWidth > 1920) {
                // Position on second monitor (assuming it's to the right)
                return {
                    left: screenWidth + 50,
                    top: 50,
                    multiMonitor: true
                };
            } else {
                // Single monitor - position in top right
                return {
                    left: Math.max(50, (screenWidth - 1200) / 2),
                    top: 50,
                    multiMonitor: false
                };
            }
        }

        // SEPARATE WINDOW LEADERBOARD FUNCTIONS
        function openLeaderboardWindow() {
            // Check if window is already open and focused
            if (leaderboardWindow && !leaderboardWindow.closed) {
                leaderboardWindow.focus();
                updateLeaderboardWindow();
                return;
            }

            // Determine window position for multi-monitor setup
            var windowFeatures = 'width=1200,height=800,scrollbars=no,resizable=yes,location=no,menubar=no,toolbar=no';
            
            // Get optimal window position for multi-monitor setup
            var position = getMultiMonitorWindowPosition();
            windowFeatures += ',left=' + position.left + ',top=' + position.top;
            
            // Log multi-monitor detection for debugging
            if (position.multiMonitor) {
                console.log('üéØ Multi-monitor detected! Opening leaderboard on second monitor at position:', position);
            } else {
                console.log('üñ•Ô∏è Single monitor detected. Opening leaderboard at default position:', position);
            }
            
            leaderboardWindow = window.open('', 'leaderboard', windowFeatures);
            
            if (!leaderboardWindow) {
                alert('Pop-up blocked! Please allow pop-ups for this site to use the leaderboard window.');
                return;
            }

            // Set up the window content
            leaderboardWindow.document.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>üèÜ ${gameState.gameName || 'Custom Game'} - Live Leaderboard</title>
                    <style>
                        body {
                            margin: 0;
                            padding: 0;
                            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
                            height: 100vh;
                            width: 100vw;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            overflow: hidden;
                        }
                        .leaderboard-container {
                            background: rgba(30, 41, 59, 0.95);
                            border: none;
                            padding: 0;
                            box-shadow: none;
                            backdrop-filter: blur(10px);
                            width: 100%;
                            height: 100vh;
                            margin: 0;
                            display: flex;
                            flex-direction: column;
                            overflow: hidden;
                        }
                        .leaderboard-header {
                            background: linear-gradient(45deg, #8b5cf6, #a855f7);
                            color: white;
                            padding: 2vh 2vw;
                            border-radius: 0;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            border-bottom: 0.2vh solid #c084fc;
                            flex-shrink: 0;
                            min-height: 8vh;
                        }
                        .leaderboard-title {
                            display: flex;
                            align-items: center;
                            gap: 1.5vw;
                        }
                        .leaderboard-title span {
                            font-size: clamp(2rem, 4vw, 2.8rem);
                        }
                        .leaderboard-title div {
                            font-size: clamp(1.4rem, 2.8vw, 2.1rem);
                            font-weight: bold;
                            text-shadow: 0.2vh 0.2vh 0.4vh rgba(0,0,0,0.3);
                        }
                        #leaderboardGameName {
                            font-size: clamp(1.8rem, 4.5vw, 3.2rem);
                            font-weight: 900;
                            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                            line-height: 1.1;
                        }
                        .leaderboard-subtitle {
                            font-size: clamp(0.9rem, 1.8vw, 1.3rem);
                            opacity: 0.9;
                            margin-top: 0.5vh;
                        }
                        .leaderboard-content {
                            padding: 2vh 2vw;
                            flex: 1;
                            color: #e2e8f0;
                            display: grid;
                            gap: 1.5vh 3vw;
                            align-items: start;
                            overflow-y: auto;
                            max-height: calc(100vh - 8vh);
                        }
                        
                        /* Two-column layout for 11+ players */
                        .leaderboard-content.two-column {
                            grid-template-columns: 1fr 1fr;
                            grid-template-rows: repeat(10, auto);
                            grid-auto-flow: column;
                        }
                        
                        /* Single column layout for 10 or fewer players */
                        .leaderboard-content.single-column {
                            grid-template-columns: 1fr;
                            grid-template-rows: none;
                            gap: 0.5vh;
                        }
                        
                        /* Dynamic sizing based on player count */
                        .leaderboard-content.single-column.few-players-1-2 {
                            gap: 2vh;
                        }
                        .leaderboard-content.single-column.few-players-3-4 {
                            gap: 1.5vh;
                        }
                        .leaderboard-content.single-column.few-players-5-6 {
                            gap: 1vh;
                        }
                        .leaderboard-content.single-column.few-players-7-8 {
                            gap: 0.8vh;
                        }
                        .leaderboard-content.single-column.few-players-9-10 {
                            gap: 0.6vh;
                        }
                        .leaderboard-item {
                            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
                            border: 0.15vh solid rgba(59, 130, 246, 0.3);
                            border-radius: 1vh;
                            padding: 1.5vh 1.5vw;
                            display: flex;
                            align-items: center;
                            gap: 1.5vw;
                            transition: all 0.3s ease;
                        }
                        .leaderboard-item:hover {
                            transform: translateY(-0.3vh);
                            box-shadow: 0 0.5vh 1.5vh rgba(59, 130, 246, 0.3);
                        }
                        .leaderboard-item.rank-1 {
                            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2) 0%, rgba(245, 158, 11, 0.2) 100%);
                            border-color: #fbbf24;
                            box-shadow: 0 0 2vh rgba(251, 191, 36, 0.4);
                        }
                        .leaderboard-item.rank-2 {
                            background: linear-gradient(135deg, rgba(192, 192, 192, 0.2) 0%, rgba(169, 169, 169, 0.2) 100%);
                            border-color: #c0c0c0;
                        }
                        .leaderboard-item.rank-3 {
                            background: linear-gradient(135deg, rgba(205, 127, 50, 0.2) 0%, rgba(184, 115, 51, 0.2) 100%);
                            border-color: #cd7f32;
                        }
                        .rank-number {
                            font-size: clamp(1.8rem, 3.5vw, 2.5rem);
                            font-weight: bold;
                            min-width: 3.5vw;
                            text-align: center;
                            color: white;
                        }
                        .rank-1 .rank-number {
                            color: #ffd700;
                            font-size: clamp(2.2rem, 4vw, 3rem);
                        }
                        .rank-2 .rank-number {
                            color: #c0c0c0;
                        }
                        .rank-3 .rank-number {
                            color: #cd7f32;
                        }
                        .player-info {
                            flex: 1;
                        }
                        .player-name {
                            font-size: clamp(1.2rem, 2.3vw, 1.8rem);
                            font-weight: 600;
                            color: #e2e8f0;
                            margin-bottom: 0.5vh;
                        }
                        .player-stats {
                            font-size: clamp(0.9rem, 1.7vw, 1.2rem);
                            color: #94a3b8;
                        }
                        .player-score {
                            font-size: clamp(2rem, 3.8vw, 2.8rem);
                            font-weight: bold;
                            color: white;
                            text-align: right;
                            min-width: 5vw;
                        }
                        .rank-1 .player-score {
                            color: #ffd700;
                            font-size: clamp(2.5rem, 4.5vw, 3.5rem);
                        }
                        .rank-2 .player-score {
                            color: #c0c0c0;
                            font-size: clamp(2.3rem, 4.2vw, 3.2rem);
                        }
                        .rank-3 .player-score {
                            color: #cd7f32;
                            font-size: clamp(2.1rem, 4vw, 3rem);
                        }
                        .no-players {
                            text-align: center;
                            color: #94a3b8;
                            font-size: clamp(1.2rem, 2.3vw, 1.8rem);
                            padding: 5vh 0;
                            grid-column: 1 / -1;
                        }
                        .leaderboard-content::-webkit-scrollbar {
                            width: 0.8vw;
                        }
                        .leaderboard-content::-webkit-scrollbar-track {
                            background: rgba(15, 23, 42, 0.5);
                        }
                        .leaderboard-content::-webkit-scrollbar-thumb {
                            background: rgba(59, 130, 246, 0.5);
                            border-radius: 0.4vw;
                        }
                        .leaderboard-content::-webkit-scrollbar-thumb:hover {
                            background: rgba(59, 130, 246, 0.7);
                        }
                    </style>
                </head>
                <body>
                    <div class="leaderboard-container">
                        <div class="leaderboard-header">
                            <div class="leaderboard-title">
                                <span>üèÜ</span>
                                <div>
                                    <div id="leaderboardGameName">${gameState.gameName || 'Custom Game'}</div>
                                    <div class="leaderboard-subtitle" id="leaderboardSubtitle">Live Leaderboard</div>
                                </div>
                            </div>
                        </div>
                        <div class="leaderboard-content" id="leaderboardContent">
                            <div class="no-players">üë• No players added yet</div>
                        </div>
                    </div>
                </body>
                </html>
            `);
            
            leaderboardWindow.document.close();
            
            // Mark that leaderboard window is open in localStorage
            localStorage.setItem('customLeaderboardOpen', 'true');
            
            // Inject self-updating JavaScript into the leaderboard window
            // This allows the leaderboard to update even when the main page is not active
            var updateScript = leaderboardWindow.document.createElement('script');
            updateScript.textContent = `
                (function() {
                    var lastUpdateTime = null;
                    
                    function updateFromLocalStorage() {
                        try {
                            var savedData = localStorage.getItem('customGameState');
                            if (!savedData) return;
                            
                            var parsed = JSON.parse(savedData);
                            if (!parsed || !parsed.gameState) return;
                            
                            var gameState = parsed.gameState;
                            
                            // Check if this is a new update (by comparing timestamp)
                            if (parsed.timestamp === lastUpdateTime) return;
                            lastUpdateTime = parsed.timestamp;
                            
                            var content = document.getElementById('leaderboardContent');
                            var subtitle = document.getElementById('leaderboardSubtitle');
                            var gameNameEl = document.getElementById('leaderboardGameName');
                            
                            if (!content || !subtitle) return;
                            
                            // Update window title
                            document.title = 'üèÜ ' + (gameState.gameName || 'Custom Game') + ' - Live Leaderboard';
                            
                            // Update game name
                            if (gameNameEl) {
                                gameNameEl.textContent = gameState.gameName || 'Custom Game';
                            }
                            
                            // Update subtitle with game status
                            var completedPlayers = gameState.players.filter(function(p) { 
                                return p.scores && p.scores.some(function(round) {
                                    return round && round.some(function(distance) {
                                        return distance && distance.some(function(throwScore) { 
                                            return throwScore !== null && throwScore !== undefined; 
                                        });
                                    });
                                });
                            }).length;
                            subtitle.textContent = completedPlayers + '/' + gameState.players.length + ' players have scores';
                            
                            // Clear existing content
                            content.innerHTML = '';
                            
                            if (gameState.players.length === 0) {
                                var noPlayersDiv = document.createElement('div');
                                noPlayersDiv.className = 'no-players';
                                noPlayersDiv.innerHTML = 'üë• No players added yet<br><span style="font-size: 0.9rem; opacity: 0.7; margin-top: 10px; display: block;">Add players to see live rankings</span>';
                                content.appendChild(noPlayersDiv);
                                return;
                            }
                            
                            // Sort players by total score (descending)
                            var sortedPlayers = gameState.players.slice().sort(function(a, b) {
                                return (b.total || 0) - (a.total || 0);
                            });
                            
                            // Determine layout based on number of players
                            var playersToShow = sortedPlayers.slice(0, 20);
                            var playerCount = playersToShow.length;
                            
                            // Apply appropriate CSS class based on player count
                            if (playerCount <= 10) {
                                var sizeClass = '';
                                if (playerCount <= 2) {
                                    sizeClass = ' few-players-1-2';
                                } else if (playerCount <= 4) {
                                    sizeClass = ' few-players-3-4';
                                } else if (playerCount <= 6) {
                                    sizeClass = ' few-players-5-6';
                                } else if (playerCount <= 8) {
                                    sizeClass = ' few-players-7-8';
                                } else if (playerCount <= 10) {
                                    sizeClass = ' few-players-9-10';
                                }
                                content.className = 'leaderboard-content single-column' + sizeClass;
                            } else {
                                content.className = 'leaderboard-content two-column';
                            }
                            
                            // Create leaderboard items
                            playersToShow.forEach(function(player, index) {
                                var rank = index + 1;
                                var item = document.createElement('div');
                                item.className = 'leaderboard-item';
                                
                                if (rank === 1) item.classList.add('rank-1');
                                else if (rank === 2) item.classList.add('rank-2');
                                else if (rank === 3) item.classList.add('rank-3');
                                
                                var rankDisplay = rank;
                                if (rank === 1) rankDisplay = 'ü•á';
                                else if (rank === 2) rankDisplay = 'ü•à';
                                else if (rank === 3) rankDisplay = 'ü•â';
                                
                                var percentageValue = typeof player.percentage === 'number' ? player.percentage : parseFloat(player.percentage) || 0;
                                item.innerHTML = 
                                    '<div class="rank-number">' + rankDisplay + '</div>' +
                                    '<div class="player-info">' +
                                        '<div class="player-name">' + (player.name || 'Player') + '</div>' +
                                        '<div class="player-stats">' + percentageValue.toFixed(1) + '%</div>' +
                                    '</div>' +
                                    '<div class="player-score">' + (player.total || 0) + '</div>';
                                
                                content.appendChild(item);
                            });
                        } catch (error) {
                            console.error('Error updating leaderboard from localStorage:', error);
                        }
                    }
                    
                    // Initial update
                    setTimeout(updateFromLocalStorage, 100);
                    
                    // Poll localStorage every 1 second for updates
                    setInterval(updateFromLocalStorage, 1000);
                })();
            `;
            leaderboardWindow.document.head.appendChild(updateScript);
            
            // Initial update from main page (for immediate display)
            setTimeout(function() {
                updateLeaderboardWindow();
            }, 100);
            
            // Set up auto-refresh from main page (as backup)
            var refreshInterval = setInterval(function() {
                if (!leaderboardWindow || leaderboardWindow.closed) {
                    clearInterval(refreshInterval);
                } else {
                    updateLeaderboardWindow();
                }
            }, 2000);
            
            // Clean up reference when window is closed
            leaderboardWindow.addEventListener('beforeunload', function() {
                leaderboardWindow = null;
                localStorage.removeItem('customLeaderboardOpen');
            });
        }

        // Try to reconnect to leaderboard window if reference was lost
        function tryReconnectLeaderboard() {
            // If we already have a valid reference, we're good
            if (leaderboardWindow && !leaderboardWindow.closed) {
                return true;
            }
            
            // Only try to reconnect if localStorage says a window should exist
            if (localStorage.getItem('customLeaderboardOpen') !== 'true') {
                return false;
            }
            
            try {
                // Try to get reference to existing window using minimal features
                // If a new window is created, it will be tiny and off-screen
                var existingWindow = window.open('', 'leaderboard', 'width=1,height=1,left=-2000,top=-2000');
                
                if (existingWindow && !existingWindow.closed) {
                    // Check if it's actually our leaderboard window
                    var hasContent = existingWindow.document.body && 
                                   existingWindow.document.body.children.length > 0 &&
                                   existingWindow.document.getElementById('leaderboardContent');
                    
                    if (hasContent) {
                        console.log('üîó Reconnected to existing leaderboard window!');
                        leaderboardWindow = existingWindow;
                        // Restore window to normal size if it was our existing window
                        if (existingWindow.outerWidth === 1) {
                            existingWindow.resizeTo(1200, 800);
                        }
                        return true;
                    } else {
                        // Not our window or blank - close it immediately and clear flag
                        existingWindow.close();
                        localStorage.removeItem('customLeaderboardOpen');
                    }
                } else {
                    // Window doesn't exist - clear flag
                    localStorage.removeItem('customLeaderboardOpen');
                }
            } catch (error) {
                // Silently fail
                localStorage.removeItem('customLeaderboardOpen');
            }
            return false;
        }

        // Function to manually refresh leaderboard (called when page loads or state changes)
        function refreshLeaderboardIfOpen() {
            // Try to reconnect if needed, then update
            if (tryReconnectLeaderboard()) {
                updateLeaderboardWindow();
            }
        }

        // Function to update the leaderboard window content
        function updateLeaderboardWindow() {
            // Try to reconnect if needed
            if (!leaderboardWindow || leaderboardWindow.closed) {
                if (!tryReconnectLeaderboard()) {
                    return;
                }
            }

            var content = leaderboardWindow.document.getElementById('leaderboardContent');
            var subtitle = leaderboardWindow.document.getElementById('leaderboardSubtitle');
            
            if (!content || !subtitle) return;
            
            // Update window title
            leaderboardWindow.document.title = 'üèÜ ' + (gameState.gameName || 'Custom Game') + ' - Live Leaderboard';
            
            // Clear existing content
            content.innerHTML = '';
            
            // Update subtitle with game status
            var completedPlayers = gameState.players.filter(function(p) { 
                return p.scores.some(function(round) {
                    return round && round.some(function(distance) {
                        return distance && distance.some(function(throwScore) { 
                            return throwScore !== null && throwScore !== undefined; 
                        });
                    });
                });
            }).length;
            subtitle.textContent = completedPlayers + '/' + gameState.players.length + ' players have scores';

            if (gameState.players.length === 0) {
                var noPlayersDiv = leaderboardWindow.document.createElement('div');
                noPlayersDiv.className = 'no-players';
                noPlayersDiv.innerHTML = 'üë• No players added yet<br><span style="font-size: 0.9rem; opacity: 0.7; margin-top: 10px; display: block;">Add players to see live rankings</span>';
                content.appendChild(noPlayersDiv);
                return;
            }

            // Sort players by total score (descending)
            var sortedPlayers = gameState.players.slice().sort(function(a, b) {
                return b.total - a.total;
            });

            // Determine layout based on number of players
            var playersToShow = sortedPlayers.slice(0, 20);
            var playerCount = playersToShow.length;
            
            // Apply appropriate CSS class based on player count
            if (playerCount <= 10) {
                var sizeClass = '';
                if (playerCount <= 2) {
                    sizeClass = ' few-players-1-2';
                } else if (playerCount <= 4) {
                    sizeClass = ' few-players-3-4';
                } else if (playerCount <= 6) {
                    sizeClass = ' few-players-5-6';
                } else if (playerCount <= 8) {
                    sizeClass = ' few-players-7-8';
                } else if (playerCount <= 10) {
                    sizeClass = ' few-players-9-10';
                }
                content.className = 'leaderboard-content single-column' + sizeClass;
            } else {
                content.className = 'leaderboard-content two-column';
            }

            // Create leaderboard items
            playersToShow.forEach(function(player, index) {
                var rank = index + 1;
                var item = leaderboardWindow.document.createElement('div');
                item.className = 'leaderboard-item';
                
                if (rank === 1) item.classList.add('rank-1');
                else if (rank === 2) item.classList.add('rank-2');
                else if (rank === 3) item.classList.add('rank-3');
                
                var rankDisplay = rank;
                if (rank === 1) rankDisplay = 'ü•á';
                else if (rank === 2) rankDisplay = 'ü•à';
                else if (rank === 3) rankDisplay = 'ü•â';
                
                var percentageValue = typeof player.percentage === 'number' ? player.percentage : parseFloat(player.percentage) || 0;
                item.innerHTML = `
                    <div class="rank-number">${rankDisplay}</div>
                    <div class="player-info">
                        <div class="player-name">${player.name}</div>
                        <div class="player-stats">
                            ${percentageValue.toFixed(1)}%
                        </div>
                    </div>
                    <div class="player-score">${player.total}</div>
                `;
                
                content.appendChild(item);
            });
        }

        // Legacy function for compatibility - redirect to window version
        function toggleLeaderboard() {
            openLeaderboardWindow();
        }

        function handleLeaderboardDrag(e) {
            if (leaderboardDragging) {
                var window = document.getElementById('leaderboardWindow');
                window.style.left = (e.clientX - leaderboardOffset.x) + 'px';
                window.style.top = (e.clientY - leaderboardOffset.y) + 'px';
                window.style.right = 'auto';
            }
        }

        function stopLeaderboardDrag() {
            leaderboardDragging = false;
            document.removeEventListener('mousemove', handleLeaderboardDrag);
            document.removeEventListener('mouseup', stopLeaderboardDrag);
        }

        // Custom Preset Functions
        function saveGamePreset() {
            if (hasGameStarted()) {
                alert('Cannot save preset after game has started! Reset the game to save settings.');
                return;
            }
            
            // Get the game name from the input field
            var gameNameInput = document.getElementById('gameNameInput');
            var presetName = gameNameInput ? gameNameInput.value.trim() : '';
            
            if (!presetName) {
                alert('Please enter a Game Name first before saving a preset.');
                return;
            }
            
            // Check if name already exists in custom presets
            var customPresets = JSON.parse(localStorage.getItem('customGamePresets') || '{}');
            if (customPresets[presetName]) {
                if (confirm('A preset with this name already exists. Do you want to overwrite it?')) {
                    // Continue with saving
                    savePresetLogic();
                }
                return;
            }
            
            // If no conflict, proceed directly
            savePresetLogic();
            
            function savePresetLogic() {
                // Read ALL values directly from UI inputs to ensure we save what the user sees
                var roundsInput = document.getElementById('roundsInput');
                var throwsInput = document.getElementById('throwsInput');
                var maxScoreInput = document.getElementById('maxScoreInput');
                var numDistancesSelect = document.getElementById('numDistancesSelect');
                var playModeSelect = document.getElementById('playModeSelect');
                var tiebreakerSelect = document.getElementById('tiebreakerSelect');
                var finalizationModeSelect = document.getElementById('finalizationModeSelect');
                
                // Get current distances from custom distance input fields if they exist
                var currentDistances = [...gameState.distances]; // Start with current distances
                
                // Check if custom distance inputs are visible and get their values
                var customDistanceInputs = document.querySelectorAll('#distanceLabelsGrid input');
                if (customDistanceInputs.length > 0) {
                    // Custom distance inputs are visible, get their current values
                    currentDistances = [];
                    for (var i = 0; i < customDistanceInputs.length; i++) {
                        var inputValue = customDistanceInputs[i].value.trim();
                        if (inputValue) {
                            currentDistances.push(inputValue);
                        } else {
                            // If input is empty, use the original distance or a default
                            currentDistances.push(gameState.distances[i] || 'Distance ' + (i + 1));
                        }
                    }
                }
                
                // Get notes from input (if in edit mode) or gameState
                var notesInput = document.getElementById('gameNotesInput');
                var notesEditContainer = document.getElementById('gameNotesEditContainer');
                var notes = '';
                
                // If edit container is visible, get notes from input
                if (notesEditContainer && notesEditContainer.style.display !== 'none' && notesInput) {
                    notes = notesInput.value.trim();
                } else {
                    // Otherwise use gameState notes
                    notes = gameState.notes || '';
                }
                
                // Create preset object with current settings from UI inputs
                var newPreset = {
                    rounds: roundsInput ? parseInt(roundsInput.value) || gameState.rounds : gameState.rounds,
                    throwsPerRound: throwsInput ? parseInt(throwsInput.value) || gameState.throwsPerRound : gameState.throwsPerRound,
                    maxScore: maxScoreInput ? parseInt(maxScoreInput.value) || gameState.maxScore : gameState.maxScore,
                    numDistances: numDistancesSelect ? parseInt(numDistancesSelect.value) || gameState.numDistances : gameState.numDistances,
                    distances: currentDistances,
                    distancePreset: 'custom', // Always save as custom when saving custom preset
                    playMode: playModeSelect ? playModeSelect.value || gameState.playMode : gameState.playMode,
                    distancesOnTop: gameState.distancesOnTop !== undefined ? gameState.distancesOnTop : (gameState.playMode === 'sequential'),
                    tiebreakerMode: tiebreakerSelect ? tiebreakerSelect.value || gameState.tiebreakerMode : gameState.tiebreakerMode,
                    finalizationMode: finalizationModeSelect ? finalizationModeSelect.value || gameState.finalizationMode : gameState.finalizationMode,
                    gameName: presetName, // Save the game name in the preset
                    notes: notes // Save notes with the preset
                };
                
                try {
                    // Save to localStorage as custom preset
                    var customPresets = JSON.parse(localStorage.getItem('customGamePresets') || '{}');
                    customPresets[presetName] = newPreset;
                    localStorage.setItem('customGamePresets', JSON.stringify(customPresets));
                    
                    // Update gameState notes to match what was saved
                    gameState.notes = notes;
                    
                    // Update the dropdown to include the new preset
                    updatePresetDropdown();
                    
                    console.log('Preset saved with notes:', notes); // Debug log
                    showTimedNotification('üíæ Preset saved: ' + presetName, 2000);
                } catch (error) {
                    alert('Error saving preset: ' + error.message);
                }
            }
        }

        function updatePresetDropdown() {
            var select = document.getElementById('distancePresetSelect');
            if (!select) return;
            
            // Store current selection
            var currentValue = select.value;
            
            // Clear existing options except the default ones
            var defaultOptions = [
                { value: '', text: 'Select a game mode...', disabled: true, selected: true },
                { value: 'silhouette', text: 'Silhouette', disabled: false },
                { value: 'texas-t', text: 'Texas T', disabled: false },
                { value: 'custom', text: 'Custom (Set your own)', disabled: false },
                { value: '', text: '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Custom Presets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', disabled: true }
            ];
            var optionsToKeep = [];
            
            // Try to preserve existing default options with their current text
            for (var i = 0; i < select.options.length; i++) {
                var option = select.options[i];
                var defaultOption = defaultOptions.find(function(def) { return def.value === option.value; });
                if (defaultOption) {
                    optionsToKeep.push({
                        value: option.value,
                        text: option.textContent,
                        disabled: option.disabled,
                        selected: option.selected
                    });
                }
            }
            
            // Ensure all default options exist
            defaultOptions.forEach(function(defaultOption) {
                var exists = optionsToKeep.some(function(opt) { return opt.value === defaultOption.value; });
                if (!exists) {
                    optionsToKeep.push(defaultOption);
                }
            });
            
            // Sort options to maintain order: placeholder, default presets (silhouette, texas-t), custom, separator
            // Separate options by type for proper ordering
            var placeholderOpts = optionsToKeep.filter(function(opt) { return opt.value === '' && opt.disabled && opt.selected; });
            var defaultPresetOpts = optionsToKeep.filter(function(opt) { 
                return opt.value === 'silhouette' || opt.value === 'texas-t'; 
            });
            // Sort default presets: silhouette first, then texas-t
            defaultPresetOpts.sort(function(a, b) {
                if (a.value === 'silhouette') return -1;
                if (b.value === 'silhouette') return 1;
                if (a.value === 'texas-t') return -1;
                if (b.value === 'texas-t') return 1;
                return 0;
            });
            var customOpts = optionsToKeep.filter(function(opt) { return opt.value === 'custom'; });
            var separatorOpts = optionsToKeep.filter(function(opt) { return opt.value === '' && opt.disabled && !opt.selected; });
            var otherOpts = optionsToKeep.filter(function(opt) { 
                return opt.value !== '' && opt.value !== 'silhouette' && opt.value !== 'texas-t' && opt.value !== 'custom'; 
            });
            
            optionsToKeep = placeholderOpts.concat(defaultPresetOpts).concat(customOpts).concat(separatorOpts).concat(otherOpts);
            
            // Clear and rebuild
            select.innerHTML = '';
            
            // Add default options back
            optionsToKeep.forEach(function(optionData) {
                var option = document.createElement('option');
                option.value = optionData.value;
                option.textContent = optionData.text;
                if (optionData.disabled) {
                    option.disabled = true;
                }
                if (optionData.selected) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            // Add custom presets
            var customPresets = JSON.parse(localStorage.getItem('customGamePresets') || '{}');
            Object.keys(customPresets).forEach(function(presetName) {
                var option = document.createElement('option');
                option.value = 'custom_' + presetName;
                option.textContent = presetName + ' (Custom)';
                select.appendChild(option);
            });
            
            // Restore current selection if it still exists
            if (currentValue) {
                select.value = currentValue;
            }
        }

        function loadCustomPreset(presetName) {
            if (hasGameStarted()) {
                alert('Cannot load preset after game has started! Reset the game to change settings.');
                document.getElementById('distancePresetSelect').value = 'custom';
                return;
            }
            
            var customPresets = JSON.parse(localStorage.getItem('customGamePresets') || '{}');
            var preset = customPresets[presetName];
            if (!preset) {
                alert('Preset not found!');
                document.getElementById('distancePresetSelect').value = 'custom';
                return;
            }
            
            // Apply preset settings - use preset values directly with fallbacks
            gameState.rounds = preset.rounds !== undefined ? preset.rounds : 5;
            gameState.throwsPerRound = preset.throwsPerRound !== undefined ? preset.throwsPerRound : 3;
            gameState.maxScore = preset.maxScore !== undefined ? preset.maxScore : 5;
            gameState.numDistances = preset.numDistances !== undefined ? preset.numDistances : 5;
            gameState.distances = preset.distances || [];
            gameState.distancePreset = 'custom_' + presetName; // Store full preset identifier
            gameState.currentPresetName = presetName; // Store preset name for reference
            gameState.playMode = preset.playMode !== undefined ? preset.playMode : 'sequential';
            gameState.distancesOnTop = preset.distancesOnTop !== undefined ? preset.distancesOnTop : (preset.playMode === 'sequential');
            gameState.tiebreakerMode = preset.tiebreakerMode !== undefined ? preset.tiebreakerMode : 'sudden-death';
            gameState.finalizationMode = preset.finalizationMode !== undefined ? preset.finalizationMode : 'auto';
            gameState.gameName = preset.gameName || presetName; // Use saved game name or preset name
            gameState.notes = preset.notes || ''; // Load notes from preset
            
            // Update target rings based on max score
            gameState.targetRings = [];
            for (var i = gameState.maxScore; i >= 0; i--) {
                gameState.targetRings.push(i);
            }
            
            // Update ALL UI inputs directly (regardless of settingsVisible)
            // Use preset values directly to ensure they're set correctly
            var gameNameInput = document.getElementById('gameNameInput');
            if (gameNameInput) {
                gameNameInput.value = preset.gameName || presetName || '';
            }
            
            var roundsInput = document.getElementById('roundsInput');
            if (roundsInput) {
                roundsInput.value = preset.rounds !== undefined ? preset.rounds : 5;
            }
            
            var throwsInput = document.getElementById('throwsInput');
            if (throwsInput) {
                throwsInput.value = preset.throwsPerRound !== undefined ? preset.throwsPerRound : 3;
            }
            
            var maxScoreInput = document.getElementById('maxScoreInput');
            if (maxScoreInput) {
                maxScoreInput.value = preset.maxScore !== undefined ? preset.maxScore : 5;
            }
            
            var tiebreakerSelect = document.getElementById('tiebreakerSelect');
            if (tiebreakerSelect) {
                tiebreakerSelect.value = preset.tiebreakerMode !== undefined ? preset.tiebreakerMode : 'sudden-death';
            }
            
            var finalizationModeSelect = document.getElementById('finalizationModeSelect');
            if (finalizationModeSelect) {
                finalizationModeSelect.value = preset.finalizationMode !== undefined ? preset.finalizationMode : 'auto';
            }
            
            var numDistancesSelect = document.getElementById('numDistancesSelect');
            if (numDistancesSelect) {
                numDistancesSelect.value = preset.numDistances !== undefined ? preset.numDistances : 5;
            }
            
            var playModeSelect = document.getElementById('playModeSelect');
            if (playModeSelect) {
                playModeSelect.value = preset.playMode !== undefined ? preset.playMode : 'sequential';
            }
            var distancesOnTopCheckbox = document.getElementById('distancesOnTopCheckbox');
            if (distancesOnTopCheckbox) {
                distancesOnTopCheckbox.checked = gameState.distancesOnTop;
            }

            // Set the distance preset dropdown to the custom preset FIRST
            var distancePresetSelect = document.getElementById('distancePresetSelect');
            if (distancePresetSelect) {
                distancePresetSelect.value = 'custom_' + presetName;
            }
            
            // Update notes from preset data
            var notes = preset.notes || '';
            gameState.notes = notes; // Update gameState
            
            // Update notes display using the new UI logic
            updateNotesDisplay();
            
            // Reset all players' scores arrays to match new settings
            gameState.players.forEach(function(player) {
                player.scores = Array(gameState.rounds).fill(null).map(function() { 
                    return Array(gameState.numDistances).fill(null).map(function() { 
                        return Array(gameState.throwsPerRound).fill(null); 
                    });
                });
                player.total = 0;
                player.average = 0;
                player.bullseyes = 0;
                player.percentage = 0;
                player.currentRound = 1;
                player.currentThrow = 1;
                player.currentDistance = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
            });
            
            // Update UI to reflect loaded settings (if panel is visible)
            if (settingsVisible) {
                updateSettingsPanel();
            }
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn) applyBtn.classList.remove('apply-glow');
            
            // Always update notes display after loading preset (regardless of panel visibility)
            // This ensures notes are displayed when panel is opened later
            updateNotesDisplay();
            
            // Show custom distance panel if preset uses custom distances
            var customPanel = document.getElementById('customDistancePanel');
            if (preset.distancePreset === 'custom') {
                if (customPanel) {
                    customPanel.style.display = 'block';
                }
            } else {
                if (customPanel) {
                    customPanel.style.display = 'none';
                }
            }
            
            // Always generate distance label inputs to populate them with saved values
            generateDistanceLabelInputs();
            
            updateGameDisplay();
            renderPlayers();
            if (leaderboardVisible) {
                updateLeaderboard();
            updateLeaderboardWindow();
            }
            
            showTimedNotification('üéØ Loaded custom preset: ' + presetName, 2000);
        }

        function removeSelectedPreset() {
            // Get all custom presets
            var customPresets = JSON.parse(localStorage.getItem('customGamePresets') || '{}');
            var presetNames = Object.keys(customPresets);
            
            // Check if there are any custom presets to remove
            if (presetNames.length === 0) {
                alert('No custom presets found to remove.');
                return;
            }
            
            // Create a modal to select which preset to remove
            var modalId = 'removePresetModal';
            var title = 'üóëÔ∏è Remove Custom Preset';
            var content = '<div style="text-align: left; margin: 20px 0;">';
            content += '<p style="color: #e2e8f0; margin-bottom: 15px;">Select a preset to remove:</p>';
            content += '<div id="presetListContainer" style="max-height: 300px; overflow-y: auto;">';
            
            presetNames.forEach(function(presetName, index) {
                var presetId = 'presetItem_' + index;
                content += '<div id="' + presetId + '" data-preset-name="' + presetName.replace(/"/g, '&quot;') + '" ';
                content += 'style="padding: 10px; margin: 5px 0; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; cursor: pointer; transition: all 0.2s;">';
                content += '<div style="font-weight: 600; color: #e2e8f0; font-size: 1rem;">' + presetName.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
                content += '<div style="font-size: 0.85rem; color: #94a3b8; margin-top: 5px;">';
                content += 'Rounds: ' + (customPresets[presetName].rounds || 'N/A') + ' | ';
                content += 'Throws: ' + (customPresets[presetName].throwsPerRound || 'N/A') + ' | ';
                content += 'Max Score: ' + (customPresets[presetName].maxScore || 'N/A');
                content += '</div>';
                content += '</div>';
            });
            
            content += '</div>';
            content += '</div>';
            
            var buttons = [
                {
                    text: 'Cancel',
                    onclick: 'closeModal("' + modalId + '")',
                    style: 'background: #64748b;'
                }
            ];
            
            var modal = createModal(modalId, title, content, buttons);
            
            // Add event listeners to preset items after modal is created
            setTimeout(function() {
                presetNames.forEach(function(presetName, index) {
                    var presetId = 'presetItem_' + index;
                    var presetElement = document.getElementById(presetId);
                    if (presetElement) {
                        presetElement.addEventListener('mouseenter', function() {
                            this.style.background = 'rgba(59, 130, 246, 0.2)';
                            this.style.borderColor = '#3b82f6';
                        });
                        presetElement.addEventListener('mouseleave', function() {
                            this.style.background = 'rgba(59, 130, 246, 0.1)';
                            this.style.borderColor = 'rgba(59, 130, 246, 0.3)';
                        });
                        presetElement.addEventListener('click', function() {
                            var presetToRemove = this.getAttribute('data-preset-name');
                            confirmRemovePreset(presetToRemove);
                            closeModal(modalId);
                        });
                    }
                });
            }, 100);
        }
        
        function confirmRemovePreset(presetName) {
            // Double confirm before removing
            if (!confirm('Are you sure you want to remove the preset "' + presetName + '"?\n\nThis action cannot be undone.')) {
                return;
            }
            
            // Remove custom preset from localStorage
            var customPresets = JSON.parse(localStorage.getItem('customGamePresets') || '{}');
            delete customPresets[presetName];
            localStorage.setItem('customGamePresets', JSON.stringify(customPresets));
            
            // Update the dropdown
            updatePresetDropdown();
            
            // Reset dropdown to default if the removed preset was selected
            var presetSelect = document.getElementById('distancePresetSelect');
            if (presetSelect && presetSelect.value === 'custom_' + presetName) {
                presetSelect.value = '';
            }
            
            showTimedNotification('üóëÔ∏è Custom preset removed: ' + presetName, 3000);
        }

        // Load custom presets on page load
        function loadCustomPresets() {
            updatePresetDropdown();
        }

        function clearScores() {
            showClearScoresConfirm('Clear all scores? This will reset all player scores to zero. Game settings and players will be kept.', function() {
                // Clear all scores for all players (keep current game settings)
                gameState.players.forEach(function(player) {
                    player.scores = Array(gameState.rounds).fill(null).map(function() { 
                        return Array(gameState.throwsPerRound).fill(null); 
                    });
                    player.total = 0;
                    player.average = 0;
                    player.bullseyes = 0;
                    player.percentage = 0;
                    player.currentRound = 1;
                    player.currentThrow = 1;
                    player.currentDistance = 1;
                    player.viewingRound = 1;
                    player.viewingDistance = 1;
                    player.gameComplete = false;
                    // Clear tiebreaker data
                    player.tiebreakerScores = [];
                    player.tiebreakerTotal = 0;
                    player.tiebreakerComplete = false;
                    player.tiebreakerCurrentThrow = 1;
                });
                
                gameState.editingThrow = null;
                gameState.gameFinalized = false;
                gameState.inTiebreaker = false;
                gameState.tiebreakerRound = 0;
                gameState.tiedPlayers = [];
                
                // Reset pagination settings
                gameState.currentPage = 1;
                gameState.playersPerPage = 20;
                gameState.totalPages = 1;
                
                // Update UI
                renderPlayers();
                if (settingsVisible) {
                    updateSettingsPanel();
                }
                updateGameDisplay();
                if (leaderboardVisible) {
                    updateLeaderboard();
            updateLeaderboardWindow();
                }
                updateLeaderboardWindow();
                
                showTimedNotification('üßπ All scores cleared! Players and settings preserved.', 3000);
            });
        }

        function clearPlayers() {
            showClearPlayersConfirm('Remove all players? This will delete all players and their data and return all settings to default.', function() {
                // Reset all settings to default values
                gameState.rounds = 5;
                gameState.throwsPerRound = 3;
                gameState.maxScore = 5;
                gameState.targetRings = [5, 4, 3, 2, 1, 0];
                gameState.distances = ['2 Meters', '3 Meters', '4 Meters', '5 Meters', '6 Meters'];
                gameState.distancePreset = 'amateur';
                gameState.numDistances = 5;
                gameState.playMode = 'sequential';
                gameState.gameName = '';
                gameState.tiebreakerMode = 'sudden-death';
                
                // Clear all players
                gameState.players = [];
                gameState.editingThrow = null;
                gameState.gameFinalized = false;
                gameState.inTiebreaker = false;
                gameState.tiebreakerRound = 0;
                gameState.tiedPlayers = [];
                
                // Reset pagination settings
                gameState.currentPage = 1;
                gameState.playersPerPage = 20;
                gameState.totalPages = 1;
                
                // Reset player ID counter
                playerId = 1;
                
                // Update UI
                renderPlayers();
                if (settingsVisible) {
                    updateSettingsPanel();
                }
                updateGameDisplay();
                if (leaderboardVisible) {
                    updateLeaderboard();
            updateLeaderboardWindow();
                }
                updateLeaderboardWindow();
                
                saveGameState(); // Auto-save after clearing players
                
                showTimedNotification('üóëÔ∏è All players removed and settings reset to default!', 3000);
            });
        }

        // Clear scores confirmation modal function
        function showClearScoresConfirm(message, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10005; padding: 20px;';
            
            // Add a flag to prevent double-processing
            let modalProcessed = false;
            
            // Generate unique IDs for this modal instance
            const modalId = 'clearScoresModal_' + Date.now();
            const confirmBtnId = 'clearScoresConfirmBtn_' + Date.now();
            const cancelBtnId = 'clearScoresCancelBtn_' + Date.now();
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #3b82f6; border-radius: 15px; padding: 30px; max-width: 500px; width: 100%; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; text-align: center;';
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">üßπ</div>
                    <h2 style="margin: 0; color: #f59e0b; font-size: 1.5rem; margin-bottom: 15px;">Clear Scores</h2>
                    <p style="margin: 0; color: #cbd5e1; font-size: 1rem; line-height: 1.5;">${message}</p>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="${confirmBtnId}" style="background: linear-gradient(45deg, #10b981, #059669); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚úÖ Clear Scores</button>
                    <button id="${cancelBtnId}" style="background: linear-gradient(45deg, #64748b, #475569); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚ùå Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Get button references after adding to DOM using unique IDs
            const confirmBtn = document.getElementById(confirmBtnId);
            const cancelBtn = document.getElementById(cancelBtnId);
            
            // Ensure buttons exist before adding event listeners
            if (confirmBtn && cancelBtn) {
                // Add hover effects
                confirmBtn.addEventListener('mouseenter', () => {
                    confirmBtn.style.transform = 'scale(1.05)';
                    confirmBtn.style.boxShadow = '0 4px 12px rgba(16, 185, 129, 0.3)';
                });
                
                confirmBtn.addEventListener('mouseleave', () => {
                    confirmBtn.style.transform = 'scale(1)';
                    confirmBtn.style.boxShadow = 'none';
                });
                
                cancelBtn.addEventListener('mouseenter', () => {
                    cancelBtn.style.transform = 'scale(1.05)';
                    cancelBtn.style.boxShadow = '0 4px 12px rgba(100, 116, 139, 0.3)';
                });
                
                cancelBtn.addEventListener('mouseleave', () => {
                    cancelBtn.style.transform = 'scale(1)';
                    cancelBtn.style.boxShadow = 'none';
                });
                
                confirmBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        console.error('Error removing clear scores modal:', error);
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    if (onConfirm) onConfirm();
                });
                
                cancelBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        console.error('Error removing clear scores modal:', error);
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    if (onCancel) onCancel();
                });
                
                // Focus the confirm button for keyboard navigation
                setTimeout(() => confirmBtn.focus(), 100);
            }
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        console.error('Error removing clear scores modal:', error);
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    if (onCancel) onCancel();
                }
            });
            
            // Close modal on Escape key
            const closeOnEscape = function(e) {
                if (e.key === 'Escape') {
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        console.error('Error removing clear scores modal:', error);
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    document.removeEventListener('keydown', closeOnEscape);
                    if (onCancel) onCancel();
                }
            };
            
            document.addEventListener('keydown', closeOnEscape);
        }

        function showClearPlayersConfirm(message, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10005; padding: 20px;';
            
            // Add a flag to prevent double-processing
            let modalProcessed = false;
            
            // Generate unique IDs for this modal instance
            const modalId = 'clearModal_' + Date.now();
            const confirmBtnId = 'clearConfirmBtn_' + Date.now();
            const cancelBtnId = 'clearCancelBtn_' + Date.now();
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #3b82f6; border-radius: 15px; padding: 30px; max-width: 500px; width: 100%; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; text-align: center;';
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">‚ùì</div>
                    <h2 style="margin: 0; color: #ef4444; font-size: 1.5rem; margin-bottom: 15px;">Clear Players</h2>
                    <p style="margin: 0; color: #cbd5e1; font-size: 1rem; line-height: 1.5;">${message}</p>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="${confirmBtnId}" style="background: linear-gradient(45deg, #10b981, #059669); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚úÖ Confirm</button>
                    <button id="${cancelBtnId}" style="background: linear-gradient(45deg, #64748b, #475569); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚ùå Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Get button references after adding to DOM using unique IDs
            const confirmBtn = document.getElementById(confirmBtnId);
            const cancelBtn = document.getElementById(cancelBtnId);
            
            // Ensure buttons exist before adding event listeners
            if (confirmBtn && cancelBtn) {
                // Add hover effects
                confirmBtn.addEventListener('mouseenter', () => {
                    confirmBtn.style.transform = 'scale(1.05)';
                    confirmBtn.style.boxShadow = '0 4px 12px rgba(16, 185, 129, 0.3)';
                });
                
                confirmBtn.addEventListener('mouseleave', () => {
                    confirmBtn.style.transform = 'scale(1)';
                    confirmBtn.style.boxShadow = 'none';
                });
                
                cancelBtn.addEventListener('mouseenter', () => {
                    cancelBtn.style.transform = 'scale(1.05)';
                    cancelBtn.style.boxShadow = '0 4px 12px rgba(100, 116, 139, 0.3)';
                });
                
                cancelBtn.addEventListener('mouseleave', () => {
                    cancelBtn.style.transform = 'scale(1)';
                    cancelBtn.style.boxShadow = 'none';
                });
                
                confirmBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        console.error('Error removing clear players modal:', error);
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    if (onConfirm) onConfirm();
                });
                
                cancelBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        console.error('Error removing clear players modal:', error);
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    if (onCancel) onCancel();
                });
                
                // Focus the confirm button for keyboard navigation
                setTimeout(() => confirmBtn.focus(), 100);
            }
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        console.error('Error removing clear players modal:', error);
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    if (onCancel) onCancel();
                }
            });
            
            // Close modal on Escape key
            const closeOnEscape = function(e) {
                if (e.key === 'Escape') {
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        console.error('Error removing clear players modal:', error);
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    document.removeEventListener('keydown', closeOnEscape);
                    if (onCancel) onCancel();
                }
            };
            
            document.addEventListener('keydown', closeOnEscape);
        }

        // Make pagination functions globally available
        window.changePage = changePage;
        window.changePlayersPerPage = changePlayersPerPage;

        // ===== PLAYER IMPORT FUNCTIONS =====
        
        function importFromManagement() {
            // Check if game has started
            if (hasGameStarted()) {
                alert('Cannot import players after scoring has begun! Reset the game to import players.');
                return;
            }
            
            // Check if game is finalized
            if (gameState.gameFinalized) {
                alert('Cannot import players after game has been finalized!');
                return;
            }
            
            // Try to get data from the new format first (competitorImportData)
            var importData = localStorage.getItem('competitorImportData');
            
            // If not found, try to get from the old format (tournamentPlayers)
            if (!importData) {
                var tournamentPlayers = localStorage.getItem('tournamentPlayers');
                if (tournamentPlayers) {
                    try {
                        var players = JSON.parse(tournamentPlayers);
                        if (players.length > 0) {
                            // Show class/division selection modal
                            showImportSelectionModal(players);
                            return;
                        }
                    } catch (e) {
                        console.error('Error converting tournament players:', e);
                    }
                }
            }
            
            if (!importData) {
                showTimedNotification('‚ùå No players found in import data. Please add players in Management first.', 4000);
                return;
            }
            
            try {
                var players = JSON.parse(importData);
                
                if (players.length === 0) {
                    showTimedNotification('‚ùå No players found in import data.', 3000);
                    return;
                }
                
                // Set game name for imported players
                var tournamentName = localStorage.getItem('tournamentName') || 'Tournament';
                gameState.gameName = tournamentName + ' - Custom Game';
                
                // Update the game name input field
                var gameNameInput = document.getElementById('gameNameInput');
                if (gameNameInput) {
                    gameNameInput.value = gameState.gameName;
                }
                
                // Clear the import data
                localStorage.removeItem('competitorImportData');
                
                // Use the common import function
                performImport(players);
                
                // Import success notification removed
            } catch (error) {
                console.error('Import error:', error);
                showTimedNotification('‚ùå Error importing players. Please try again.', 4000);
            }
        }
        
        // Import selection modal to choose class and division
        function showImportSelectionModal(allPlayers) {
            var classes = [...new Set(allPlayers.map(function(p) { return p.className; }).filter(function(className) { return className && className.trim() !== ''; }))].sort();
            var playerCounts = {};
            allPlayers.forEach(function(player) {
                var key = player.className + ' - ' + player.divisionName;
                playerCounts[key] = (playerCounts[key] || 0) + 1;
            });
            
            var modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10002; padding: 20px;';
            
            var modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #8b5cf6; border-radius: 15px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;';
            
            var classOptions = classes.map(function(className) {
                return '<option value="' + className + '">' + className + '</option>';
            }).join('');
            
            modalContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <h2 style="color: #8b5cf6; font-size: 1.5rem; margin-bottom: 10px;">üì• Select Players to Import</h2>
                    <p style="color: #94a3b8; font-size: 0.9rem;">Choose class and division to import from Management</p>
                </div>
                
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #334155;">
                    <h3 style="color: #f1f5f9; margin-bottom: 15px; font-size: 1.1rem;">üéØ Select Class and Division:</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 8px; color: #cbd5e1; font-weight: 500; font-size: 0.9rem;">Class:</label>
                            <select id="importClassSelect" onchange="updateImportDivisionOptions()" style="width: 100%; background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                                <option value="">Select Class...</option>
                                ${classOptions}
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 8px; color: #cbd5e1; font-weight: 500; font-size: 0.9rem;">Division:</label>
                            <select id="importDivisionSelect" style="width: 100%; background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                                <option value="">Select Division...</option>
                            </select>
                        </div>
                    </div>
                    <div id="importPlayerCount" style="background: rgba(30, 41, 59, 0.8); padding: 15px; border-radius: 8px; border: 1px solid #475569; margin-bottom: 15px; display: none;">
                        <div style="text-align: center; color: #f1f5f9; font-weight: 500;">
                            <span id="selectedPlayerCount">0</span> players available for import
                        </div>
                    </div>
                    <button id="importSelectedBtn" onclick="importFromDropdown()" style="background: linear-gradient(45deg, #8b5cf6, #a855f7); border: none; color: white; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-weight: 500; width: 100%; font-size: 1rem; transition: all 0.3s ease; opacity: 0.5; pointer-events: none;">üì• Import Selected Players</button>
                </div>
                
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #334155;">
                    <h3 style="color: #f1f5f9; margin-bottom: 15px; font-size: 1.1rem;">üìä Quick Import Options:</h3>
                    <div style="display: grid; gap: 10px;">
                        <button onclick="importAllPlayers();" style="background: linear-gradient(45deg, #10b981, #059669); border: none; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.3s ease;">üì• Import All ${allPlayers.length} Players</button>
                        <button onclick="showAvailableGroups();" style="background: linear-gradient(45deg, #f59e0b, #d97706); border: none; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.3s ease;">üìã View All Available Groups</button>
                        <button onclick="showEventImportOptions();" style="background: linear-gradient(45deg, #3b82f6, #1d4ed8); border: none; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.3s ease;">üéØ Import by Event</button>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="closeMainImportModal();" style="background: #64748b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            window.importModalAllPlayers = allPlayers;
            
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                    delete window.importModalAllPlayers;
                }
            });
        }
        
        function updateImportDivisionOptions() {
            var classSelect = document.getElementById('importClassSelect');
            var divisionSelect = document.getElementById('importDivisionSelect');
            var playerCountDiv = document.getElementById('importPlayerCount');
            var importBtn = document.getElementById('importSelectedBtn');
            
            if (!classSelect || !divisionSelect || !window.importModalAllPlayers) return;
            
            var selectedClass = classSelect.value;
            divisionSelect.innerHTML = '<option value="">Select Division...</option>';
            playerCountDiv.style.display = 'none';
            importBtn.style.opacity = '0.5';
            importBtn.style.pointerEvents = 'none';
            
            if (!selectedClass) return;
            
            var divisionsForClass = [...new Set(window.importModalAllPlayers
                .filter(function(player) { return player.className === selectedClass; })
                .map(function(player) { return player.divisionName; })
            )].sort();
            
            divisionsForClass.forEach(function(division) {
                var option = document.createElement('option');
                option.value = division;
                option.textContent = division;
                divisionSelect.appendChild(option);
            });
            
            divisionSelect.addEventListener('change', function() {
                var selectedDivision = divisionSelect.value;
                if (!selectedDivision) {
                    playerCountDiv.style.display = 'none';
                    importBtn.style.opacity = '0.5';
                    importBtn.style.pointerEvents = 'none';
                    return;
                }
                
                var filteredPlayers = window.importModalAllPlayers.filter(function(p) {
                    return p.className === selectedClass && p.divisionName === selectedDivision;
                });
                
                var playerCountSpan = document.getElementById('selectedPlayerCount');
                if (playerCountSpan) {
                    playerCountSpan.textContent = filteredPlayers.length;
                }
                playerCountDiv.style.display = 'block';
                importBtn.style.opacity = '1';
                importBtn.style.pointerEvents = 'auto';
            });
        }
        
        function importFromDropdown() {
            var classSelect = document.getElementById('importClassSelect');
            var divisionSelect = document.getElementById('importDivisionSelect');
            
            if (!classSelect || !divisionSelect || !window.importModalAllPlayers) return;
            
            var selectedClass = classSelect.value;
            var selectedDivision = divisionSelect.value;
            
            if (!selectedClass || !selectedDivision) {
                showTimedNotification('‚ùå Please select both class and division.', 3000);
                return;
            }
            
            importSelectedPlayers(selectedClass, selectedDivision);
            
            var modal = document.querySelector('div[style*="z-index: 10002"]');
            if (modal) {
                modal.remove();
                delete window.importModalAllPlayers;
            }
        }
        
        function importSelectedPlayers(selectedClass, selectedDivision) {
            if (!window.importModalAllPlayers) return;
            
            var filteredPlayers = window.importModalAllPlayers.filter(function(p) {
                return p.className === selectedClass && p.divisionName === selectedDivision;
            });
            
            if (filteredPlayers.length === 0) {
                showTimedNotification('‚ùå No players found for selected class and division.', 3000);
                return;
            }
            
            // Convert to import format
            var playersToImport = filteredPlayers.map(function(p) {
                return {
                    name: p.name,
                    class: p.className,
                    division: p.divisionName,
                    event: p.eventName || 'No Event'
                };
            });
            
            // Set game name
            var tournamentName = localStorage.getItem('tournamentName') || 'Tournament';
            gameState.gameName = tournamentName + ' - ' + selectedClass + ' - ' + selectedDivision;
            
            // Update the game name input field
            var gameNameInput = document.getElementById('gameNameInput');
            if (gameNameInput) {
                gameNameInput.value = gameState.gameName;
            }
            
            // Perform import
            performImport(playersToImport);
        }
        
        function closeMainImportModal() {
            // Find and remove the main import modal (z-index: 10002)
            var mainModal = document.querySelector('div[style*="z-index: 10002"]');
            if (mainModal) {
                mainModal.remove();
            }
            
            // Also clear any stuck backdrops
            var backdrops = document.querySelectorAll('div[style*="background: rgba(0, 0, 0, 0.8)"]');
            backdrops.forEach(function(backdrop) {
                if (backdrop.style.position === 'fixed' && backdrop.style.zIndex === '10002') {
                    backdrop.remove();
                }
            });
            
            // Clear import modal data
            delete window.importModalAllPlayers;
        }
        
        function importAllPlayers() {
            var tournamentPlayers = localStorage.getItem('tournamentPlayers');
            if (!tournamentPlayers) {
                showTimedNotification('‚ùå No player data found.', 3000);
                return;
            }
            
            try {
                var allPlayers = JSON.parse(tournamentPlayers);
                var convertedData = allPlayers.map(function(player) {
                    return {
                        name: player.name,
                        class: player.className,
                        division: player.divisionName
                    };
                });
                
                // Set game name to indicate all players were imported
                var tournamentName = localStorage.getItem('tournamentName') || 'Tournament';
                gameState.gameName = tournamentName + ' - All Players';
                
                // Update the game name input field
                var gameNameInput = document.getElementById('gameNameInput');
                if (gameNameInput) {
                    gameNameInput.value = gameState.gameName;
                }
                
                performImport(convertedData);
                
                // Close modal
                closeMainImportModal();
            } catch (error) {
                console.error('Import error:', error);
                showTimedNotification('‚ùå Error importing players. Please try again.', 4000);
            }
        }
        
        function showAvailableGroups() {
            if (!window.importModalAllPlayers) return;
            
            var playerCounts = {};
            window.importModalAllPlayers.forEach(function(player) {
                var key = player.className + ' - ' + player.divisionName;
                playerCounts[key] = (playerCounts[key] || 0) + 1;
            });
            
            var filterOptions = [];
            Object.entries(playerCounts).forEach(function([key, count]) {
                var parts = key.split(' - ');
                var className = parts[0];
                var divisionName = parts[1];
                filterOptions.push({ className: className, divisionName: divisionName, count: count, key: key });
            });
            
            filterOptions.sort(function(a, b) { return b.count - a.count; });
            
            var groupsModal = document.createElement('div');
            groupsModal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10003; padding: 20px;';
            
            var groupsContent = document.createElement('div');
            groupsContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #f59e0b; border-radius: 15px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;';
            
            var groupsHtml = filterOptions.map(function(option) {
                return '<div style="background: linear-gradient(45deg, #475569, #64748b); border: 1px solid #64748b; color: white; padding: 15px; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;">' +
                    '<div>' +
                    '<div style="font-size: 1.1rem; font-weight: bold; color: #f1f5f9;">' + option.className + ' - ' + option.divisionName + '</div>' +
                    '<div style="font-size: 0.9rem; color: #94a3b8; margin-top: 4px;">' + option.count + ' player' + (option.count !== 1 ? 's' : '') + '</div>' +
                    '</div>' +
                    '<div style="font-size: 1.2rem; color: #f59e0b;">üìä</div>' +
                    '</div>';
            }).join('');
            
            groupsContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <h2 style="color: #f59e0b; font-size: 1.5rem; margin-bottom: 10px;">üìã Available Groups</h2>
                    <p style="color: #94a3b8; font-size: 0.9rem;">All class and division combinations with player counts</p>
                </div>
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #334155;">
                    <div style="display: grid; gap: 10px;">
                        ${groupsHtml}
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="closeGroupsModal();" style="background: #64748b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">Close</button>
                </div>
            `;
            
            groupsModal.appendChild(groupsContent);
            document.body.appendChild(groupsModal);
            
            groupsModal.addEventListener('click', function(e) {
                if (e.target === groupsModal) {
                    groupsModal.remove();
                }
            });
        }
        
        function closeGroupsModal() {
            var groupsModal = document.querySelector('div[style*="z-index: 10003"]');
            if (groupsModal) {
                groupsModal.remove();
            }
        }
        
        function showEventImportOptions() {
            if (!window.importModalAllPlayers) return;
            
            // Check if there are events stored in localStorage
            var events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
            
            if (events.length === 0) {
                alert('No events found in the tournament data.\n\nTo use event-based importing:\n1. Go to Management.html\n2. Create events in the Events section\n3. Assign players to events\n4. Then try importing by event again.');
                return;
            }
            
            // Create event-player mapping using the participants array in each event
            var eventPlayerCounts = {};
            events.forEach(function(event) {
                if (event.participants && event.participants.length > 0) {
                    // Count how many participants from this event are in the available players
                    // Match by ID first, then fall back to name/class/division matching
                    var eventPlayers = window.importModalAllPlayers.filter(function(player) {
                        return event.participants.some(function(participant) {
                            // Try matching by ID first
                            if (participant.id && player.id && participant.id === player.id) {
                                return true;
                            }
                            // Fall back to matching by name, class, and division
                            return participant.name === player.name && 
                                   participant.className === player.className && 
                                   participant.divisionName === player.divisionName;
                        });
                    });
                    eventPlayerCounts[event.name] = eventPlayers.length;
                } else {
                    eventPlayerCounts[event.name] = 0;
                }
            });
            
            // Filter out events with no players
            var eventsWithPlayers = events.filter(function(event) {
                return eventPlayerCounts[event.name] > 0;
            });
            
            if (eventsWithPlayers.length === 0) {
                alert('No players are assigned to events.\n\nTo assign players to events:\n1. Go to Management.html\n2. Go to the Events section\n3. Click "Manage Participants" on an event\n4. Add players to the event\n5. Then try importing by event again.');
                return;
            }
            
            // Create event import modal
            var eventModal = document.createElement('div');
            eventModal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10004; padding: 20px;';
            
            var eventContent = document.createElement('div');
            eventContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #3b82f6; border-radius: 15px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;';
            
            var eventButtonsHtml = eventsWithPlayers.map(function(event) {
                var playerCount = eventPlayerCounts[event.name];
                var eventIcon = getEventIcon(event.type);
                var eventTypeLabel = getEventTypeLabel(event.type);
                return '<button onclick="importEventPlayers(\'' + event.name.replace(/'/g, "\\'") + '\');" style="background: linear-gradient(45deg, #3b82f6, #1d4ed8); border: none; color: white; padding: 15px; border-radius: 10px; cursor: pointer; font-weight: 500; transition: all 0.3s ease; text-align: left; width: 100%;">' +
                    '<div style="font-size: 1.1rem; margin-bottom: 5px;">' + eventIcon + ' ' + event.name + '</div>' +
                    '<div style="font-size: 0.85rem; color: #cbd5e1; opacity: 0.8;">' + eventTypeLabel + '</div>' +
                    '<div style="font-size: 0.9rem; color: #cbd5e1; margin-top: 4px;">' + playerCount + ' player' + (playerCount !== 1 ? 's' : '') + ' available</div>' +
                    '</button>';
            }).join('');
            
            eventContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <h2 style="color: #3b82f6; font-size: 1.5rem; margin-bottom: 10px;">üéØ Import by Event</h2>
                    <p style="color: #94a3b8; font-size: 0.9rem;">Select an event to import all its participants</p>
                </div>
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #334155;">
                    <div style="display: grid; gap: 10px;">
                        ${eventButtonsHtml}
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="closeEventImportModal();" style="background: #64748b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">Cancel</button>
                </div>
            `;
            
            eventModal.appendChild(eventContent);
            document.body.appendChild(eventModal);
            
            eventModal.addEventListener('click', function(e) {
                if (e.target === eventModal) {
                    eventModal.remove();
                }
            });
        }
        
        function closeEventImportModal() {
            var eventModal = document.querySelector('div[style*="z-index: 10004"]');
            if (eventModal) {
                eventModal.remove();
            }
        }
        
        function importEventPlayers(eventName) {
            console.log('=== Import Event Players Debug ===');
            console.log('Event Name:', eventName);
            console.log('importModalAllPlayers exists:', !!window.importModalAllPlayers);
            
            if (!window.importModalAllPlayers) {
                console.error('No importModalAllPlayers found!');
                return;
            }
            
            console.log('Total available players:', window.importModalAllPlayers.length);
            console.log('Sample player:', window.importModalAllPlayers[0]);
            
            var events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
            console.log('Total events in storage:', events.length);
            
            var selectedEvent = events.find(function(event) { return event.name === eventName; });
            console.log('Selected event:', selectedEvent);
            
            if (!selectedEvent || !selectedEvent.participants) {
                console.error('Event not found or has no participants');
                showTimedNotification('‚ùå Event not found or has no participants.', 3000);
                return;
            }
            
            console.log('Event participants count:', selectedEvent.participants.length);
            console.log('Sample participant:', selectedEvent.participants[0]);
            
            // Filter players that are in this event
            // Match by ID first, then fall back to name/class/division matching
            var eventPlayers = window.importModalAllPlayers.filter(function(player) {
                return selectedEvent.participants.some(function(participant) {
                    // Try matching by ID first
                    if (participant.id && player.id && participant.id === player.id) {
                        console.log('Matched by ID:', player.name);
                        return true;
                    }
                    // Fall back to matching by name, class, and division
                    var nameMatch = participant.name === player.name;
                    var classMatch = participant.className === player.className;
                    var divisionMatch = participant.divisionName === player.divisionName;
                    
                    if (nameMatch && classMatch && divisionMatch) {
                        console.log('Matched by name/class/division:', player.name);
                        return true;
                    }
                    return false;
                });
            });
            
            console.log('Filtered event players count:', eventPlayers.length);
            
            if (eventPlayers.length === 0) {
                console.error('No matching players found!');
                console.log('Debug - First participant:', selectedEvent.participants[0]);
                console.log('Debug - First available player:', window.importModalAllPlayers[0]);
                showTimedNotification('‚ùå No players found for this event.', 3000);
                return;
            }
            
            // Convert to import format
            var playersToImport = eventPlayers.map(function(p) {
                return {
                    name: p.name,
                    class: p.className,
                    division: p.divisionName,
                    event: eventName
                };
            });
            
            console.log('Players to import:', playersToImport.length);
            console.log('Sample player to import:', playersToImport[0]);
            
            // Set game name
            var tournamentName = localStorage.getItem('tournamentName') || 'Tournament';
            gameState.gameName = tournamentName + ' - ' + eventName;
            
            // Update the game name input field
            var gameNameInput = document.getElementById('gameNameInput');
            if (gameNameInput) {
                gameNameInput.value = gameState.gameName;
            }
            
            // Close modals
            closeEventImportModal();
            closeMainImportModal();
            
            console.log('Calling performImport...');
            // Perform import
            performImport(playersToImport);
        }
        
        function performImport(players) {
            console.log('performImport called with', players ? players.length : 0, 'players');
            
            if (!players || players.length === 0) {
                console.error('No players to import!');
                showTimedNotification('‚ùå No players to import.', 3000);
                return;
            }
            
            console.log('Showing confirmation modal...');
            // Show confirmation modal
            showImportConfirmModal(players.length, function() {
                console.log('Import confirmed, executing importPlayersLogic...');
                importPlayersLogic();
            });
            
            function importPlayersLogic() {
                console.log('importPlayersLogic executing...');
                
                // Clear existing players before importing
                console.log('Clearing existing players. Current count:', gameState.players.length);
                gameState.players = [];
                
                // Import players
                players.forEach(function(playerData, index) {
                    var newPlayer = {
                        id: playerId++,
                        name: playerData.name || ('Player ' + (index + 1)),
                        scores: Array(gameState.rounds).fill(null).map(function() { 
                            return Array(gameState.numDistances).fill(null).map(function() { 
                                return Array(gameState.throwsPerRound).fill(null); 
                            });
                        }),
                        total: 0,
                        average: 0,
                        bullseyes: 0,
                        percentage: 0,
                        currentRound: 1,
                        currentThrow: 1,
                        currentDistance: 1,
                        viewingRound: 1,
                        viewingDistance: 1,
                        gameComplete: false
                    };
                    
                    gameState.players.push(newPlayer);
                    console.log('Added player:', newPlayer.name);
                });
                
                console.log('Total players after import:', gameState.players.length);
                
                // Reset pagination to show imported players
                gameState.currentPage = 1;
                
                // Update display
                console.log('Calling renderPlayers...');
                renderPlayers();
                console.log('Calling updateGameDisplay...');
                updateGameDisplay();
                
                if (leaderboardVisible) {
                    console.log('Updating leaderboard...');
                    updateLeaderboard();
            updateLeaderboardWindow();
                }
                
                console.log('Import complete!');
                showTimedNotification('‚úÖ Successfully imported ' + players.length + ' player' + (players.length !== 1 ? 's' : '') + '!', 3000);
            }
        }
        
        function showImportConfirmModal(playerCount, onConfirm) {
            console.log('showImportConfirmModal called with playerCount:', playerCount);
            console.log('onConfirm callback type:', typeof onConfirm);
            
            var message = 'Import ' + playerCount + ' player' + (playerCount !== 1 ? 's' : '') + ' from Management?';
            
            var modal = document.createElement('div');
            modal.id = 'importConfirmModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10003; padding: 20px;';
            
            var modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #8b5cf6; border-radius: 15px; padding: 30px; max-width: 500px; width: 100%; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; text-align: center;';
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">üì•</div>
                    <h2 style="margin: 0; color: #8b5cf6; font-size: 1.5rem; margin-bottom: 15px;">Import Players</h2>
                    <p style="margin: 0; color: #cbd5e1; font-size: 1rem; line-height: 1.5;">${message}</p>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="confirmImportBtn" style="background: linear-gradient(45deg, #8b5cf6, #a855f7); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">üì• Import Players</button>
                    <button id="cancelImportBtn" style="background: #64748b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚ùå Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Store callback
            window.importConfirmCallback = onConfirm;
            console.log('Callback stored in window.importConfirmCallback');
            
            // Add event listeners instead of inline onclick
            var confirmBtn = document.getElementById('confirmImportBtn');
            var cancelBtn = document.getElementById('cancelImportBtn');
            
            if (confirmBtn) {
                confirmBtn.addEventListener('click', function() {
                    console.log('Confirm button clicked!');
                    confirmImportAction();
                });
            } else {
                console.error('Confirm button not found!');
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', function() {
                    console.log('Cancel button clicked!');
                    closeImportConfirmModal();
                });
            }
        }
        
        function confirmImportAction() {
            console.log('confirmImportAction called!');
            console.log('Callback exists:', !!window.importConfirmCallback);
            
            // Store the callback before closing the modal (which clears it)
            var callback = window.importConfirmCallback;
            
            // Close the modal
            closeImportConfirmModal();
            
            // Execute the callback
            if (callback) {
                console.log('Executing import callback...');
                callback();
            } else {
                console.error('No import callback found!');
            }
        }
        
        function closeImportConfirmModal() {
            var modal = document.getElementById('importConfirmModal');
            if (modal) {
                modal.remove();
            }
            window.importConfirmCallback = null;
        }
        
        // Make import functions globally available
        window.importFromManagement = importFromManagement;
        window.updateImportDivisionOptions = updateImportDivisionOptions;
        window.importFromDropdown = importFromDropdown;
        window.importSelectedPlayers = importSelectedPlayers;
        window.closeMainImportModal = closeMainImportModal;
        window.importAllPlayers = importAllPlayers;
        window.showAvailableGroups = showAvailableGroups;
        window.closeGroupsModal = closeGroupsModal;
        window.showEventImportOptions = showEventImportOptions;
        window.closeEventImportModal = closeEventImportModal;
        window.importEventPlayers = importEventPlayers;
        window.confirmImportAction = confirmImportAction;
        window.closeImportConfirmModal = closeImportConfirmModal;
    </script>
</body>
</html>
