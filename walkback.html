<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triple Nickel - Walkback</title>
    <link rel="stylesheet" href="shared-sidebar.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        /* Override shared styles for full window layout */
        * {
            box-sizing: border-box;
        }
        
        html {
            height: 100%;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow-x: auto;
            overflow-y: auto;
            height: 100%;
            min-width: 320px;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: none !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            min-height: 100vh;
            min-width: 320px;
            display: flex;
            flex-direction: row;
        }

        /* Sidebar styles handled by shared-sidebar.css */

        /* Nav button and sidebar header styles handled by shared-sidebar.css */
        
        .game-interface {
            flex: 1;
            margin-left: clamp(250px, 20vw, 300px);
            padding: 15px;
            display: flex;
            flex-direction: column;
            min-width: 0;
            transition: margin-left 0.3s ease;
        }

        .game-interface.expanded {
            margin-left: 0;
        }
        
        /* Responsive player grid */
        .players-grid {
            display: grid !important;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)) !important;
            gap: 15px !important;
            margin-bottom: 20px !important;
            width: 100% !important;
            max-width: none !important;
            min-width: 0 !important;
        }
        
        /* Make player cards maintain minimum size when side by side */
        .player-card {
            position: relative;
            width: 100% !important;
            max-width: none !important;
            min-width: 0 !important;
            flex-shrink: 0 !important;
            overflow: hidden;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        /* Ensure all text content inside player cards wraps properly */
        .player-card * {
            box-sizing: border-box;
            max-width: 100%;
        }
        
        .player-card .player-name {
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .player-card .player-header {
            min-width: 0;
            overflow: hidden;
        }
        
        .player-card .player-name-section {
            min-width: 0;
            overflow: hidden;
            flex: 1 1 auto;
        }
        
        .player-card .player-stats {
            min-width: 0;
            flex-shrink: 1;
        }
        
        .player-card .score-details {
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden;
        }
        
        .player-card .score-buttons {
            min-width: 0;
            overflow: hidden;
        }
        
        .player-card .score-button {
            min-width: 0;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .player-card .round-nav-btn {
            min-width: 0;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        
        .round-nav-btn.in-progress {
            background: #f59e0b;
            color: white;
        }
        
        .player-card .throw-box {
            min-width: 0;
            overflow: hidden;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        /* Ensure all direct children of player-card handle overflow */
        .player-card > div {
            min-width: 0;
        }
        
        /* Ensure button containers wrap properly */
        .player-card div[style*="flex-wrap"] {
            min-width: 0;
            overflow: visible;
        }
        
        /* Ensure all spans and text elements wrap */
        .player-card span {
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }
        
        /* Ensure notification/status messages wrap */
        .player-card > div {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        /* Responsive header */
        .game-header {
            flex-wrap: wrap !important;
            gap: 10px !important;
            margin-bottom: 15px !important;
        }
        
        .action-buttons {
            flex-wrap: wrap !important;
            gap: 8px !important;
            justify-content: flex-end !important;
            margin-left: auto !important;
            padding-right: 60px !important;
        }
        
        .action-button {
            white-space: nowrap !important;
            min-width: fit-content !important;
        }
        
        /* Responsive settings panel grid */
        #settingsPanel {
            margin-bottom: 20px !important;
        }
        
        #settingsPanel .config-grid {
            display: grid !important;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)) !important;
            gap: 20px !important;
        }
        
        #customDistanceInputs {
            display: grid !important;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)) !important;
            gap: 15px !important;
        }
        
        /* Apply Changes button glow when settings have been modified */
        #applySettingsBtn.apply-glow {
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.8), 0 0 40px rgba(16, 185, 129, 0.4);
            animation: apply-glow-pulse 1.5s ease-in-out infinite;
        }
        @keyframes apply-glow-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.8), 0 0 40px rgba(16, 185, 129, 0.4); }
            50% { box-shadow: 0 0 28px rgba(16, 185, 129, 1), 0 0 50px rgba(16, 185, 129, 0.6); }
        }
        
        /* Responsive game info */
        .game-info {
            margin-bottom: 15px !important;
        }
        
        /* Add player button area */
        .add-player {
            margin-top: auto;
            padding: 15px 0;
            text-align: center;
            min-width: 0;
        }

        /* Player management controls */
        .player-controls {
            margin-bottom: 20px;
        }

        .pagination-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(30, 41, 59, 0.4);
            border-radius: 10px;
            padding: 15px 20px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            flex-wrap: wrap;
            gap: 15px;
        }

        .pagination-info {
            display: flex;
            align-items: center;
            color: #e2e8f0;
            font-weight: 500;
        }

        .pagination-buttons {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .pagination-buttons button {
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .pagination-buttons button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .pagination-buttons button:disabled {
            background: #475569;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #pageInfo {
            color: #cbd5e1;
            font-weight: 500;
            min-width: 90px;
            text-align: center;
        }
        
        .pagination-right {
            display: flex;
            align-items: center;
            gap: 15px;
            justify-content: space-between;
            width: 100%;
        }
        
        .pagination-dropdown {
            flex-shrink: 0;
        }
        
        /* Scrollbar styling - only for extreme cases */
        .container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .container::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.3);
            border-radius: 4px;
        }
        
        .container::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.5);
            border-radius: 4px;
        }
        
        .container::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.7);
        }
        
        /* Ensure smooth scrolling */
        .container {
            scroll-behavior: smooth;
        }
        
        /* Remove button styling */
        .remove-button {
            background: rgba(220, 38, 38, 0.8);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.3s ease;
            position: absolute;
            top: 15px;
            left: 10px;
            z-index: 10;
            opacity: 0.6;
            font-weight: 500;
        }

        .remove-button:hover {
            background: rgba(185, 28, 28, 0.9);
            opacity: 1;
            transform: scale(1.05);
        }

        .player-card:hover .remove-button {
            opacity: 0.8;
        }
        
        /* Responsive breakpoints */
        @media (min-width: 800px) {
            /* Multiple cards side by side - maintain 320px minimum */
            .players-grid {
                grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)) !important;
            }
            
            /* Settings panel for medium screens */
            #settingsPanel .config-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)) !important;
            }
        }
        
        @media (max-width: 799px) and (min-width: 450px) {
            /* Single column layout - cards can scale down */
            .players-grid {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
            
            .game-interface {
                padding: 12px;
            }
            
            .game-header {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 12px !important;
            }
            
            .action-buttons {
                justify-content: center !important;
                padding-right: 0 !important;
            }
            
            /* Settings panel responsive */
            #settingsPanel .config-grid {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)) !important;
            }
            
            #customDistanceInputs {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)) !important;
            }
        }
        
        @media (max-width: 449px) {
            /* Very narrow screens - cards scale down significantly */
            .players-grid {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }
            
            .game-interface {
                padding: 10px;
            }
            
            .game-header {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 8px !important;
            }
            
            .action-buttons {
                display: grid !important;
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 6px !important;
                padding-right: 0 !important;
            }
            
            .action-button {
                width: 100% !important;
                text-align: center;
                padding: 8px 4px !important;
                font-size: 0.75rem !important;
            }
            
            /* Settings panel for small screens */
            #settingsPanel .config-grid {
                grid-template-columns: 1fr !important;
            }
            
            #customDistanceInputs {
                grid-template-columns: 1fr !important;
            }
            
            /* Compact game info for mobile */
            .game-info {
                margin-bottom: 10px !important;
                padding: 10px !important;
            }
            
            .current-game {
                font-size: 1.2rem !important;
                margin-bottom: 4px !important;
            }
            
            .game-status {
                font-size: 0.8rem !important;
            }
            
            /* Compact round/distance nav buttons for mobile */
            .round-nav-btn {
                padding: 5px 6px !important;
                font-size: 0.65rem !important;
                min-width: 28px !important;
                border-radius: 4px !important;
            }
            
            /* Reduce gap in nav button containers */
            .player-card div[style*="gap: 5px"] {
                gap: 3px !important;
            }
            
            /* Compact the Rounds/Distances labels */
            .player-card span[style*="font-size: 0.8rem"] {
                font-size: 0.7rem !important;
            }
        }
        
        @media (max-width: 320px) {
            /* Extremely narrow - add horizontal scrolling only as last resort */
            .container {
                min-width: 320px;
                overflow-x: auto;
            }
            
            .players-grid {
                min-width: 300px;
            }
        }
        
        /* Large screen optimizations */
        @media (min-width: 1400px) {
            .players-grid {
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)) !important;
            }
        }
        
        @media (min-width: 1800px) {
            .players-grid {
                grid-template-columns: repeat(auto-fit, minmax(380px, 1fr)) !important;
            }
        }
        
        @media (min-width: 2400px) {
            .players-grid {
                grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)) !important;
            }
        }

        /* Medium screens and smaller */
        @media (max-width: 1024px) {
            .sidebar {
                width: clamp(200px, 25vw, 250px);
            }
            
            .sidebar-toggle {
                left: clamp(200px, 25vw, 250px);
            }
            
            .game-interface {
                margin-left: clamp(200px, 25vw, 250px);
            }
        }

        /* Small screens */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
                border-right: none;
                border-bottom: 2px solid #475569;
                flex-direction: row;
                flex-wrap: nowrap;
                justify-content: center;
                align-items: flex-start;
                gap: 6px;
                padding: 8px;
                transform: none !important;
            }
            
            .sidebar.collapsed {
                transform: none !important;
            }
            
            .sidebar-toggle {
                display: none;
            }
            
            .sidebar-header {
                width: auto;
                flex-shrink: 0;
                margin-bottom: 0;
                padding-bottom: 0;
                border-bottom: none;
                padding-right: 8px;
                border-right: 1px solid rgba(71, 85, 105, 0.3);
            }
            
            .nav-button {
                flex: 1 1 0;
                min-width: 0;
                max-width: none;
                padding: 6px 4px;
                font-size: 0.65rem;
            }
            
            .game-interface {
                margin-left: 0;
                padding: 15px;
            }
            
            .game-interface.expanded {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Shared Navigation will be loaded here -->
        <div id="shared-navigation"></div>
        
        <!-- Game Interface -->
        <div id="gameInterface" class="game-interface main-content">
            <div class="game-header">
                <div class="action-buttons">
                    <button class="action-button leaderboard-btn" onclick="openLeaderboardWindow()">üèÜ Leaderboard</button>
                    <button class="action-button stats-btn" onclick="showStats()">üìä Stats</button>
                    <button class="action-button settings-btn" onclick="toggleSettings()">‚öôÔ∏è Settings</button>
                    <button class="action-button settings-btn" onclick="exportData()">üíæ Export</button>
                    <button class="action-button" id="finalizeBtn" style="background: linear-gradient(45deg, #fbbf24, #f59e0b); display: none;" onclick="gameState.waitingForUserFinalizationChoice = false; finalizeGame();">üèÅ Finalize Game</button>
                    <button class="action-button" id="resetGameBtn" style="background: linear-gradient(45deg, #ef4444, #dc2626); display: none;" onclick="showResetGameWarning()">üîÑ Reset Game</button>
                    <button class="action-button" id="trackProgressBtn" style="background: linear-gradient(45deg, #8b5cf6, #a855f7);" onclick="showTrackProgressModal()">üìà Track Progress</button>
                </div>
            </div>

            <div class="game-info">
                <div class="current-game" id="currentGameTitle">Walkback</div>
                <div class="game-status" id="gameStatus">üéØ Walkback Game ‚Ä¢ 5 Rounds ‚Ä¢ 3 Throws per Round</div>
                <div id="gameNameDisplay" style="color: #94a3b8; font-size: 1rem; margin-top: 5px; display: none;"></div>
                <div id="finalizedBanner" style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1e293b; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center; font-weight: bold; font-size: 1.1rem; display: none;">üîí GAME FINALIZED - RESULTS LOCKED üîí</div>
            </div>

            <!-- Settings Panel -->
            <div id="settingsPanel" style="background: rgba(30, 41, 59, 0.9); border: 1px solid #475569; border-radius: 15px; padding: 25px; margin-bottom: 30px; display: none;">
                <div style="font-size: 1.3rem; font-weight: bold; margin-bottom: 20px; display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span>‚öôÔ∏è</span>
                        <span>Walkback Settings</span>
                    </div>
                    <button onclick="resetSettingsToDefaultsInPanel()" style="background: #64748b; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 500; transition: all 0.3s ease;">Reset</button>
                </div>
                
                <!-- Game Started Warning -->
                <div id="gameStartedWarning" style="background: rgba(245, 101, 101, 0.1); border: 1px solid #ef4444; padding: 15px; border-radius: 10px; margin-bottom: 20px; display: none;">
                    <div style="color: #ef4444; font-weight: bold; margin-bottom: 5px;">‚ö†Ô∏è Game In Progress</div>
                    <div style="color: #fca5a5; font-size: 0.9rem;">Most settings are locked once scoring begins. Use "Reset Game" to change game configuration.</div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    <div style="display: flex; flex-direction: column;">
                        <label style="font-size: 0.9rem; font-weight: 500; margin-bottom: 8px; color: #e2e8f0;">Game Name</label>
                        <input type="text" id="gameNameInput" placeholder="Enter custom game name..." maxlength="50" style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                    </div>
                    <div style="display: flex; flex-direction: column;">
                        <label style="font-size: 0.9rem; font-weight: 500; margin-bottom: 8px; color: #e2e8f0;">Number of Rounds</label>
                        <select id="roundsSelect" onchange="updateRoundsCount()" style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                            <option value="1">1 Round</option>
                            <option value="2">2 Rounds</option>
                            <option value="3">3 Rounds</option>
                            <option value="4" selected>4 Rounds</option>
                            <option value="5">5 Rounds</option>
                            <option value="6">6 Rounds</option>
                            <option value="7">7 Rounds</option>
                            <option value="8">8 Rounds</option>
                            <option value="9">9 Rounds</option>
                            <option value="10">10 Rounds</option>
                            <option value="11">11 Rounds</option>
                            <option value="12">12 Rounds</option>
                            <option value="13">13 Rounds</option>
                            <option value="14">14 Rounds</option>
                            <option value="15">15 Rounds</option>
                            <option value="16">16 Rounds</option>
                            <option value="17">17 Rounds</option>
                            <option value="18">18 Rounds</option>
                            <option value="19">19 Rounds</option>
                            <option value="20">20 Rounds</option>
                        </select>
                    </div>
                    <div style="display: flex; flex-direction: column;">
                        <label style="font-size: 0.9rem; font-weight: 500; margin-bottom: 8px; color: #e2e8f0;">Throws per Round</label>
                        <select id="throwsPerRoundSelect" onchange="updateThrowsPerRound()" style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                            <option value="1">1 Throw</option>
                            <option value="2">2 Throws</option>
                            <option value="3" selected>3 Throws</option>
                            <option value="4">4 Throws</option>
                            <option value="5">5 Throws</option>
                            <option value="6">6 Throws</option>
                            <option value="7">7 Throws</option>
                            <option value="8">8 Throws</option>
                            <option value="9">9 Throws</option>
                            <option value="10">10 Throws</option>
                            <option value="11">11 Throws</option>
                            <option value="12">12 Throws</option>
                            <option value="13">13 Throws</option>
                            <option value="14">14 Throws</option>
                            <option value="15">15 Throws</option>
                            <option value="16">16 Throws</option>
                            <option value="17">17 Throws</option>
                            <option value="18">18 Throws</option>
                            <option value="19">19 Throws</option>
                            <option value="20">20 Throws</option>
                        </select>
                    </div>
                    <div style="display: flex; flex-direction: column;">
                        <label style="font-size: 0.9rem; font-weight: 500; margin-bottom: 8px; color: #e2e8f0;">Number of Distances</label>
                        <select id="numDistancesSelect" onchange="updateNumDistances()" style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                            <option value="1">1 Distance</option>
                            <option value="2">2 Distances</option>
                            <option value="3">3 Distances</option>
                            <option value="4">4 Distances</option>
                            <option value="5" selected>5 Distances</option>
                            <option value="6">6 Distances</option>
                            <option value="7">7 Distances</option>
                            <option value="8">8 Distances</option>
                            <option value="9">9 Distances</option>
                            <option value="10">10 Distances</option>
                            <option value="11">11 Distances</option>
                            <option value="12">12 Distances</option>
                            <option value="13">13 Distances</option>
                            <option value="14">14 Distances</option>
                            <option value="15">15 Distances</option>
                            <option value="16">16 Distances</option>
                            <option value="17">17 Distances</option>
                            <option value="18">18 Distances</option>
                            <option value="19">19 Distances</option>
                            <option value="20">20 Distances</option>
                        </select>
                    </div>
                    <div style="display: flex; flex-direction: column;">
                        <label style="font-size: 0.9rem; font-weight: 500; margin-bottom: 8px; color: #e2e8f0;">Max Points per Throw</label>
                        <select id="maxScoreSelect" onchange="updateMaxScore()" style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                            <option value="1">1 Point</option>
                            <option value="2">2 Points</option>
                            <option value="3">3 Points</option>
                            <option value="4">4 Points</option>
                            <option value="5" selected>5 Points</option>
                            <option value="6">6 Points</option>
                            <option value="7">7 Points</option>
                            <option value="8">8 Points</option>
                            <option value="9">9 Points</option>
                            <option value="10">10 Points</option>
                            <option value="11">11 Points</option>
                            <option value="12">12 Points</option>
                            <option value="13">13 Points</option>
                            <option value="14">14 Points</option>
                            <option value="15">15 Points</option>
                            <option value="16">16 Points</option>
                            <option value="17">17 Points</option>
                            <option value="18">18 Points</option>
                            <option value="19">19 Points</option>
                            <option value="20">20 Points</option>
                        </select>
                    </div>
                    <div style="display: flex; flex-direction: column;">
                        <label style="font-size: 0.9rem; font-weight: 500; margin-bottom: 8px; color: #e2e8f0; display: flex; align-items: center; gap: 8px;">
                            <span>Play Mode</span>
                            <span style="display: flex; align-items: center; gap: 4px;">
                                <input type="checkbox" id="distancesOnTopCheckbox" onchange="updateDistancesOnTop()" style="width: 14px; height: 14px; cursor: pointer;">
                                <span>üîÑ</span>
                            </span>
                        </label>
                        <select id="playModeSelect" onchange="updatePlayMode()" style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                            <option value="sequential">Sequential Distance (2m‚Üí3m‚Üí4m‚Üí5m‚Üí6m, repeat)</option>
                            <option value="consecutive">Consecutive Rounds (all rounds at 2m, then all at 3m, etc.)</option>
                        </select>
                    </div>
                    <div style="display: flex; flex-direction: column;">
                        <label style="font-size: 0.9rem; font-weight: 500; margin-bottom: 8px; color: #e2e8f0;">Distance Preset</label>
                        <select id="distancePresetSelect" onchange="updateDistancePreset()" style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                            <option value="amateur">Amateur (2m, 3m, 4m, 5m, 6m...)</option>
                            <option value="professional">Professional (3m, 4m, 5m, 6m, 7m...)</option>
                            <option value="custom">Custom (Set your own)</option>
                            <option value="" disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Custom Presets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
                        </select>
                    </div>
                    <div style="display: flex; flex-direction: column;">
                        <label style="font-size: 0.9rem; font-weight: 500; margin-bottom: 8px; color: #e2e8f0;">Tiebreaker Mode</label>
                        <select id="tiebreakerSelect" style="background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                            <option value="sudden-death-podium-match">Sudden Death Podium Round (1st, 2nd, 3rd - 3 throws each)</option>
                            <option value="sudden-death-podium">Sudden Death Podium (1st, 2nd, 3rd)</option>
                            <option value="sudden-death">Sudden Death (1 throw each)</option>
                            <option value="sudden-death-round">Sudden Death Round (3 throws each)</option>
                            <option value="no-tiebreaker">No Tiebreaker (Allow ties)</option>
                        </select>
                    </div>
                    <div style="display: flex; flex-direction: column;">
                        <label style="font-size: 0.9rem; font-weight: 500; margin-bottom: 8px; color: #e2e8f0;">Save Current Settings</label>
                        <div style="display: flex; flex-direction: row; gap: 8px; align-items: center; flex-wrap: nowrap;">
                            <button id="savePresetBtn" onclick="saveGamePreset()" style="background: #059669; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 500; transition: all 0.3s ease; min-width: 120px;">üíæ Save as Preset</button>
                            <button onclick="removeSelectedPreset()" style="background: #ef4444; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 500; transition: all 0.3s ease; min-width: 120px;">üóëÔ∏è Remove Preset</button>
                        </div>
                    </div>

                </div>
                
                <!-- Custom Distance Configuration -->
                <div id="customDistanceGroup" style="background: rgba(15, 23, 42, 0.5); border: 1px solid #475569; border-radius: 10px; padding: 20px; margin-bottom: 20px; display: none;">
                    <h4 style="margin-bottom: 15px; color: #e2e8f0; display: flex; align-items: center; gap: 10px;">
                        <span>üìè</span>
                        <span>Custom Distance Configuration</span>
                    </h4>
                    <div id="customDistanceInputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 15px;">
                        <!-- Distance inputs will be generated dynamically -->
                    </div>
                </div>
                
                <div style="display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 20px; align-items: center;">
                    <button id="applySettingsBtn" onclick="applySettings()" style="background: #10b981; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease;">Apply Changes</button>
                    <button onclick="clearScores()" style="background: #f59e0b; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease;">Clear Scores</button>
                    <button onclick="clearPlayers()" style="background: #ef4444; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: all 0.3s ease;">Clear Players</button>
                </div>
                
                <!-- Tournament Status Management -->
                <div id="tournamentStatusSection" style="background: rgba(59, 130, 246, 0.1); border: 1px solid #3b82f6; border-radius: 10px; padding: 20px; margin-bottom: 20px; display: none;">
                    <h4 style="margin-bottom: 15px; color: #3b82f6; display: flex; align-items: center; gap: 10px;">
                        <span>üèÜ</span>
                        <span>Tournament Status Management</span>
                    </h4>
                    <div style="color: #cbd5e1; font-size: 0.9rem; margin-bottom: 15px;">
                        This game is linked to a tournament event. Manage the event status in the tournament management system.
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="checkTournamentEventStatus()" style="background: #3b82f6; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.3s ease;">üìä Check Event Status</button>
                        <button onclick="updateTournamentEventStatus()" style="background: #10b981; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.3s ease;">‚úÖ Mark as Completed</button>
                        <button onclick="revertTournamentEventStatus()" style="background: #f59e0b; border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.3s ease;">üîÑ Revert to In-Progress</button>
                    </div>
                </div>
            </div>

            <!-- Track Progress Modal -->
            <div id="trackProgressModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10000; display: none; justify-content: center; align-items: center;">
                <div style="background: linear-gradient(135deg, #1e293b 0%, #334155 100%); border: 2px solid #8b5cf6; border-radius: 20px; padding: 30px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);">
                    <div style="font-size: 1.5rem; font-weight: bold; margin-bottom: 20px; color: #e2e8f0; display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <span>üìà</span>
                        <span>Track Progress Setup</span>
                    </div>
                    
                    <div style="color: #cbd5e1; font-size: 1rem; margin-bottom: 25px; line-height: 1.5;">
                        <p><strong>Track Progress</strong> provides real-time tournament management with group organization and status tracking.</p>
                        <p style="margin-top: 15px; color: #94a3b8;"><strong>Features:</strong> Groups players by lane size ‚Ä¢ Shows THROWING/ON DECK/WAITING status ‚Ä¢ Real-time progress statistics</p>
                        <p style="margin-top: 10px; color: #94a3b8; font-size: 0.9rem;">Example: 8 lanes = groups of 8 players each</p>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <label style="font-size: 1rem; font-weight: 600; margin-bottom: 10px; color: #e2e8f0; display: block;">Number of Lanes (1-99):</label>
                        <input type="number" id="numLanesSelect" min="1" max="99" value="4" style="background: #475569; border: 1px solid #64748b; color: white; padding: 12px; border-radius: 8px; font-size: 1rem; outline: none; width: 100%; max-width: 200px; text-align: center;" 
                               oninput="this.value = this.value.replace(/[^0-9]/g, ''); if(this.value > 99) this.value = 99; if(this.value < 1 && this.value !== '') this.value = 1;" 
                               onblur="if(this.value === '' || this.value < 1) this.value = 4;" placeholder="4">
                    </div>
                    
                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="confirmTrackProgressSetup()" style="background: linear-gradient(45deg, #8b5cf6, #a855f7); border: none; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 600; transition: all 0.3s ease;">‚úÖ Enable Track Progress</button>
                        <button onclick="closeTrackProgressModal()" style="background: #64748b; border: none; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 500; transition: all 0.3s ease;">‚ùå Cancel</button>
                    </div>
                </div>
            </div>

            <!-- Player Management Controls -->
            <div class="player-controls">
                <div class="pagination-controls" id="paginationControls" style="display: none;">
                    <div class="pagination-info">
                        <span id="playerCount">0 players</span>
                    </div>
                    <div class="pagination-right">
                        <div class="pagination-dropdown">
                            <select id="playersPerPage" onchange="changePlayersPerPage()" style="padding: 5px; background: rgba(30, 41, 59, 0.8); color: white; border: 1px solid #475569; border-radius: 5px;">
                                <option value="20" selected>20 per page</option>
                                <option value="30">30 per page</option>
                                <option value="50">50 per page</option>
                                <option value="100">100 per page</option>
                                <option value="all">Show All</option>
                            </select>
                        </div>
                        <div class="pagination-buttons">
                            <button id="prevPageBtn" onclick="changePage(-1)" disabled>‚Üê Previous</button>
                            <span id="pageInfo">Page 1 of 1</span>
                            <button id="nextPageBtn" onclick="changePage(1)" disabled>Next ‚Üí</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="players-grid" id="playersGrid">
                <!-- Players will be added here dynamically -->
            </div>

            <!-- Bottom Pagination Controls -->
            <div class="pagination-controls" id="bottomPaginationControls" style="display: none; margin-top: 20px;">
                <div class="pagination-info">
                    <span id="bottomPlayerCount">0 players</span>
                </div>
                <div class="pagination-right">
                    <div class="pagination-dropdown">
                        <select id="bottomPlayersPerPage" onchange="changePlayersPerPage()" style="padding: 5px; background: rgba(30, 41, 59, 0.8); color: white; border: 1px solid #475569; border-radius: 5px;">
                            <option value="20" selected>20 per page</option>
                            <option value="30">30 per page</option>
                            <option value="50">50 per page</option>
                            <option value="100">100 per page</option>
                            <option value="all">Show All</option>
                        </select>
                    </div>
                    <div class="pagination-buttons">
                        <button id="bottomPrevPageBtn" onclick="changePage(-1)" disabled>‚Üê Previous</button>
                        <span id="bottomPageInfo">Page 1 of 1</span>
                        <button id="bottomNextPageBtn" onclick="changePage(1)" disabled>Next ‚Üí</button>
                    </div>
                </div>
            </div>

            <div class="add-player">
                <button class="add-player-btn" onclick="addPlayer()" id="addPlayerBtn">üë• Add Player</button>
            </div>
        </div>

        <!-- Floating Leaderboard Window REMOVED - Now using separate popup window -->
        

    </div>

    <script src="shared-functions.js"></script>
    <script src="shared-menu-handlers.js"></script>
    <script>
        // Walkback-specific game state
        var gameState = {
            type: 'Walkback',
            rounds: 4,
            throwsPerRound: 3,
            maxScore: 5,
            targetRings: [5, 4, 3, 2, 1, 0], // Will be dynamically generated based on maxScore
            distances: ['2 Meters', '3 Meters', '4 Meters', '5 Meters', '6 Meters'],
            distancePreset: 'amateur',
            numDistances: 5,
            playMode: 'consecutive', // 'sequential' or 'consecutive'
            distancesOnTop: false, // Sequential mode: checked by default, Consecutive: unchecked by default
            isWalkback: true,
            isGolf: false,
            players: [],
            editingThrow: null,
            currentRound: 1,
            currentDistance: 1,
            currentThrow: 1,
            viewingRound: 1,
            viewingDistance: 1,
            gameFinalized: false,
            gameName: '',
            tiebreakerMode: 'sudden-death-podium-match',
            podiumTiebreakers: null,
            playersImported: false, // Track if players were imported from management
            eventSetToInProgress: false, // Track if event status has been set to in-progress
            trackProgress: true, // Track progress feature always enabled
            numLanes: 4, // Number of lanes for progress tracking
                                // Pagination settings
                    currentPage: 1,
                    playersPerPage: 20,
                    totalPages: 1
        };



        // Global variables
        var playerId = 1;
        var leaderboardVisible = false;
        var leaderboardWindow = null; // Reference to the separate window
        var victoryWindow = null; // Reference to the victory window
        var leaderboardDragging = false;
        var leaderboardOffset = { x: 0, y: 0 };
        var settingsVisible = false;
        var gameFinalizedOnce = false;
        var trackProgressWindow = null; // Reference to the track progress window

        // Helper functions for event type display
        function getEventIcon(eventType) {
            switch(eventType) {
                case 'knife': return 'üîÑ';
                case 'tomahawk': return 'üîÑ';
                case 'quickdraw': return '‚ö°';
                case 'golf': return '‚õ≥';
                case 'custom': return 'üéØ';
                case 'sidegame': return 'üéØ';
                default: return 'üéØ';
            }
        }

        function getEventTypeLabel(eventType) {
            switch(eventType) {
                case 'knife': return 'Knife Walkback';
                case 'tomahawk': return 'Tomahawk Walkback';
                case 'quickdraw': return 'Quick Draw';
                case 'sidegame': return 'Side Game';
                default: return 'Event';
            }
        }

        // SEPARATE WINDOW LEADERBOARD FUNCTIONS
        function openLeaderboardWindow() {
            // Check if window is already open and focused
            if (leaderboardWindow && !leaderboardWindow.closed) {
                leaderboardWindow.focus();
                // Don't update if in tiebreaker - show frozen standings instead
                if (gameState.inTiebreaker) {
                    showFrozenLeaderboard();
                } else {
                    updateLeaderboardWindow();
                }
                return;
            }

            // Determine window position for multi-monitor setup
            var windowFeatures = 'width=1200,height=800,scrollbars=no,resizable=yes,location=no,menubar=no,toolbar=no';
            
            // Get optimal window position for multi-monitor setup
            var position = getMultiMonitorWindowPosition();
            windowFeatures += ',left=' + position.left + ',top=' + position.top;
            
            // Log multi-monitor detection for debugging
            if (position.multiMonitor) {
                console.log('üéØ Multi-monitor detected! Opening leaderboard on second monitor at position:', position);
            } else {
                console.log('üñ•Ô∏è Single monitor detected. Opening leaderboard at default position:', position);
            }
            
            // Manual override for 3-monitor setups (uncomment the line below if automatic detection fails)
            // windowFeatures = 'width=1200,height=800,left=1920,top=50,scrollbars=no,resizable=yes,location=no,menubar=no,toolbar=no';
            
            leaderboardWindow = window.open('', 'leaderboard', windowFeatures);
            
            if (!leaderboardWindow) {
                alert('Pop-up blocked! Please allow pop-ups for this site to use the leaderboard window.');
                return;
            }

            // Set up the window content
            leaderboardWindow.document.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>üèÜ ${gameState.gameName || 'Walkback Championship'} - Live Leaderboard</title>
                    <style>
                        body {
                            margin: 0;
                            padding: 0;
                            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
                            height: 100vh;
                            width: 100vw;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            overflow: hidden;
                        }
                        .leaderboard-container {
                            background: rgba(30, 41, 59, 0.95);
                            border: none;
                            padding: 0;
                            box-shadow: none;
                            backdrop-filter: blur(10px);
                            width: 100%;
                            height: 100vh;
                            margin: 0;
                            display: flex;
                            flex-direction: column;
                            overflow: hidden;
                        }
                        .leaderboard-header {
                            background: linear-gradient(45deg, #f59e0b, #d97706);
                            color: white;
                            padding: 2vh 2vw;
                            border-radius: 0;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            border-bottom: 0.2vh solid #fbbf24;
                            flex-shrink: 0;
                            min-height: 8vh;
                        }
                        .leaderboard-title {
                            display: flex;
                            align-items: center;
                            gap: 1.5vw;
                        }
                        .leaderboard-title span {
                            font-size: clamp(2rem, 4vw, 2.8rem);
                        }
                        .leaderboard-title div {
                            font-size: clamp(1.4rem, 2.8vw, 2.1rem);
                            font-weight: bold;
                            text-shadow: 0.2vh 0.2vh 0.4vh rgba(0,0,0,0.3);
                        }
                        #leaderboardGameName {
                            font-size: clamp(1.8rem, 4.5vw, 3.2rem);
                            font-weight: 900;
                            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                            line-height: 1.1;
                        }
                        #leaderboardSubtitle {
                            font-size: clamp(1rem, 2.4vw, 1.6rem);
                            color: rgba(255,255,255,0.8);
                            font-weight: 500;
                            margin-top: 0.2vh;
                        }
                        .leaderboard-status {
                            font-size: clamp(0.6rem, 1.4vw, 1rem);
                            color: #fbbf24;
                            font-weight: 600;
                            margin-top: 0.3vh;
                            text-shadow: 0.1vh 0.1vh 0.2vh rgba(0,0,0,0.3);
                            opacity: 0;
                            transition: opacity 0.3s ease;
                        }
                        .leaderboard-status.show {
                            opacity: 1;
                        }

                        .leaderboard-content {
                            padding: 2vh 2vw;
                            flex: 1;
                            color: #e2e8f0;
                            display: grid;
                            gap: 1.5vh 3vw;
                            align-items: start;
                            overflow-y: auto;
                            max-height: calc(100vh - 8vh);
                        }
                        
                        /* Two-column layout for 11+ players */
                        .leaderboard-content.two-column {
                            grid-template-columns: 1fr 1fr;
                            grid-template-rows: repeat(10, auto);
                            grid-auto-flow: column;
                        }
                        
                        /* Single column layout for 10 or fewer players */
                        .leaderboard-content.single-column {
                            grid-template-columns: 1fr;
                            grid-template-rows: none;
                            gap: 0.5vh;
                        }
                        
                        /* Dynamic sizing based on player count */
                        .leaderboard-content.single-column.few-players-1-2 {
                            gap: 2vh;
                        }
                        .leaderboard-content.single-column.few-players-3-4 {
                            gap: 1.5vh;
                        }
                        .leaderboard-content.single-column.few-players-5-6 {
                            gap: 1vh;
                        }
                        .leaderboard-content.single-column.few-players-7-8 {
                            gap: 0.8vh;
                        }
                        .leaderboard-content.single-column.few-players-9-10 {
                            gap: 0.6vh;
                        }
                        
                        .leaderboard-item {
                            background: rgba(51, 65, 85, 0.8);
                            border: 0.2vh solid rgba(255, 255, 255, 0.1);
                            border-radius: 1.5vh;
                            padding: 1.5vh 1.5vw;
                            display: flex;
                            align-items: center;
                            transition: all 0.3s ease;
                            width: 96%;
                            max-width: none;
                            min-height: 6vh;
                        }
                        
                        /* Bigger tiles for fewer players */
                        .leaderboard-content.single-column.few-players-1-2 .leaderboard-item {
                            min-height: 12vh;
                            padding: 2.5vh 2vw;
                        }
                        .leaderboard-content.single-column.few-players-3-4 .leaderboard-item {
                            min-height: 10vh;
                            padding: 2vh 1.8vw;
                        }
                        .leaderboard-content.single-column.few-players-5-6 .leaderboard-item {
                            min-height: 8vh;
                            padding: 1.8vh 1.6vw;
                        }
                        .leaderboard-content.single-column.few-players-7-8 .leaderboard-item {
                            min-height: 7vh;
                            padding: 1.6vh 1.5vw;
                        }
                        .leaderboard-content.single-column.few-players-9-10 .leaderboard-item {
                            min-height: 6.5vh;
                            padding: 1.5vh 1.5vw;
                        }
                        .leaderboard-item:hover {
                            transform: translateY(-0.2vh);
                            box-shadow: 0 0.8vh 2.5vh rgba(0, 0, 0, 0.3);
                        }
                        .rank-1 { border-color: #ffd700; }
                        .rank-2 { border-color: #c0c0c0; }
                        .rank-3 { border-color: #cd7f32; }
                        .no-players {
                            text-align: center;
                            color: #94a3b8;
                            font-size: clamp(1rem, 2vw, 1.2rem);
                            padding: 4vh 2vw;
                            width: 100%;
                            flex: 1;
                            display: flex;
                            flex-direction: column;
                            justify-content: center;
                        }
                        .leaderboard-trophy {
                            font-size: clamp(1.6rem, 3.2vw, 2.2rem);
                            margin-right: 1.2vw;
                            width: 2.5vw;
                            min-width: 40px;
                            text-align: center;
                        }
                        .leaderboard-rank {
                            font-size: clamp(1.1rem, 2.4vw, 1.6rem);
                            font-weight: bold;
                            width: 2vw;
                            min-width: 35px;
                            text-align: center;
                            margin-right: 1.2vw;
                        }
                        .leaderboard-info {
                            flex: 1;
                            min-width: 0;
                        }
                        .leaderboard-name {
                            font-size: clamp(1.2rem, 2.6vw, 1.6rem);
                            font-weight: bold;
                            color: white;
                            margin-bottom: 0.5vh;
                        }
                        .leaderboard-stats {
                            display: flex;
                            flex-wrap: wrap;
                            gap: 1vw;
                            font-size: clamp(0.7rem, 1.4vw, 1rem);
                            color: #e2e8f0;
                            align-items: center;
                        }
                        .leaderboard-stat {
                            white-space: nowrap;
                            display: flex;
                            align-items: center;
                            gap: 0.5vw;
                        }
                        .leaderboard-stat-value {
                            font-weight: bold;
                            color: white;
                        }
                        .leaderboard-score {
                            font-size: clamp(1.8rem, 3.8vw, 2.8rem);
                            font-weight: bold;
                            color: white;
                            text-align: center;
                            min-width: 6vw;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: center;
                            text-shadow: 0.2vh 0.2vh 0.4vh rgba(0,0,0,0.5);
                        }
                        .rank-1 .leaderboard-score {
                            color: #ffd700;
                            font-size: clamp(2rem, 4.2vw, 3rem);
                        }
                        .rank-2 .leaderboard-score {
                            color: #c0c0c0;
                            font-size: clamp(1.9rem, 4vw, 2.9rem);
                        }
                        .rank-3 .leaderboard-score {
                            color: #cd7f32;
                            font-size: clamp(1.85rem, 3.9vw, 2.85rem);
                        }
                        .leaderboard-score-label {
                            font-size: clamp(0.5rem, 0.9vw, 0.7rem);
                            color: rgba(255,255,255,0.8);
                            font-weight: normal;
                            margin-top: 0.3vh;
                            text-shadow: 0.1vh 0.1vh 0.2vh rgba(0,0,0,0.5);
                        }
                        .leaderboard-score-breakdown {
                            font-size: clamp(0.7rem, 1.3vw, 0.9rem);
                            color: #ef4444;
                            margin-top: 0.2vh;
                        }
                        @media (max-width: 768px) {
                            .leaderboard-header {
                                padding: 1.5vh 3vw;
                                flex-direction: column;
                                gap: 1vh;
                                min-height: 12vh;
                            }
                            .leaderboard-title {
                                gap: 3vw;
                            }
                            #leaderboardGameName {
                                font-size: clamp(1.5rem, 5vw, 2.8rem);
                            }
                            #leaderboardSubtitle {
                                font-size: clamp(0.9rem, 2.8vw, 1.4rem);
                            }
                            .leaderboard-status {
                                font-size: clamp(0.5rem, 1.8vw, 0.9rem);
                            }
                            .leaderboard-item {
                                padding: 2vh 3vw;
                                flex-direction: column;
                                text-align: center;
                                gap: 1vh;
                            }
                            .leaderboard-stats {
                                justify-content: center;
                                gap: 2vw;
                            }
                            .leaderboard-score {
                                min-width: auto;
                                margin-top: 1vh;
                            }
                        }
                        
                        /* Large screen optimizations for two-column layout */
                        @media (min-height: 900px) {
                            .leaderboard-content.two-column {
                                gap: 1.2vh 2.5vw;
                                grid-template-rows: repeat(10, auto);
                                grid-auto-flow: column;
                            }
                            .leaderboard-content.single-column {
                                gap: 0.6vh;
                            }
                            .leaderboard-item {
                                min-height: 5vh;
                                padding: 1.2vh 1.5vw;
                            }
                            
                            /* Adjust larger tiles for big screens */
                            .leaderboard-content.single-column.few-players-1-2 .leaderboard-item {
                                min-height: 10vh;
                                padding: 2vh 1.8vw;
                            }
                            .leaderboard-content.single-column.few-players-3-4 .leaderboard-item {
                                min-height: 8vh;
                                padding: 1.8vh 1.6vw;
                            }
                            .leaderboard-content.single-column.few-players-5-6 .leaderboard-item {
                                min-height: 6.5vh;
                                padding: 1.6vh 1.4vw;
                            }
                        }
                        
                        @media (min-height: 1200px) {
                            .leaderboard-content.two-column {
                                gap: 1vh 2vw;
                                grid-template-rows: repeat(10, auto);
                                grid-auto-flow: column;
                            }
                            .leaderboard-content.single-column {
                                gap: 0.5vh;
                            }
                            .leaderboard-item {
                                min-height: 4.5vh;
                                padding: 1vh 1.5vw;
                            }
                            
                            /* Adjust larger tiles for very big screens */
                            .leaderboard-content.single-column.few-players-1-2 .leaderboard-item {
                                min-height: 8vh;
                                padding: 1.8vh 1.6vw;
                            }
                            .leaderboard-content.single-column.few-players-3-4 .leaderboard-item {
                                min-height: 6.5vh;
                                padding: 1.6vh 1.4vw;
                            }
                            .leaderboard-content.single-column.few-players-5-6 .leaderboard-item {
                                min-height: 5.5vh;
                                padding: 1.4vh 1.3vw;
                            }
                        }
                        
                        /* Ultra-wide screen optimization for 20+ players in two columns */
                        @media (min-height: 1000px) and (min-width: 1400px) {
                            .leaderboard-content.two-column {
                                gap: 0.8vh 1.5vw;
                                padding: 1.5vh 2vw;
                                grid-template-rows: repeat(10, auto);
                                grid-auto-flow: column;
                            }
                            .leaderboard-content.single-column {
                                gap: 0.4vh;
                                padding: 1.5vh 2vw;
                            }
                            .leaderboard-item {
                                min-height: 3.8vh;
                                padding: 0.8vh 1.5vw;
                            }
                            
                            /* Adjust larger tiles for ultra-wide screens */
                            .leaderboard-content.single-column.few-players-1-2 .leaderboard-item {
                                min-height: 7vh;
                                padding: 1.6vh 1.4vw;
                            }
                            .leaderboard-content.single-column.few-players-3-4 .leaderboard-item {
                                min-height: 5.5vh;
                                padding: 1.4vh 1.3vw;
                            }
                            .leaderboard-content.single-column.few-players-5-6 .leaderboard-item {
                                min-height: 4.5vh;
                                padding: 1.2vh 1.2vw;
                            }
                            
                            .leaderboard-name {
                                font-size: clamp(1.1rem, 2.4vw, 1.5rem);
                                margin-bottom: 0.3vh;
                            }
                            .leaderboard-stats {
                                gap: 0.8vw;
                            }
                            .leaderboard-stat {
                                font-size: clamp(0.9rem, 1.8vw, 1.2rem);
                            }
                            .leaderboard-score {
                                font-size: clamp(1.6rem, 3.2vw, 2.4rem);
                            }
                        }
                        
                        /* Mobile responsive - always single column for small screens */
                        @media (max-width: 768px) {
                            .leaderboard-content {
                                grid-template-columns: 1fr !important;
                                grid-template-rows: none !important;
                                gap: 1vh;
                                justify-items: center;
                            }
                            
                            /* Adjust larger tiles for mobile */
                            .leaderboard-content.single-column.few-players-1-2 .leaderboard-item {
                                min-height: 10vh;
                                padding: 2vh 3vw;
                            }
                            .leaderboard-content.single-column.few-players-3-4 .leaderboard-item {
                                min-height: 8vh;
                                padding: 1.8vh 2.5vw;
                            }
                            .leaderboard-content.single-column.few-players-5-6 .leaderboard-item {
                                min-height: 6.5vh;
                                padding: 1.6vh 2vw;
                            }
                        }
                    </style>
                </head>
                <body>
                    <div class="leaderboard-container">
                        <div class="leaderboard-header">
                            <div class="leaderboard-title">
                                <span>üèÜ</span>
                                <div>
                                    <div id="leaderboardGameName">${gameState.gameName || 'Walkback Championship'}</div>
                                    <div id="leaderboardSubtitle">Live Leaderboard</div>
                                    <div id="leaderboardStatus" class="leaderboard-status"></div>
                                </div>
                            </div>

                        </div>
                        <div class="leaderboard-content" id="leaderboardContent">
                            <!-- Leaderboard items will be populated here -->
                        </div>
                    </div>
                </body>

                </html>
            `);

            leaderboardWindow.document.close();
            
            // Update the leaderboard content (check tiebreaker status first)
            if (gameState.inTiebreaker) {
                showFrozenLeaderboard();
            } else {
                updateLeaderboardWindow();
            }
            
            // Show frozen standings if tiebreaker is in progress
            if (gameState.inTiebreaker) {
                showFrozenLeaderboard();
            }
            
            // Mark that leaderboard window is open in localStorage
            localStorage.setItem('walkbackLeaderboardOpen', 'true');
            
            // Handle window close
            leaderboardWindow.addEventListener('beforeunload', function() {
                leaderboardWindow = null;
                localStorage.removeItem('walkbackLeaderboardOpen');
            });
        }

        // TRACK PROGRESS FUNCTIONS
        function showTrackProgressModal() {
            if (gameState.players.length === 0) {
                alert('Please add players before enabling Track Progress.');
                return;
            }
            
            document.getElementById('trackProgressModal').style.display = 'flex';
            document.getElementById('numLanesSelect').value = gameState.numLanes || 4;
        }
        
        function closeTrackProgressModal() {
            document.getElementById('trackProgressModal').style.display = 'none';
        }
        
        function confirmTrackProgressSetup() {
            var numLanes = parseInt(document.getElementById('numLanesSelect').value);
            
            // Validate input
            if (isNaN(numLanes) || numLanes < 1 || numLanes > 99) {
                alert('Please enter a valid number of lanes (1-99).');
                return;
            }
            
            gameState.numLanes = numLanes;
            gameState.trackProgress = true;
            
            closeTrackProgressModal();
            saveGameState();
            
            // Track progress enabled silently
            
            // Open the track progress window to show the lane groups
            openTrackProgressWindow();
        }
        
        function toggleTrackProgress() {
            // This function is no longer needed since we removed the checkbox
            // Track Progress is now always available via the button
        }
        
        function openTrackProgressWindow() {
            // Simple implementation - just show a basic window
            var windowFeatures = 'width=1200,height=800,scrollbars=yes,resizable=yes,location=no,menubar=no,toolbar=no';
            trackProgressWindow = window.open('', 'trackProgress', windowFeatures);
            
            if (!trackProgressWindow) {
                alert('Pop-up blocked! Please allow pop-ups for this site to use the Track Progress window.');
                return;
            }

            // Dark theme HTML content to match Leaderboard
            var htmlContent = '<!DOCTYPE html><html><head><title>üìà Track Progress</title>';
            htmlContent += '<style>';
            htmlContent += 'body{margin:0;padding:20px;background:linear-gradient(135deg,#0f172a 0%,#1e293b 50%,#334155 100%);';
            htmlContent += 'min-height:100vh;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;color:#e2e8f0}';
            htmlContent += '.lane{background:rgba(51,65,85,0.8);border:2px solid rgba(255,255,255,0.1);border-radius:15px;padding:20px;margin-bottom:20px;';
            htmlContent += 'transition:all 0.3s ease;backdrop-filter:blur(10px)}';
            htmlContent += '.lane:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(0,0,0,0.3)}';
            htmlContent += '.player{background:rgba(30,41,59,0.6);border:1px solid rgba(255,255,255,0.1);border-radius:8px;padding:12px;margin:8px 0;';
            htmlContent += 'transition:all 0.3s ease;color:#e2e8f0}';
            htmlContent += '.player:hover{background:rgba(30,41,59,0.8);transform:translateX(5px)}';
            htmlContent += '.players-container{display:flex;flex-direction:column}';
            htmlContent += '.players-container.two-columns{display:grid;grid-template-columns:1fr 1fr;gap:15px}';
            htmlContent += '.player-column{display:flex;flex-direction:column}';
            htmlContent += '.lane h2{color:#e2e8f0;margin:0 0 15px 0;font-size:1.3em}';
            htmlContent += '.lane h2:hover{background:rgba(139,92,246,0.2);padding:10px;border-radius:8px;margin:-10px -10px 15px -10px}';
            htmlContent += '</style></head><body>';
            htmlContent += '<div id="content"></div></body></html>';
            trackProgressWindow.document.write(htmlContent);
            
            // Mark that track progress window is open in localStorage
            localStorage.setItem('walkbackTrackProgressOpen', 'true');
            
            // Wait for window to load, then populate content
            trackProgressWindow.document.close(); // Close the document to finish writing
            
            // Handle window close
            trackProgressWindow.addEventListener('beforeunload', function() {
                trackProgressWindow = null;
                localStorage.removeItem('walkbackTrackProgressOpen');
            });
            
            // Multiple attempts to populate content to handle timing issues
            setTimeout(function() {
                updateTrackProgressWindow();
            }, 100);
            
            trackProgressWindow.onload = function() {
                setTimeout(updateTrackProgressWindow, 50);
            };
        }
        
        function closeTrackProgressWindow() {
            // This function is no longer needed since we're using a separate window
            // The window closes itself when the user clicks the close button
        }
        
        function createPlayerDiv(player, lane, throwingGroup, onDeckGroup) {
            var playerDiv = trackProgressWindow.document.createElement('div');
            playerDiv.className = 'player';
            
            var playerStatusIcon = '';
            var playerStatusText = '';
            var playerBgColor = '';
            
            if (player.gameComplete) {
                playerStatusIcon = '‚úÖ';
                playerStatusText = ' (Complete)';
                playerBgColor = 'rgba(30, 41, 59, 0.8)';
            } else if (lane.laneNumber === throwingGroup) {
                playerStatusIcon = 'üéØ';
                playerStatusText = ' (Throwing)';
                playerBgColor = 'rgba(30, 41, 59, 0.8)';
            } else if (lane.laneNumber === onDeckGroup) {
                playerStatusIcon = 'üïê';
                playerStatusText = ' (On Deck)';
                playerBgColor = 'rgba(30, 41, 59, 0.8)';
            } else {
                playerStatusIcon = '‚è∏Ô∏è';
                playerStatusText = ' (Waiting)';
                playerBgColor = 'rgba(30, 41, 59, 0.8)';
            }
            
            playerDiv.innerHTML = '<strong>' + player.name + '</strong> - Score: ' + (player.total || 0) + 
                                 ' ' + playerStatusIcon + playerStatusText;
            
            playerDiv.style.background = playerBgColor;
            if (player.gameComplete) {
                playerDiv.style.borderColor = '#22c55e';
            } else if (lane.laneNumber === throwingGroup) {
                playerDiv.style.borderColor = '#ef4444';
            } else if (lane.laneNumber === onDeckGroup) {
                playerDiv.style.borderColor = '#f59e0b';
            } else {
                playerDiv.style.borderColor = 'rgba(255, 255, 255, 0.1)';
            }
            
            return playerDiv;
        }

        function updateTrackProgressWindow() {
            if (!trackProgressWindow || trackProgressWindow.closed) {
                console.log('Track Progress window not available');
                return;
            }

            var content = trackProgressWindow.document.getElementById('content');
            if (!content) {
                console.log('Content element not found, retrying in 100ms...');
                setTimeout(updateTrackProgressWindow, 100);
                return;
            }
            
            content.innerHTML = '';
            
            // Check if we have players
            if (!gameState.players || gameState.players.length === 0) {
                content.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No players added yet. Add players to see groups.</div>';
                return;
            }
            
            // Calculate overall progress statistics
            var totalPlayers = gameState.players.length;
            var completedPlayers = gameState.players.filter(function(p) { return p.gameComplete; }).length;
            var inProgressPlayers = totalPlayers - completedPlayers;
            var completionPercentage = totalPlayers > 0 ? Math.round((completedPlayers / totalPlayers) * 100) : 0;
            
            // Create progress stats section with dark theme
            var statsDiv = trackProgressWindow.document.createElement('div');
            statsDiv.style.cssText = 'background: linear-gradient(45deg, #8b5cf6, #7c3aed); color: white; padding: 20px; border-radius: 15px; margin-bottom: 20px; box-shadow: 0 8px 25px rgba(0,0,0,0.3); border-bottom: 3px solid #a855f7;';
            
            var statsTitle = trackProgressWindow.document.createElement('h3');
            statsTitle.style.cssText = 'margin: 0 0 15px 0; font-size: 1.2em; text-align: center;';
            statsTitle.innerHTML = 'üìä ' + (gameState.gameName || 'Walkback Championship') + ' - Progress Statistics';
            statsDiv.appendChild(statsTitle);
            
            var statsGrid = trackProgressWindow.document.createElement('div');
            statsGrid.style.cssText = 'display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;';
            
            // Calculate total groups for stats (before we sort them)
            var totalGroupsForStats = Math.ceil(gameState.players.length / gameState.numLanes);
            
            // Players stat (total/completed format) - dark theme
            var playersStat = trackProgressWindow.document.createElement('div');
            playersStat.style.cssText = 'background: rgba(30, 41, 59, 0.6); padding: 15px; border-radius: 12px; border: 2px solid rgba(59, 130, 246, 0.4); color: white; backdrop-filter: blur(10px);';
            playersStat.innerHTML = '<div style="font-size: 1.8em; font-weight: bold; margin-bottom: 5px;">üë• ' + completedPlayers + '/' + totalPlayers + '</div>' +
                                   '<div style="font-size: 0.9em; opacity: 0.8;">Players</div>';
            statsGrid.appendChild(playersStat);
            
            // Groups stat (total/completed format) - dark theme
            var groupsStat = trackProgressWindow.document.createElement('div');
            groupsStat.style.cssText = 'background: rgba(30, 41, 59, 0.6); padding: 15px; border-radius: 12px; border: 2px solid rgba(139, 92, 246, 0.4); color: white; backdrop-filter: blur(10px);';
            groupsStat.innerHTML = '<div style="font-size: 1.8em; font-weight: bold; margin-bottom: 5px;" id="groups-stat-number">üèÜ 0/' + totalGroupsForStats + '</div>' +
                                  '<div style="font-size: 0.9em; opacity: 0.8;">Groups</div>';
            statsGrid.appendChild(groupsStat);
            
            // Completion percentage stat - dark theme
            var percentStat = trackProgressWindow.document.createElement('div');
            percentStat.style.cssText = 'background: rgba(30, 41, 59, 0.6); padding: 15px; border-radius: 12px; border: 2px solid rgba(34, 197, 94, 0.4); color: white; backdrop-filter: blur(10px);';
            percentStat.innerHTML = '<div style="font-size: 1.8em; font-weight: bold; margin-bottom: 5px;">üìà ' + completionPercentage + '%</div>' +
                                   '<div style="font-size: 0.9em; opacity: 0.8;">Complete</div>';
            statsGrid.appendChild(percentStat);
            
            statsDiv.appendChild(statsGrid);
            content.appendChild(statsDiv);
            
            // Calculate player groups - each group has numLanes players
            var playersPerGroup = gameState.numLanes; // Group size equals number of lanes
            var laneGroups = [];
            var totalGroups = Math.ceil(gameState.players.length / playersPerGroup);
            
            console.log('Creating groups: ' + totalGroups + ' groups of ' + playersPerGroup + ' players each');
            
            for (var i = 0; i < totalGroups; i++) {
                var startIndex = i * playersPerGroup;
                var endIndex = Math.min(startIndex + playersPerGroup, gameState.players.length);
                var groupPlayers = gameState.players.slice(startIndex, endIndex);
                
                if (groupPlayers.length > 0) {
                    laneGroups.push({
                        laneNumber: i + 1,
                        players: groupPlayers
                    });
                }
            }
            
            // Calculate group completion statistics
            var completedGroups = 0;
            laneGroups.forEach(function(lane) {
                var groupCompletedPlayers = lane.players.filter(function(p) { return p.gameComplete; }).length;
                if (groupCompletedPlayers === lane.players.length && lane.players.length > 0) {
                    completedGroups++;
                }
            });
            
            // Update the groups stat in the main statistics section
            var groupsStatElement = trackProgressWindow.document.getElementById('groups-stat-number');
            if (groupsStatElement) {
                groupsStatElement.innerHTML = 'üèÜ ' + completedGroups + '/' + laneGroups.length;
            }
            
            
            // Determine group statuses: first incomplete = Throwing, second incomplete = On Deck
            var incompleteGroups = [];
            laneGroups.forEach(function(lane) {
                var completedPlayers = lane.players.filter(function(p) { return p.gameComplete; }).length;
                var isGroupComplete = completedPlayers === lane.players.length && lane.players.length > 0;
                if (!isGroupComplete) {
                    incompleteGroups.push(lane.laneNumber);
                }
            });
            
            var throwingGroup = incompleteGroups.length > 0 ? incompleteGroups[0] : null;
            var onDeckGroup = incompleteGroups.length > 1 ? incompleteGroups[1] : null;
            
            // Sort groups: incomplete groups first (in order), completed groups at bottom
            var incompleteGroupsDisplay = [];
            var completedGroupsDisplay = [];
            
            laneGroups.forEach(function(lane) {
                var completedPlayers = lane.players.filter(function(p) { return p.gameComplete; }).length;
                var isGroupComplete = completedPlayers === lane.players.length && lane.players.length > 0;
                
                if (isGroupComplete) {
                    completedGroupsDisplay.push(lane);
                } else {
                    incompleteGroupsDisplay.push(lane);
                }
            });
            
            // Combine arrays: incomplete first, then completed
            var sortedGroups = incompleteGroupsDisplay.concat(completedGroupsDisplay);
            
            // Add separator before completed groups if there are any
            var separatorAdded = false;
            
            // Create lane groups display
            sortedGroups.forEach(function(lane, index) {
                // Check if all players in this group are complete
                var completedPlayers = lane.players.filter(function(p) { return p.gameComplete; }).length;
                var isGroupComplete = completedPlayers === lane.players.length && lane.players.length > 0;
                
                // Add separator before first completed group
                if (isGroupComplete && !separatorAdded && completedGroupsDisplay.length > 0) {
                    var separatorDiv = trackProgressWindow.document.createElement('div');
                    separatorDiv.style.cssText = 'margin: 30px 0 20px 0; padding: 15px; background: rgba(51, 65, 85, 0.6); border: 2px solid rgba(34, 197, 94, 0.3); border-radius: 12px; text-align: center; font-weight: bold; color: #22c55e; backdrop-filter: blur(10px);';
                    separatorDiv.innerHTML = 'üìã Completed Groups';
                    content.appendChild(separatorDiv);
                    separatorAdded = true;
                }
                
                // Determine group status
                var groupStatus = '';
                var statusColor = '';
                var statusBgColor = '';
                
                if (isGroupComplete) {
                    groupStatus = 'COMPLETE';
                    statusColor = '#22c55e';
                    statusBgColor = 'rgba(51, 65, 85, 0.8)';
                } else if (lane.laneNumber === throwingGroup) {
                    groupStatus = 'THROWING';
                    statusColor = '#ef4444';
                    statusBgColor = 'rgba(51, 65, 85, 0.8)';
                } else if (lane.laneNumber === onDeckGroup) {
                    groupStatus = 'ON DECK';
                    statusColor = '#f59e0b';
                    statusBgColor = 'rgba(51, 65, 85, 0.8)';
                } else {
                    groupStatus = 'WAITING';
                    statusColor = '#94a3b8';
                    statusBgColor = 'rgba(51, 65, 85, 0.8)';
                }
                
                var laneDiv = trackProgressWindow.document.createElement('div');
                laneDiv.className = 'lane';
                laneDiv.style.background = statusBgColor;
                laneDiv.style.borderColor = statusColor;
                laneDiv.style.borderWidth = lane.laneNumber === throwingGroup ? '3px' : '2px';
                
                var laneHeader = trackProgressWindow.document.createElement('h2');
                laneHeader.style.color = statusColor;
                
                var statusIcon = '';
                if (isGroupComplete) statusIcon = '‚úÖ';
                else if (lane.laneNumber === throwingGroup) statusIcon = 'üéØ';
                else if (lane.laneNumber === onDeckGroup) statusIcon = 'üïê';
                else statusIcon = '‚è∏Ô∏è';
                
                if (isGroupComplete) {
                    laneHeader.innerHTML = statusIcon + ' Group ' + lane.laneNumber + ' - ' + groupStatus + ' (' + lane.players.length + ' players)';
                } else {
                    laneHeader.innerHTML = statusIcon + ' Group ' + lane.laneNumber + ' - ' + groupStatus + ' (' + completedPlayers + '/' + lane.players.length + ' complete)';
                }
                
                laneDiv.appendChild(laneHeader);
                
                // Create player container
                var playersContainer = trackProgressWindow.document.createElement('div');
                playersContainer.id = 'players-group-' + lane.laneNumber;
                playersContainer.className = 'players-container';
                
                // If group has more than 5 players, use two-column layout
                if (lane.players.length > 5) {
                    playersContainer.classList.add('two-columns');
                    
                    // Create two columns
                    var leftColumn = trackProgressWindow.document.createElement('div');
                    leftColumn.className = 'player-column';
                    var rightColumn = trackProgressWindow.document.createElement('div');
                    rightColumn.className = 'player-column';
                    
                    // Split players between columns
                    var midPoint = Math.ceil(lane.players.length / 2);
                    var leftPlayers = lane.players.slice(0, midPoint);
                    var rightPlayers = lane.players.slice(midPoint);
                    
                    // Add players to left column
                    leftPlayers.forEach(function(player) {
                        var playerDiv = createPlayerDiv(player, lane, throwingGroup, onDeckGroup);
                        leftColumn.appendChild(playerDiv);
                    });
                    
                    // Add players to right column
                    rightPlayers.forEach(function(player) {
                        var playerDiv = createPlayerDiv(player, lane, throwingGroup, onDeckGroup);
                        rightColumn.appendChild(playerDiv);
                    });
                    
                    playersContainer.appendChild(leftColumn);
                    playersContainer.appendChild(rightColumn);
                } else {
                    // Single column layout for 5 or fewer players
                    lane.players.forEach(function(player) {
                        var playerDiv = createPlayerDiv(player, lane, throwingGroup, onDeckGroup);
                        playersContainer.appendChild(playerDiv);
                    });
                }
                
                laneDiv.appendChild(playersContainer);
                
                content.appendChild(laneDiv);
            });
            
            console.log('Track Progress window updated with ' + laneGroups.length + ' groups');
        }
        

        
        function calculatePlayerProgress(player) {
            if (player.gameComplete) return 100;
            
            var totalThrows = gameState.rounds * gameState.numDistances * gameState.throwsPerRound;
            var completedThrows = 0;
            
            for (var r = 0; r < player.scores.length; r++) {
                for (var d = 0; d < player.scores[r].length; d++) {
                    for (var t = 0; t < player.scores[r][d].length; t++) {
                        if (player.scores[r][d][t] !== null) {
                            completedThrows++;
                        }
                    }
                }
            }
            
            return Math.round((completedThrows / totalThrows) * 100);
        }
        
        function hasPlayerStarted(player) {
            for (var r = 0; r < player.scores.length; r++) {
                for (var d = 0; d < player.scores[r].length; d++) {
                    for (var t = 0; t < player.scores[r][d].length; t++) {
                        if (player.scores[r][d][t] !== null) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        


        // Function to update the leaderboard window content
        function updateLeaderboardWindow() {
            if (!leaderboardWindow || leaderboardWindow.closed) {
                return;
            }

            var content = leaderboardWindow.document.getElementById('leaderboardContent');
            var subtitle = leaderboardWindow.document.getElementById('leaderboardSubtitle');
            
            if (!content || !subtitle) return;
            
            // COMPLETELY BLOCK UPDATES DURING TIEBREAKERS
            if (gameState.inTiebreaker) {
                console.log('üîí LEADERBOARD UPDATE BLOCKED - Tiebreaker in progress');
                console.log('üîí Stack trace:', new Error().stack);
                return;
            }
            
            // Update window title and header
            leaderboardWindow.document.title = 'üèÜ ' + (gameState.gameName || 'Walkback Championship') + ' - Live Leaderboard';
            
            // Update the header title if it exists
            var headerTitleDiv = leaderboardWindow.document.querySelector('.leaderboard-title div');
            if (headerTitleDiv) {
                var titleElement = headerTitleDiv.querySelector('div');
                if (titleElement) {
                    titleElement.textContent = gameState.gameName || 'Walkback Championship';
                }
            }

            // Clear existing content
            content.innerHTML = '';
            
            // Update status in title area
            var statusElement = leaderboardWindow.document.getElementById('leaderboardStatus');
            if (statusElement) {
                if (gameState.gameFinalized) {
                    statusElement.innerHTML = 'üîí FINALIZED RESULTS - SCORES LOCKED';
                    statusElement.className = 'leaderboard-status show';
                } else if (gameState.inTiebreaker) {
                    statusElement.innerHTML = 'üî• TIEBREAKER ROUND ' + gameState.tiebreakerRound + ' - ' + gameState.tiebreakerPlayers.length + ' players tied';
                    statusElement.className = 'leaderboard-status show';
                } else {
                    statusElement.innerHTML = '';
                    statusElement.className = 'leaderboard-status';
                }
            } else if (isEntireGameComplete()) {
                if (statusElement) {
                    statusElement.innerHTML = 'üèÜ WALKBACK COMPLETE - FINAL RESULTS';
                    statusElement.className = 'leaderboard-status show';
                }
            }
            


            // Update subtitle with game status
            if (gameState.inTiebreaker) {
                var tiedCount = gameState.tiedPlayers ? gameState.tiedPlayers.length : 0;
                subtitle.textContent = 'Tiebreaker Round ' + gameState.tiebreakerRound + ' - ' + tiedCount + ' players tied';
            } else {
                var completedPlayers = gameState.players.filter(function(p) { return p.gameComplete; }).length;
                subtitle.textContent = completedPlayers + '/' + gameState.players.length + ' players completed';
            }

            if (gameState.players.length === 0) {
                var noPlayersDiv = leaderboardWindow.document.createElement('div');
                noPlayersDiv.className = 'no-players';
                noPlayersDiv.innerHTML = 'üë• No players added yet<br><span style="font-size: 0.9rem; opacity: 0.7; margin-top: 10px; display: block;">Add players to see live rankings</span>';
                content.appendChild(noPlayersDiv);
                return;
            }

            // Sort players by regulation score only (descending for standard, ascending for golf)
            var sortedPlayers = gameState.players.slice().sort(function(a, b) {
                // Sort by regulation scores only - tiebreakers are only for breaking ties, not adding points
                return gameState.isGolf ? a.total - b.total : b.total - a.total;
            });

            // Determine layout based on number of players
            var playersToShow = sortedPlayers.slice(0, 20);
            var playerCount = playersToShow.length;
            
            // Apply appropriate CSS class based on player count
            if (playerCount <= 10) {
                var sizeClass = '';
                if (playerCount <= 2) {
                    sizeClass = ' few-players-1-2';
                } else if (playerCount <= 4) {
                    sizeClass = ' few-players-3-4';
                } else if (playerCount <= 6) {
                    sizeClass = ' few-players-5-6';
                } else if (playerCount <= 8) {
                    sizeClass = ' few-players-7-8';
                } else if (playerCount <= 10) {
                    sizeClass = ' few-players-9-10';
                }
                content.className = 'leaderboard-content single-column' + sizeClass;
            } else {
                content.className = 'leaderboard-content two-column';
            }

            // Generate leaderboard items (limit to top 20 players)
            playersToShow.forEach(function(player, index) {
                var rank = index + 1;
                var trophy = rank === 1 ? 'üèÜ' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : 'üéØ';
                var rankClass = rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : rank === 3 ? 'rank-3' : 'rank-other';
                
                var item = leaderboardWindow.document.createElement('div');
                item.className = 'leaderboard-item ' + rankClass;
                
                if (rank === 1 && (isEntireGameComplete() || gameState.gameFinalized)) {
                    item.style.background = 'linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(245, 158, 11, 0.1))';
                    item.style.border = '2px solid #fbbf24';
                    item.style.boxShadow = '0 4px 15px rgba(251, 191, 36, 0.3)';
                }
                
                // Hide players not in tiebreaker if we're in tiebreaker mode
                if (gameState.inTiebreaker && player.hiddenForTiebreaker) {
                    item.style.opacity = '0.5';
                    item.style.filter = 'grayscale(70%)';
                }
                
                // Show regulation score only - tiebreakers are only for breaking ties, not adding points
                var totalScoreDisplay = player.total;
                
                var maxScoreLabel = gameState.maxScore === 5 ? 'Bullseyes' : 'Max Scores';
                
                // Get team information for this player
                var playerTeam = getPlayerTeam(player.name);
                var teamInfoHtml = '';
                if (playerTeam) {
                    var teamColor = playerTeam.color || '#3b82f6'; // Default to blue if no color
                    teamInfoHtml = '<div style="background: ' + teamColor + '1A; border: 1px solid ' + teamColor + '; padding: 4px 8px; border-radius: 4px; margin-top: 4px; display: inline-flex; align-items: center; gap: 4px; font-size: 0.8rem;">' +
                        '<span style="color: ' + teamColor + ';">üèÜ</span>' +
                        '<span style="color: ' + teamColor + '; font-weight: 500;">' + playerTeam.name + '</span>' +
                        (playerTeam.captainId && playerTeam.members.find(m => m.id === player.id && m.id === playerTeam.captainId) ? 
                            '<span style="color: #f59e0b;">üëë</span>' : '') +
                        '</div>';
                }

                item.innerHTML = 
                    '<div class="leaderboard-trophy">' + trophy + '</div>' +
                    '<div class="leaderboard-rank" style="color: ' + 
                    (rank === 1 ? '#ffd700' : rank === 2 ? '#c0c0c0' : rank === 3 ? '#cd7f32' : '#64748b') + ';">#' + rank + '</div>' +
                    '<div class="leaderboard-info">' +
                        '<div class="leaderboard-name">' + player.name + (rank === 1 && (isEntireGameComplete() || gameState.gameFinalized) ? ' üéâ' : '') + '</div>' +
                        teamInfoHtml +
                        '<div class="leaderboard-stats">' +
                            '<div class="leaderboard-stat">Avg: <span class="leaderboard-stat-value">' + player.average + '</span></div>' +
                            '<span>‚Ä¢</span>' +
                            '<div class="leaderboard-stat">Efficiency: <span class="leaderboard-stat-value">' + (player.percentage || 0) + '%</span></div>' +
                            '<span>‚Ä¢</span>' +
                            '<div class="leaderboard-stat" style="color: #fbbf24; font-weight: bold;">üéØ ' + maxScoreLabel + ': ' + player.bullseyes + '</div>' +
                            (player.tripleNickels > 0 ? '<span>‚Ä¢</span><div class="leaderboard-stat" style="color: #ef4444; font-weight: bold;">üî• Triple Nickels: ' + player.tripleNickels + '</div>' : '') +
                            (player.noDrops > 0 ? '<span>‚Ä¢</span><div class="leaderboard-stat" style="color: #22c55e; font-weight: bold;">üíé No Drops: ' + player.noDrops + '</div>' : '') +
                        '</div>' +
                    '</div>' +
                    '<div class="leaderboard-score">' +
                        '<div>' + totalScoreDisplay + '</div>' +
                        '<div class="leaderboard-score-label">POINTS</div>' +
                    '</div>';
                
                content.appendChild(item);
            });
        }

        // Keep the old function for backward compatibility but redirect to new function
        function toggleLeaderboard() {
            openLeaderboardWindow();
        }
        
        // Function to detect multi-monitor setup and get optimal window position
        function getMultiMonitorWindowPosition() {
            try {
                // Log all available screen information for debugging
                console.log('üîç Screen Detection Debug:');
                console.log('  window.screen.width:', window.screen.width);
                console.log('  window.screen.height:', window.screen.height);
                console.log('  window.screen.availWidth:', window.screen.availWidth);
                console.log('  window.screen.availHeight:', window.screen.availHeight);
                console.log('  window.screen.left:', window.screen.left);
                console.log('  window.screen.top:', window.screen.top);
                
                // Check if we have access to screen information
                if (window.screen && window.screen.availWidth) {
                    var primaryScreenWidth = window.screen.availWidth;
                    var primaryScreenHeight = window.screen.availHeight;
                    var totalScreenWidth = window.screen.width;
                    var totalScreenHeight = window.screen.height;
                    
                    // Calculate the difference to determine if we have multiple monitors
                    var widthDifference = totalScreenWidth - primaryScreenWidth;
                    var heightDifference = totalScreenHeight - primaryScreenHeight;
                    
                    console.log('  Width difference:', widthDifference);
                    console.log('  Height difference:', heightDifference);
                    console.log('  Primary screen width:', primaryScreenWidth);
                    console.log('  Total screen width:', totalScreenWidth);
                    
                    // More aggressive detection for multi-monitor setups
                    // Check if total screen width is significantly larger than primary screen width
                    if (totalScreenWidth > primaryScreenWidth * 1.2) {
                        // We have multiple monitors - position on second monitor
                        var leftPosition = primaryScreenWidth + 50; // 50px from left edge of second monitor
                        var topPosition = 50; // 50px from top
                        
                        console.log('üéØ Multi-monitor detected! Positioning on second monitor at:', leftPosition, topPosition);
                        
                        return {
                            left: leftPosition,
                            top: topPosition,
                            multiMonitor: true,
                            reason: 'width_difference'
                        };
                    }
                    
                    // Alternative detection method - check if we have significant additional screen space
                    if (widthDifference > 200 || heightDifference > 200) {
                        var leftPosition, topPosition;
                        
                        if (widthDifference > heightDifference) {
                            // Horizontal multi-monitor setup (side by side)
                            leftPosition = primaryScreenWidth + 50;
                            topPosition = 50;
                        } else {
                            // Vertical multi-monitor setup (stacked)
                            leftPosition = 50;
                            topPosition = primaryScreenHeight + 50;
                        }
                        
                        console.log('üéØ Multi-monitor detected (alternative method)! Positioning at:', leftPosition, topPosition);
                        
                        return {
                            left: leftPosition,
                            top: topPosition,
                            multiMonitor: true,
                            reason: 'space_difference'
                        };
                    }
                }
                
                // Single monitor or fallback
                console.log('üñ•Ô∏è Single monitor detected or fallback. Using default position.');
                return {
                    left: 100,
                    top: 100,
                    multiMonitor: false,
                    reason: 'single_monitor'
                };
            } catch (error) {
                console.log('‚ùå Error detecting multi-monitor setup:', error);
                return {
                    left: 100,
                    top: 100,
                    multiMonitor: false,
                    reason: 'error'
                };
            }
        }

        // Try to reconnect to leaderboard window if reference was lost
        function tryReconnectLeaderboard() {
            // If we already have a valid reference, we're good
            if (leaderboardWindow && !leaderboardWindow.closed) {
                return true;
            }
            
            // Only try to reconnect if localStorage says a window should exist
            if (localStorage.getItem('walkbackLeaderboardOpen') !== 'true') {
                return false;
            }
            
            try {
                // Try to get reference to existing window using minimal features
                // If a new window is created, it will be tiny and off-screen
                var existingWindow = window.open('', 'leaderboard', 'width=1,height=1,left=-2000,top=-2000');
                
                if (existingWindow && !existingWindow.closed) {
                    // Check if it's actually our leaderboard window
                    var hasContent = existingWindow.document.body && 
                                   existingWindow.document.body.children.length > 0 &&
                                   existingWindow.document.getElementById('leaderboardContent');
                    
                    if (hasContent) {
                        console.log('üîó Reconnected to existing leaderboard window!');
                        leaderboardWindow = existingWindow;
                        // Restore window to normal size if it was our existing window
                        if (existingWindow.outerWidth === 1) {
                            existingWindow.resizeTo(1200, 800);
                        }
                        return true;
                    } else {
                        // Not our window or blank - close it immediately and clear flag
                        existingWindow.close();
                        localStorage.removeItem('walkbackLeaderboardOpen');
                    }
                } else {
                    // Window doesn't exist - clear flag
                    localStorage.removeItem('walkbackLeaderboardOpen');
                }
            } catch (error) {
                // Silently fail
                localStorage.removeItem('walkbackLeaderboardOpen');
            }
            return false;
        }
        
        // Try to reconnect to track progress window if reference was lost
        function tryReconnectTrackProgress() {
            // If we already have a valid reference, we're good
            if (trackProgressWindow && !trackProgressWindow.closed) {
                return true;
            }
            
            // Only try to reconnect if localStorage says a window should exist
            if (localStorage.getItem('walkbackTrackProgressOpen') !== 'true') {
                return false;
            }
            
            try {
                // Try to get reference to existing window using minimal features
                // If a new window is created, it will be tiny and off-screen
                var existingWindow = window.open('', 'trackProgress', 'width=1,height=1,left=-2000,top=-2000');
                
                if (existingWindow && !existingWindow.closed) {
                    // Check if it's actually our track progress window
                    var hasContent = existingWindow.document.body && 
                                   existingWindow.document.body.children.length > 0 &&
                                   existingWindow.document.getElementById('content');
                    
                    if (hasContent) {
                        console.log('üîó Reconnected to existing track progress window!');
                        trackProgressWindow = existingWindow;
                        // Restore window to normal size if it was our existing window
                        if (existingWindow.outerWidth === 1) {
                            existingWindow.resizeTo(1200, 800);
                        }
                        return true;
                    } else {
                        // Not our window or blank - close it immediately and clear flag
                        existingWindow.close();
                        localStorage.removeItem('walkbackTrackProgressOpen');
                    }
                } else {
                    // Window doesn't exist - clear flag
                    localStorage.removeItem('walkbackTrackProgressOpen');
                }
            } catch (error) {
                // Silently fail
                localStorage.removeItem('walkbackTrackProgressOpen');
            }
            return false;
        }

        // Function to manually refresh leaderboard (called when tiebreakers start/end)
        function refreshLeaderboardIfOpen() {
            // Try to reconnect if needed, then update
            if (tryReconnectLeaderboard() && !gameState.inTiebreaker) {
                updateLeaderboardWindow();
            }
        }
        
        // Function to manually refresh track progress (called when scores change)
        function refreshTrackProgressIfOpen() {
            // Try to reconnect if needed, then update
            if (tryReconnectTrackProgress()) {
                updateTrackProgressWindow();
            }
        }
        
        // Function to show frozen standings during tiebreakers
        function showFrozenLeaderboard() {
            console.log('üßä SHOWING FROZEN LEADERBOARD - Tiebreaker in progress');
            if (!leaderboardWindow || leaderboardWindow.closed) {
                return;
            }

            var content = leaderboardWindow.document.getElementById('leaderboardContent');
            var subtitle = leaderboardWindow.document.getElementById('leaderboardSubtitle');
            var statusElement = leaderboardWindow.document.getElementById('leaderboardStatus');
            
            if (!content || !subtitle) return;
            
            // Update status in title area
            if (statusElement) {
                statusElement.innerHTML = 'üî• TIEBREAKER IN PROGRESS - STANDINGS FROZEN';
                statusElement.className = 'leaderboard-status show';
            }
            
            // Show frozen pre-tiebreaker standings
            if (gameState.preTiebreakerStandings) {
                content.innerHTML = '';
                
                // Determine layout based on number of players
                var standingsToShow = gameState.preTiebreakerStandings.slice(0, 20);
                var playerCount = standingsToShow.length;
                
                // Apply appropriate CSS class based on player count
                if (playerCount <= 10) {
                    content.className = 'leaderboard-content single-column';
                } else {
                    content.className = 'leaderboard-content two-column';
                }

                // Show frozen standings (limit to top 20 players)
                standingsToShow.forEach(function(standing) {
                    var player = standing.player;
                    var rank = standing.rank;
                    var trophy = rank === 1 ? 'üèÜ' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : 'üéØ';
                    var rankClass = rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : rank === 3 ? 'rank-3' : 'rank-other';
                    
                    var item = leaderboardWindow.document.createElement('div');
                    item.className = 'leaderboard-item ' + rankClass;
                    item.style.opacity = '0.7'; // Make it look frozen
                    
                    // Use frozen regulation game score only (no tiebreaker points)
                    var totalScoreDisplay = standing.total;
                    
                    var maxScoreLabel = gameState.maxScore === 5 ? 'Bullseyes' : 'Max Scores';
                    
                    // Get team information for this player
                    var playerTeam = getPlayerTeam(player.name);
                    var teamInfoHtml = '';
                    if (playerTeam) {
                        var teamColor = playerTeam.color || '#3b82f6'; // Default to blue if no color
                        teamInfoHtml = '<div style="background: ' + teamColor + '1A; border: 1px solid ' + teamColor + '; padding: 4px 8px; border-radius: 4px; margin-top: 4px; display: inline-flex; align-items: center; gap: 4px; font-size: 0.8rem;">' +
                            '<span style="color: ' + teamColor + ';">üèÜ</span>' +
                            '<span style="color: ' + teamColor + '; font-weight: 500;">' + playerTeam.name + '</span>' +
                            (playerTeam.captainId && playerTeam.members.find(m => m.id === player.id && m.id === playerTeam.captainId) ? 
                                '<span style="color: #f59e0b;">üëë</span>' : '') +
                            '</div>';
                    }

                    item.innerHTML = 
                        '<div class="leaderboard-trophy">' + trophy + '</div>' +
                        '<div class="leaderboard-rank" style="color: ' + 
                        (rank === 1 ? '#ffd700' : rank === 2 ? '#c0c0c0' : rank === 3 ? '#cd7f32' : '#64748b') + ';">#' + rank + '</div>' +
                        '<div class="leaderboard-info">' +
                            '<div class="leaderboard-name">' + player.name + '</div>' +
                            teamInfoHtml +
                            '<div class="leaderboard-stats">' +
                                '<div class="leaderboard-stat">Avg: <span class="leaderboard-stat-value">' + player.average + '</span></div>' +
                                '<span>‚Ä¢</span>' +
                                '<div class="leaderboard-stat">Efficiency: <span class="leaderboard-stat-value">' + (player.percentage || 0) + '%</span></div>' +
                                '<span>‚Ä¢</span>' +
                                '<div class="leaderboard-stat" style="color: #fbbf24; font-weight: bold;">üéØ ' + maxScoreLabel + ': ' + player.bullseyes + '</div>' +
                                (player.tripleNickels > 0 ? '<span>‚Ä¢</span><div class="leaderboard-stat" style="color: #ef4444; font-weight: bold;">üî• Triple Nickels: ' + player.tripleNickels + '</div>' : '') +
                                (player.noDrops > 0 ? '<span>‚Ä¢</span><div class="leaderboard-stat" style="color: #22c55e; font-weight: bold;">üíé No Drops: ' + player.noDrops + '</div>' : '') +
                            '</div>' +
                        '</div>' +
                        '<div class="leaderboard-score">' +
                            '<div>' + totalScoreDisplay + '</div>' +
                            '<div class="leaderboard-score-label">POINTS</div>' +
                        '</div>';
                    
                    content.appendChild(item);
                });
                
                // Update subtitle
                subtitle.textContent = 'Tiebreaker in Progress - Standings Frozen';
            }
        }


        // Initialize the game
        function initializeGame() {
            // Load saved game state if available
            loadGameState();
            
            // Load custom presets
            loadCustomPresets();
            
            // Note: We don't reconnect windows on page load to avoid creating blank windows
            // Reconnection happens automatically when scores are entered (via refreshLeaderboardIfOpen)
            
            // Ensure distances array matches numDistances
            if (gameState.distances.length !== gameState.numDistances) {
                gameState.distances = getDefaultDistances(gameState.distancePreset, gameState.numDistances);
            }
            
            // Generate target rings based on max score
            gameState.targetRings = generateTargetRings();
            
            // Only add first player if no saved data was loaded
            if (gameState.players.length === 0) {
                addPlayer(); // Add first player
            }
            
            updateGameDisplay();
            updateAddPlayerButton(); // Set initial button state
        }

        // Auto-save functionality
        function saveGameState() {
            try {
                const saveData = {
                    gameState: gameState,
                    playerId: playerId,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('walkbackGameState', JSON.stringify(saveData));
            } catch (error) {
                console.error('Error saving game state:', error);
            }
        }

        function loadGameState() {
            try {
                const savedData = localStorage.getItem('walkbackGameState');
                if (savedData) {
                    const parsed = JSON.parse(savedData);
                    if (parsed.gameState) {
                        // Restore game state
                        gameState = parsed.gameState;
                        playerId = parsed.playerId || 1;
                        
                        // Ensure all required properties exist
                        if (!gameState.targetRings) {
                            gameState.targetRings = generateTargetRings();
                        }
                        if (!gameState.distances) {
                            gameState.distances = getDefaultDistances(gameState.distancePreset, gameState.numDistances);
                        }
                        // Set default playMode to consecutive if not set (for new defaults)
                        if (!gameState.playMode) {
                            gameState.playMode = 'consecutive';
                        }
                        // Set default distancesOnTop based on playMode if not set
                        if (gameState.distancesOnTop === undefined || gameState.distancesOnTop === null) {
                            gameState.distancesOnTop = (gameState.playMode === 'sequential');
                        }
                        
                        // Update UI
                        renderPlayers();
                        updateGameDisplay();
                        updateAddPlayerButton();
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error loading game state:', error);
            }
            return false;
        }

        function addPlayer() {
            if (hasGameStarted()) {
                showCustomAlert('Cannot add players after scoring has begun! Reset the game to add more players.');
                return;
            }
            
            if (gameState.playersImported) {
                showCustomAlert('Cannot manually add players when using imported players! Clear all players first to add manual players.');
                return;
            }
            
            var player = {
                id: playerId++,
                name: 'Player ' + (gameState.players.length + 1),
                scores: Array(gameState.rounds).fill(null).map(function() { 
                    return Array(gameState.numDistances).fill(null).map(function() { 
                        return Array(gameState.throwsPerRound).fill(null); 
                    }); 
                }),
                total: 0,
                average: 0,
                bullseyes: 0,
                tripleNickels: 0,
                noDrops: 0,
                percentage: 0,
                currentRound: 1,
                currentDistance: 1,
                currentThrow: 1,
                viewingRound: 1,
                viewingDistance: 1,
                gameComplete: false,
                tiebreakerScores: [],
                tiebreakerTotal: 0,
                podiumTiebreakerPoints: 0,
                podiumTiebreakerPosition: null
            };
            gameState.players.push(player);
            renderPlayers();
            updateGameDisplay();
            
            // Update leaderboard if open
            refreshLeaderboardIfOpen();
            
            // Update track progress if open
            refreshTrackProgressIfOpen();
            
            saveGameState(); // Auto-save after adding player
        }

        function removePlayer(playerId) {
            if (gameState.gameFinalized) {
                alert('Cannot remove players after game has been finalized!');
                return;
            }
            
            if (gameState.inTiebreaker) {
                alert('Cannot remove players during a tiebreaker!');
                return;
            }
            
            var playerIndex = gameState.players.findIndex(function(p) { return p.id === playerId; });
            if (playerIndex === -1) return;
            
            var player = gameState.players[playerIndex];
            
            // Check if player has any scores
            var hasScores = player.scores.some(function(round) {
                return round && round.some(function(distance) {
                    return distance && distance.some(function(score) { 
                        return score !== null; 
                    });
                });
            });
            
            var confirmMessage = hasScores ? 
                'Remove ' + player.name + '? This will permanently delete all their scores!' :
                'Remove ' + player.name + ' from the game?';
            
            showClearPlayersConfirm(confirmMessage, function() {
                // Remove the player
                gameState.players.splice(playerIndex, 1);
                
                // Clear any editing state for this player
                if (gameState.editingThrow && gameState.editingThrow.playerId === playerId) {
                    gameState.editingThrow = null;
                }
                
                renderPlayers();
                updateGameDisplay();
                
                // Update leaderboard if open
                refreshLeaderboardIfOpen();
                
                // Update track progress if open
                refreshTrackProgressIfOpen();
                
                saveGameState(); // Auto-save after removing player
                
                // If no players left, continue silently
            });
        }

        function updateGameDisplay() {
            var gameTitle = gameState.inTiebreaker ? gameState.type + ' - ' + getTiebreakerDisplayName(gameState.tiebreakerMode) : gameState.type;
            document.getElementById('currentGameTitle').textContent = gameTitle;
            
            var gameNameDisplay = gameState.gameName ? ' ‚Ä¢ ' + gameState.gameName : '';
            var tiebreakerInfo = '';
            
            if (gameState.inTiebreaker) {
                if ((gameState.tiebreakerMode === 'sudden-death-podium' || gameState.tiebreakerMode === 'sudden-death-podium-match') && gameState.podiumPosition) {
                    var positionNames = {
                        first: '1st Place',
                        second: '2nd Place',
                        third: '3rd Place'
                    };
                    tiebreakerInfo = ' ‚Ä¢ ' + positionNames[gameState.podiumPosition].toUpperCase() + ' TIEBREAKER ROUND ' + gameState.tiebreakerRound;
                } else {
                    tiebreakerInfo = ' ‚Ä¢ TIEBREAKER ROUND ' + gameState.tiebreakerRound;
                }
            }
            
            var totalThrows = gameState.rounds * gameState.numDistances * gameState.throwsPerRound;
            var playModeDisplay = gameState.playMode === 'consecutive' ? ' ‚Ä¢ Consecutive Rounds' : ' ‚Ä¢ Sequential Distance';
            var maxScoreDisplay = gameState.maxScore !== 5 ? ' ‚Ä¢ Max: ' + gameState.maxScore + ' pts' : '';
            var importStatus = gameState.playersImported ? ' ‚Ä¢ üì• Imported Players' : '';
            document.getElementById('gameStatus').textContent = 'üó°Ô∏è ' + gameState.type + ' Game' + gameNameDisplay + tiebreakerInfo + ' ‚Ä¢ ' + gameState.rounds + ' Rounds ‚Ä¢ ' + gameState.numDistances + ' Distances ‚Ä¢ ' + totalThrows + ' Total Throws' + playModeDisplay + maxScoreDisplay + importStatus;
            
            // Show/hide finalized banner
            var finalizedBanner = document.getElementById('finalizedBanner');
            if (finalizedBanner) {
                finalizedBanner.style.display = gameState.gameFinalized ? 'block' : 'none';
            }
            
            // Update finalize button visibility based on current game state
            updateFinalizeButtonVisibility();
            
            // Update track progress if open
            refreshTrackProgressIfOpen();
        }

        function renderPlayers() {
            var grid = document.getElementById('playersGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            // Debug logging
            console.log('üéØ renderPlayers called - Total players:', gameState.players ? gameState.players.length : 0);
            console.log('üéØ Current page:', gameState.currentPage, 'Players per page:', gameState.playersPerPage);
            
            var allPlayersToShow = gameState.inTiebreaker ? 
                gameState.players.filter(function(player) { return !player.hiddenForTiebreaker; }) :
                gameState.players;
            
            // Get paginated players (disable pagination during tiebreakers for clarity)
            var playersToShow = allPlayersToShow; // Default to all players
            
            // Apply pagination only if we have players and not in tiebreaker
            if (!gameState.inTiebreaker && allPlayersToShow && allPlayersToShow.length > 0 && gameState.playersPerPage !== 'all') {
                var playersPerPage = parseInt(gameState.playersPerPage) || 20;
                var startIndex = (gameState.currentPage - 1) * playersPerPage;
                var endIndex = Math.min(startIndex + playersPerPage, allPlayersToShow.length);
                
                // Only apply pagination if we have valid indices
                if (startIndex >= 0 && startIndex < allPlayersToShow.length) {
                    playersToShow = allPlayersToShow.slice(startIndex, endIndex);
                } else {
                    console.error('Invalid pagination indices: ' + startIndex + ' to ' + endIndex);
                }
            }
            
            console.log('üéØ Players to show after pagination:', playersToShow ? playersToShow.length : 0);
            
            // Safety check removed - let pagination handle empty results naturally
            
            playersToShow.forEach(function(player) {
                var playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                
                            // Handle tiebreaker display
            if (gameState.inTiebreaker && gameState.tiebreakerPlayers.some(function(tp) { return tp.id === player.id; })) {
                console.log('üîç DEBUG: Rendering tiebreaker player:', player.name);
                renderTiebreakerPlayer(playerCard, player);
            } else {
                console.log('üîç DEBUG: Rendering regular player:', player.name);
                renderRegularPlayer(playerCard, player);
            }
                
                grid.appendChild(playerCard);
            });
            
            // Update pagination controls after rendering players
            updatePaginationControls();
            
            // Update add player button state
            updateAddPlayerButton();
            
            // Update track progress if open
            refreshTrackProgressIfOpen();
        }

        function updateAddPlayerButton() {
            var addPlayerBtn = document.getElementById('addPlayerBtn');
            var importBtn = document.querySelector('button[onclick="importFromManagement()"]');
            var gameStarted = hasGameStarted();
            // Update Add Player button
            if (addPlayerBtn) {
                if (gameStarted) {
                    addPlayerBtn.disabled = true;
                    addPlayerBtn.style.opacity = '0.5';
                    addPlayerBtn.style.cursor = 'not-allowed';
                    addPlayerBtn.textContent = 'üîí Game Started - Cannot Add Players';
                } else if (gameState.playersImported) {
                    addPlayerBtn.disabled = true;
                    addPlayerBtn.style.opacity = '0.5';
                    addPlayerBtn.style.cursor = 'not-allowed';
                    addPlayerBtn.textContent = 'üì• Using Imported Players';
                    addPlayerBtn.title = 'Cannot manually add players when using imported players. Clear all players first to add manual players.';
                } else {
                    addPlayerBtn.disabled = false;
                    addPlayerBtn.style.opacity = '1';
                    addPlayerBtn.style.cursor = 'pointer';
                    addPlayerBtn.textContent = 'üë• Add Player';
                    addPlayerBtn.title = 'Add a new player to the game';
                }
            }
            // Update Import Players button
            if (importBtn) {
                if (gameStarted) {
                    importBtn.disabled = true;
                    importBtn.style.opacity = '0.5';
                    importBtn.style.cursor = 'not-allowed';
                    importBtn.textContent = 'üîí Game Started - Cannot Import';
                    importBtn.title = 'Cannot import players after scoring has begun! Reset the game to import players.';
                } else {
                    importBtn.disabled = false;
                    importBtn.style.opacity = '1';
                    importBtn.style.cursor = 'pointer';
                    importBtn.textContent = 'üì• Import Players';
                    importBtn.title = 'Import players from Management.html (click "Import to Walkback" in Management first)';
                }
            }
        }

        function renderRegularPlayer(playerCard, player) {
            var displayRound = player.viewingRound;
            var displayDistance = player.viewingDistance;
            var displayThrow = player.currentThrow;
            
            if (gameState.editingThrow && gameState.editingThrow.playerId === player.id) {
                displayRound = gameState.editingThrow.round;
                displayDistance = gameState.editingThrow.distance;
                displayThrow = gameState.editingThrow.throw;
            }
            
            var currentRoundDistanceScores = player.scores[displayRound - 1] && player.scores[displayRound - 1][displayDistance - 1] ? 
                player.scores[displayRound - 1][displayDistance - 1] : Array(gameState.throwsPerRound).fill(null);
            var currentRoundDistanceTotal = currentRoundDistanceScores.reduce(function(sum, score) { return sum + (score || 0); }, 0);

            var selectedScore = null;
            if (gameState.editingThrow && gameState.editingThrow.playerId === player.id) {
                selectedScore = currentRoundDistanceScores[gameState.editingThrow.throw - 1];
            } else if (displayRound === player.currentRound && displayDistance === player.currentDistance) {
                selectedScore = currentRoundDistanceScores[player.currentThrow - 1];
            }

            // Check if we're viewing a future round/distance that shouldn't allow score entry
            // For consecutive mode: future if distance > currentDistance, OR (distance == currentDistance AND round > currentRound)
            // For sequential mode: future if round > currentRound, OR (round == currentRound AND distance > currentDistance)
            var isViewingFuturePosition = false;
            if (gameState.playMode === 'consecutive') {
                isViewingFuturePosition = (displayDistance > player.currentDistance) || 
                                        (displayDistance === player.currentDistance && displayRound > player.currentRound);
            } else {
                isViewingFuturePosition = (displayRound > player.currentRound) || 
                                        (displayRound === player.currentRound && displayDistance > player.currentDistance);
            }
            
            var canEnterCurrentScore = !isViewingFuturePosition && canEnterScore(player, player.currentRound, player.currentDistance, player.currentThrow);
            var scoreButtonsHtml = gameState.targetRings.slice().reverse().map(function(score) {
                var isSelected = selectedScore === score;
                var backgroundColor = getScoreColor(score);
                var textColor = getScoreTextColor(score);
                var borderStyle = isSelected ? 'border: 3px solid #fbbf24;' : 'border: 2px solid rgba(255,255,255,0.2);';
                var boxShadow = isSelected ? 'box-shadow: 0 0 15px rgba(251, 191, 36, 0.5);' : '';
                
                var buttonStyle = 'background: ' + backgroundColor + '; color: ' + textColor + '; ' + borderStyle + ' ' + boxShadow + 
                       ' padding: 12px; border-radius: 8px; font-weight: bold; font-size: 1.1rem; min-width: 45px; min-height: 45px;';
                
                if (!canEnterCurrentScore) {
                    buttonStyle += ' opacity: 0.5; cursor: not-allowed;';
                    return '<button class="score-button" disabled ' +
                           'style="' + buttonStyle + '">' + score + '</button>';
                } else {
                    return '<button class="score-button" onclick="addScore(' + player.id + ', ' + score + ')" ' +
                           'style="' + buttonStyle + ' cursor: pointer; transition: all 0.3s ease;" ' +
                           'onmouseover="this.style.transform=\'scale(1.05)\'; this.style.boxShadow=\'0 4px 12px rgba(0,0,0,0.3)\'" ' +
                           'onmouseout="this.style.transform=\'scale(1)\'; this.style.boxShadow=\'' + boxShadow + '\'">' + 
                           score + '</button>';
                }
            }).join('');

            // Round navigation buttons
            // Check completion status for the currently viewing distance, not the current distance
            var roundNavButtons = Array(gameState.rounds).fill(null).map(function(_, roundIndex) {
                var roundNum = roundIndex + 1;
                var isViewing = roundNum === displayRound;
                // Check if this round is complete at the viewing distance
                var isCompleteAtViewingDistance = isDistanceComplete(player, roundIndex, displayDistance - 1);
                var isCurrent = roundNum === player.currentRound && displayDistance === player.currentDistance;
                // Check if this is the current round but viewing a different round (mark current position when editing elsewhere)
                var isCurrentPosition = roundNum === player.currentRound && !isViewing;
                
                var className = 'round-nav-btn ';
                var indicatorStyle = '';
                if (isViewing) {
                    className += 'current';
                } else if (isCompleteAtViewingDistance) {
                    // Round is complete at the viewing distance - show as completed
                    className += 'completed';
                } else if (isCurrent) {
                    // Show in-progress only if this is the current round at the current distance
                    className += 'in-progress';
                } else {
                    className += 'empty';
                }
                
                // Add border indicator if this is the current position but viewing elsewhere
                if (isCurrentPosition) {
                    indicatorStyle = 'border: 2px dashed #fbbf24; box-shadow: 0 0 8px rgba(251, 191, 36, 0.5);';
                }
                
                return '<button class="' + className + '" onclick="navigateToRound(' + player.id + ', ' + roundNum + ')" title="Round ' + roundNum + (isCurrentPosition ? ' (Current Position)' : '') + '" style="' + indicatorStyle + '">R' + roundNum + '</button>';
            }).join('');

            // Distance navigation buttons for current round
            var distanceNavButtons = Array(gameState.numDistances).fill(null).map(function(_, distanceIndex) {
                var distanceNum = distanceIndex + 1;
                var isViewing = distanceNum === player.viewingDistance && displayRound === player.viewingRound;
                var isComplete = isDistanceComplete(player, displayRound - 1, distanceIndex);
                var isCurrent = distanceNum === player.currentDistance && displayRound === player.currentRound;
                // Check if this is the current distance but viewing a different distance
                var isCurrentPosition = distanceNum === player.currentDistance && displayRound === player.currentRound && !isViewing;
                
                var className = 'round-nav-btn ';
                var indicatorStyle = '';
                if (isViewing) {
                    className += 'current';
                } else if (isComplete) {
                    className += 'completed';
                } else if (isCurrent) {
                    className += 'in-progress';
                } else {
                    className += 'empty';
                }
                
                // Add border indicator if this is the current position but viewing elsewhere
                if (isCurrentPosition) {
                    indicatorStyle = 'border: 2px dashed #fbbf24; box-shadow: 0 0 8px rgba(251, 191, 36, 0.5);';
                }
                
                var label = gameState.distances[distanceIndex] ? 
                    (gameState.distances[distanceIndex].includes('Meters') ? 
                        gameState.distances[distanceIndex].replace(' Meters', 'M').replace(' meters', 'm') :
                        gameState.distances[distanceIndex].length > 8 ? 
                            gameState.distances[distanceIndex].substring(0, 6) + '...' :
                            gameState.distances[distanceIndex]
                    ) : 'D' + distanceNum;
                
                var title = (gameState.distances[distanceIndex] || 'Distance ' + distanceNum) + (isCurrentPosition ? ' (Current Position)' : '');
                return '<button class="' + className + '" onclick="navigateToDistance(' + player.id + ', ' + displayRound + ', ' + distanceNum + ')" title="' + title + '" style="' + indicatorStyle + '">' + label + '</button>';
            }).join('');

            var throwDisplayHtml = Array(gameState.throwsPerRound).fill(null).map(function(_, throwIndex) {
                var score = currentRoundDistanceScores[throwIndex];
                var isCurrent = throwIndex === player.currentThrow - 1 && displayRound === player.currentRound && displayDistance === player.currentDistance && !gameState.editingThrow;
                var isEditing = gameState.editingThrow && 
                                gameState.editingThrow.playerId === player.id && 
                                gameState.editingThrow.round === displayRound && 
                                gameState.editingThrow.distance === displayDistance &&
                                gameState.editingThrow.throw === throwIndex + 1;
                
                var className = 'throw-box ';
                var backgroundColor = '';
                var textColor = 'white';
                var borderStyle = '';
                
                if (isEditing) {
                    className += 'editing';
                    backgroundColor = 'background: linear-gradient(45deg, #fbbf24, #f59e0b);';
                    textColor = '#1e293b';
                    borderStyle = 'border: 3px solid #fbbf24;';
                } else if (score !== null) {
                    if (!canEditThisThrow) {
                        className += 'locked';
                        backgroundColor = 'background: ' + getScoreColor(score) + '; opacity: 0.7;';
                        textColor = getScoreTextColor(score);
                        borderStyle = 'border: 2px solid #64748b;';
                    } else {
                        className += 'completed';
                        backgroundColor = 'background: ' + getScoreColor(score) + ';';
                        textColor = getScoreTextColor(score);
                        borderStyle = 'border: 2px solid rgba(255,255,255,0.3);';
                    }
                } else if (isCurrent) {
                    className += 'current';
                    backgroundColor = 'background: linear-gradient(45deg, #3b82f6, #1d4ed8);';
                    textColor = 'white';
                    borderStyle = 'border: 3px solid #60a5fa;';
                } else if (canEnterThisThrow) {
                    className += 'available';
                    backgroundColor = 'background: linear-gradient(45deg, #10b981, #059669);';
                    textColor = 'white';
                    borderStyle = 'border: 2px solid #34d399;';
                } else if (isViewingFuturePosition) {
                    className += 'future';
                    backgroundColor = 'background: #374151;';
                    textColor = '#6b7280';
                    borderStyle = 'border: 2px solid #4b5563;';
                } else {
                    className += 'empty';
                    backgroundColor = 'background: #475569;';
                    textColor = '#94a3b8';
                    borderStyle = 'border: 2px solid #64748b;';
                }
                
                var throwNum = throwIndex + 1;
                var roundNum = displayRound;
                var distanceNum = displayDistance;
                
                var canEditThisThrow = canEnterScore(player, roundNum, distanceNum, throwNum);
                var canEnterThisThrow = score === null && canEnterScore(player, roundNum, distanceNum, throwNum) && !isViewingFuturePosition;
                var isNextAvailable = score === null && roundNum === player.currentRound && distanceNum === player.currentDistance && throwNum === player.currentThrow;
                
                var clickHandler = score !== null ? 
                    (canEditThisThrow ? 'editThrow(' + player.id + ', ' + roundNum + ', ' + distanceNum + ', ' + throwNum + ')' : '') : 
                    (canEnterThisThrow ? 'navigateToThrow(' + player.id + ', ' + roundNum + ', ' + distanceNum + ', ' + throwNum + ')' : '');
                
                var tooltip = score !== null ? 
                    (canEditThisThrow ? 'Click to edit this throw (Score: ' + score + ')' : 'Score locked - game complete (Score: ' + score + ')') : 
                    (canEnterThisThrow ? 'Click to enter score for Throw ' + throwNum : 
                     (isViewingFuturePosition ? 'Complete previous rounds first' : 'Complete previous throws first'));
                
                return '<div class="' + className + '" onclick="' + clickHandler + '" title="' + tooltip + '" ' +
                       'style="padding: 15px; border-radius: 8px; text-align: center; font-weight: bold; cursor: pointer; ' +
                       'transition: all 0.3s ease; position: relative; ' + backgroundColor + ' color: ' + textColor + '; ' + borderStyle + '">' + 
                       (score !== null ? score : throwNum) + '</div>';
            }).join('');
            
            // Determine if viewing past/future round/distance based on actual game progression
            // For consecutive mode: need to consider both round and distance
            // If a round/distance has scores, it's in the past (completed) and should be editable
            var roundIndex = displayRound - 1;
            var distanceIndex = displayDistance - 1;
            var hasScores = player.scores[roundIndex] && 
                           player.scores[roundIndex][distanceIndex] && 
                           player.scores[roundIndex][distanceIndex].some(function(score) { return score !== null; });
            
            var isViewingPastRound = false;
            var isViewingFutureRound = false;
            var isViewingPastDistance = false;
            var isViewingFutureDistance = false;
            
            // If the round/distance has scores, it's completed (past) - don't show future message
            if (hasScores) {
                // Check if it's truly in the past based on game progression
                if (gameState.playMode === 'consecutive') {
                    if (displayDistance < player.currentDistance) {
                        isViewingPastDistance = true;
                    } else if (displayDistance === player.currentDistance && displayRound < player.currentRound) {
                        isViewingPastRound = true;
                    }
                } else {
                    if (displayRound < player.currentRound) {
                        isViewingPastRound = true;
                    } else if (displayRound === player.currentRound && displayDistance < player.currentDistance) {
                        isViewingPastDistance = true;
                    }
                }
            } else {
                // No scores yet - check if it's in the future
                if (gameState.playMode === 'consecutive') {
                    // Consecutive mode: rounds complete at each distance before moving to next distance
                    // Past: distance < currentDistance, OR (distance == currentDistance AND round < currentRound)
                    // Future: distance > currentDistance, OR (distance == currentDistance AND round > currentRound)
                    if (displayDistance < player.currentDistance) {
                        // Any round at a previous distance is in the past
                        isViewingPastDistance = true;
                    } else if (displayDistance > player.currentDistance) {
                        // Any round at a future distance is in the future
                        isViewingFutureDistance = true;
                    } else {
                        // Same distance - compare rounds
                        if (displayRound < player.currentRound) {
                            isViewingPastRound = true;
                        } else if (displayRound > player.currentRound) {
                            isViewingFutureRound = true;
                        }
                    }
                } else {
                    // Sequential mode: all distances in a round complete before moving to next round
                    // Past: round < currentRound, OR (round == currentRound AND distance < currentDistance)
                    // Future: round > currentRound, OR (round == currentRound AND distance > currentDistance)
                    if (displayRound < player.currentRound) {
                        isViewingPastRound = true;
                    } else if (displayRound > player.currentRound) {
                        isViewingFutureRound = true;
                    } else {
                        // Same round - compare distances
                        if (displayDistance < player.currentDistance) {
                            isViewingPastDistance = true;
                        } else if (displayDistance > player.currentDistance) {
                            isViewingFutureDistance = true;
                        }
                    }
                }
            }
            
            var maxPossibleScore = gameState.rounds * gameState.numDistances * gameState.throwsPerRound * gameState.maxScore;
            var currentDistanceName = gameState.distances[displayDistance - 1] || 'Distance ' + displayDistance;
            var currentPositionLabel = gameState.playMode === 'consecutive' ? 
                'Round ' + displayRound + ' at ' + currentDistanceName :
                'Round ' + displayRound + ' - ' + currentDistanceName;
            
            var maxScoreLabel = gameState.maxScore === 5 ? 'Bullseyes' : 'Max Scores';
            
            // Add remove button - only show if game is not finalized and not in tiebreaker
            var removeButtonHtml = '';
            if (!gameState.gameFinalized && !gameState.inTiebreaker) {
                removeButtonHtml = '<button class="remove-button" onclick="removePlayer(' + player.id + ')" title="Remove ' + player.name + '">‚úï</button>';
            }
            
            // Get team information for this player
            var playerTeam = getPlayerTeam(player.name);
            var teamInfoHtml = '';
            if (playerTeam) {
                var teamColor = playerTeam.color || '#3b82f6'; // Default to blue if no color
                teamInfoHtml = '<div style="background: ' + teamColor + '1A; border: 1px solid ' + teamColor + '; padding: 8px 12px; border-radius: 6px; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">' +
                    '<span style="color: ' + teamColor + '; font-weight: bold;">üèÜ</span>' +
                    '<span style="color: ' + teamColor + '; font-size: 0.9rem; font-weight: 500;">' + playerTeam.name + '</span>' +
                    (playerTeam.captainId && playerTeam.members.find(m => m.id === player.id && m.id === playerTeam.captainId) ? 
                        '<span style="color: #f59e0b;">üëë</span>' : '') +
                    '</div>';
            }

            playerCard.innerHTML = removeButtonHtml + '<div class="player-header">' +
                '<div class="player-name-section">' +
                '<input type="text" class="player-name" value="' + player.name + '" onchange="updatePlayerName(' + player.id + ', this.value)">' +
                '</div>' +
                '<div class="player-stats">' +
                '<div class="total-score">' + player.total + '</div>' +
                '<div class="score-details">' +
                'Avg: ' + player.average + '<br>Efficiency: ' + (player.percentage || 0) + '%<br>' +
                '<span class="yellow">üéØ ' + maxScoreLabel + ': ' + player.bullseyes + '</span><br>' +
                '<span class="purple">Score: ' + player.total + '/' + maxPossibleScore + '</span>' +
                (player.tripleNickels > 0 ? '<br><span class="red">üî• Triple Nickels: ' + player.tripleNickels + '</span>' : '') +
                (player.noDrops > 0 ? '<br><span class="green">üíé No Drops: ' + player.noDrops + '</span>' : '') +
                '</div></div></div>' +
                teamInfoHtml +
                '<div style="margin-bottom: 15px; padding: 10px; background: rgba(15, 23, 42, 0.5); border-radius: 8px; border: 1px solid #475569;">' +
                (gameState.distancesOnTop ? 
                    // Distances on top, Rounds on bottom
                    '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">' +
                    '<span style="font-size: 0.8rem; color: #94a3b8; font-weight: 500;">Distances:</span>' +
                    '<div style="display: flex; gap: 5px; flex-wrap: wrap;">' + distanceNavButtons + '</div></div>' +
                    '<div style="display: flex; align-items: center; gap: 10px;">' +
                    '<span style="font-size: 0.8rem; color: #94a3b8; font-weight: 500;">Rounds:</span>' +
                    '<div style="display: flex; gap: 5px; flex-wrap: wrap;">' + roundNavButtons + '</div></div>' :
                    // Default: Rounds on top, Distances on bottom
                    '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">' +
                    '<span style="font-size: 0.8rem; color: #94a3b8; font-weight: 500;">Rounds:</span>' +
                    '<div style="display: flex; gap: 5px; flex-wrap: wrap;">' + roundNavButtons + '</div></div>' +
                    '<div style="display: flex; align-items: center; gap: 10px;">' +
                    '<span style="font-size: 0.8rem; color: #94a3b8; font-weight: 500;">Distances:</span>' +
                    '<div style="display: flex; gap: 5px; flex-wrap: wrap;">' + distanceNavButtons + '</div></div>') +
                '</div>' +
                (isViewingPastRound ? '<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center; color: #a855f7; font-weight: 500; font-size: 0.9rem;">üìú Viewing Past Round ' + displayRound + '</div>' : '') +
                (isViewingFutureRound ? '<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center; color: #a855f7; font-weight: 500; font-size: 0.9rem;">üîÆ Viewing Future Round ' + displayRound + '</div>' : '') +
                (isViewingPastDistance ? '<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center; color: #a855f7; font-weight: 500; font-size: 0.9rem;">üìú Viewing Past Distance</div>' : '') +
                (isViewingFutureDistance ? '<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid #8b5cf6; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center; color: #a855f7; font-weight: 500; font-size: 0.9rem;">üîÆ Viewing Future Distance</div>' : '') +
                '<div class="score-input">' +
                '<label class="score-label">Points</label>' +
                '<div class="score-buttons" ' + (gameState.gameFinalized ? 'style="display: none;"' : 
                    (player.gameComplete && !(gameState.editingThrow && gameState.editingThrow.playerId === player.id)) ? 'style="display: none;"' : '') + '>' +
                scoreButtonsHtml + '</div>' +
                (player.gameComplete ? '<div style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1e293b; padding: 20px; border-radius: 12px; text-align: center; font-weight: bold; font-size: 1.1rem; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);">üèÜ GAME COMPLETED! üèÜ<br><span style="font-size: 0.9rem; margin-top: 8px; display: block;">Final Score: ' + player.total + ' points</span>' + (gameState.gameFinalized ? '<br><span style="font-size: 0.8rem; color: #7c2d12;">üîí Results Locked</span>' : '') + '</div>' : '') +
                '</div>' +
                '<div style="display: grid; grid-template-columns: repeat(' + Math.min(gameState.throwsPerRound, 6) + ', 1fr); gap: 8px; margin-top: 15px;">' +
                throwDisplayHtml + '</div>';
        }

        function renderTiebreakerPlayer(playerCard, player) {
            var tiebreakerRound = gameState.tiebreakerRound - 1;
            // Fix: Only 1 throw for sudden-death-podium, 3 throws for sudden-death-podium-match
            var throwsPerRound = 1; // Default
            if (gameState.tiebreakerMode === 'sudden-death-podium-match') {
                throwsPerRound = 3; // 3 throws for podium match
            } else if (gameState.tiebreakerMode === 'sudden-death-podium' || gameState.tiebreakerMode === 'sudden-death') {
                throwsPerRound = 1; // 1 throw for podium or sudden death
            } else {
                throwsPerRound = 3; // 3 throws for other modes
            }
            var tiebreakerScores = player.tiebreakerScores && player.tiebreakerScores[tiebreakerRound] ? 
                player.tiebreakerScores[tiebreakerRound] : Array(throwsPerRound).fill(null);
            
            var selectedScore = tiebreakerScores[player.tiebreakerCurrentThrow - 1];
            
            var scoreButtonsHtml = gameState.targetRings.slice().reverse().map(function(score) {
                var isSelected = selectedScore === score;
                var backgroundColor = getScoreColor(score);
                var textColor = getScoreTextColor(score);
                var borderStyle = isSelected ? 'border: 3px solid #fbbf24;' : 'border: 2px solid rgba(255,255,255,0.2);';
                var boxShadow = isSelected ? 'box-shadow: 0 0 15px rgba(251, 191, 36, 0.5);' : '';
                
                return '<button class="score-button" onclick="addScore(' + player.id + ', ' + score + ')" ' +
                       'style="background: ' + backgroundColor + '; color: ' + textColor + '; ' + borderStyle + ' ' + boxShadow + 
                       ' padding: 12px; border-radius: 8px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; font-size: 1.1rem; min-width: 45px; min-height: 45px;" ' +
                       'onmouseover="this.style.transform=\'scale(1.05)\'; this.style.boxShadow=\'0 4px 12px rgba(0,0,0,0.3)\'" ' +
                       'onmouseout="this.style.transform=\'scale(1)\'; this.style.boxShadow=\'' + boxShadow + '\'">' + 
                       score + '</button>';
            }).join('');

            var throwDisplayHtml = Array(throwsPerRound).fill(null).map(function(_, throwIndex) {
                var score = tiebreakerScores[throwIndex];
                var isCurrent = throwIndex === player.tiebreakerCurrentThrow - 1;
                
                var className = 'throw-box ';
                var backgroundColor = '';
                var textColor = 'white';
                var borderStyle = '';
                
                if (score !== null) {
                    className += 'completed';
                    backgroundColor = 'background: ' + getScoreColor(score) + ';';
                    textColor = getScoreTextColor(score);
                    borderStyle = 'border: 2px solid rgba(255,255,255,0.3);';
                } else if (isCurrent) {
                    className += 'current';
                    backgroundColor = 'background: linear-gradient(45deg, #3b82f6, #1d4ed8);';
                    textColor = 'white';
                    borderStyle = 'border: 3px solid #60a5fa;';
                } else {
                    className += 'empty';
                    backgroundColor = 'background: #475569;';
                    textColor = '#94a3b8';
                    borderStyle = 'border: 2px solid #64748b;';
                }
                
                var throwNum = throwIndex + 1;
                
                return '<div class="' + className + '" ' +
                       'style="padding: 15px; border-radius: 8px; text-align: center; font-weight: bold; cursor: pointer; ' +
                       'transition: all 0.3s ease; position: relative; ' + backgroundColor + ' color: ' + textColor + '; ' + borderStyle + '">' + 
                       (score !== null ? score : throwNum) + '</div>';
            }).join('');
            
            // Add remove button for tiebreaker players (though it should be hidden during tiebreaker)
            var removeButtonHtml = '';
            if (!gameState.gameFinalized && !gameState.inTiebreaker) {
                removeButtonHtml = '<button class="remove-button" onclick="removePlayer(' + player.id + ')" title="Remove ' + player.name + '">‚úï</button>';
            }
            
            playerCard.innerHTML = removeButtonHtml + '<div class="player-header">' +
                '<div class="player-name-section">' +
                '<input type="text" class="player-name" value="' + player.name + '" onchange="updatePlayerName(' + player.id + ', this.value)">' +
                '</div>' +
                '<div class="player-stats">' +
                '<div class="total-score">' + (player.tiebreakerTotal || 0) + '</div>' +
                '<div class="score-details">' +
                'Regular: ' + player.total + '<br>' +
                'Tiebreaker: ' + (player.tiebreakerTotal || 0) + '<br>' +
                '<span class="red">üî• Round ' + gameState.tiebreakerRound + '</span>' +
                '</div></div></div>' +
                '<div style="background: rgba(220, 38, 38, 0.1); border: 1px solid #ef4444; padding: 15px; border-radius: 10px; margin-bottom: 15px; text-align: center; color: #ef4444; font-weight: bold; font-size: 1.1rem;">üî• TIEBREAKER ROUND ' + gameState.tiebreakerRound + '</div>' +
                '<div class="score-input">' +
                '<label class="score-label">Points</label>' +
                '<div class="score-buttons" ' + (player.tiebreakerComplete ? 'style="display: none;"' : '') + '>' +
                scoreButtonsHtml + '</div>' +
                (player.tiebreakerComplete ? '<div style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1e293b; padding: 20px; border-radius: 12px; text-align: center; font-weight: bold; font-size: 1.1rem;">üèÜ TIEBREAKER COMPLETE!<br><span style="font-size: 0.9rem; margin-top: 8px; display: block;">Tiebreaker Score: ' + (player.tiebreakerTotal || 0) + ' points</span></div>' : '') +
                '</div>' +
                '<div style="display: grid; grid-template-columns: repeat(' + throwsPerRound + ', 1fr); gap: 8px; margin-top: 15px;">' +
                throwDisplayHtml + '</div>';
        }

        function arePreviousThrowsCompleted(player, roundNumber, distanceNumber, throwNumber) {
            var roundIndex = roundNumber - 1;
            var distanceIndex = distanceNumber - 1;
            
            // Check if all previous throws in the current round/distance are completed
            for (var t = 1; t < throwNumber; t++) {
                if (!player.scores[roundIndex] || 
                    !player.scores[roundIndex][distanceIndex] || 
                    player.scores[roundIndex][distanceIndex][t - 1] === null) {
                    return false;
                }
            }
            return true;
        }

        function isMostRecentScore(player, roundNumber, distanceNumber, throwNumber) {
            // Allow editing of all scores as long as the game is not finalized
            // Players can edit any score even after completing their game
            return !gameState.gameFinalized;
        }

        function canEnterScore(player, roundNumber, distanceNumber, throwNumber) {
            // Can always edit existing scores if game is not finalized
            if (gameState.gameFinalized) {
                return false;
            }
            
            // Check if this is an existing score that can be edited
            var roundIndex = roundNumber - 1;
            var distanceIndex = distanceNumber - 1;
            var throwIndex = throwNumber - 1;
            
            if (player.scores[roundIndex] && 
                player.scores[roundIndex][distanceIndex] && 
                player.scores[roundIndex][distanceIndex][throwIndex] !== null) {
                // This is an existing score - allow editing any previously completed score during active session
                // Players should be able to edit any score as many times as needed during an active session
                return isMostRecentScore(player, roundNumber, distanceNumber, throwNumber);
            }
            
            // For new scores, check if this is the next sequential position
            if (gameState.playMode === 'consecutive') {
                // Consecutive mode: complete all rounds at current distance before moving to next distance
                // Check if this is the current position
                if (roundNumber !== player.currentRound || distanceNumber !== player.currentDistance || throwNumber !== player.currentThrow) {
                    return false;
                }
                
                // Check if all previous throws in the current round/distance are completed
                return arePreviousThrowsCompleted(player, roundNumber, distanceNumber, throwNumber);
            } else {
                // Sequential mode: complete all distances in current round before moving to next round
                // Check if this is the current position
                if (roundNumber !== player.currentRound || distanceNumber !== player.currentDistance || throwNumber !== player.currentThrow) {
                    return false;
                }
                
                // Check if all previous throws in the current round/distance are completed
                return arePreviousThrowsCompleted(player, roundNumber, distanceNumber, throwNumber);
            }
        }

        function addScore(playerId, score) {
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (!player) return;

            // Check if we're in tiebreaker mode
            if (gameState.inTiebreaker) {
                addTiebreakerScore(playerId, score);
                return;
            }

            var roundIndex, distanceIndex, throwIndex;
            var wasEditingExistingScore = false;

            if (gameState.editingThrow && gameState.editingThrow.playerId === playerId) {
                roundIndex = gameState.editingThrow.round - 1;
                distanceIndex = gameState.editingThrow.distance - 1;
                throwIndex = gameState.editingThrow.throw - 1;
                wasEditingExistingScore = player.scores[roundIndex] && player.scores[roundIndex][distanceIndex] && player.scores[roundIndex][distanceIndex][throwIndex] !== null;
                
                // For existing scores, allow editing as long as game is not finalized
                // This ensures players can edit any previously completed score during active session
                if (wasEditingExistingScore) {
                    if (gameState.gameFinalized) {
                        showTimedNotification('‚ùå Cannot edit scores - game has been finalized!', 3000);
                        gameState.editingThrow = null;
                        renderPlayers();
                        return;
                    }
                    // Allow editing - no need to check canEnterScore for existing scores
                } else {
                    // For new scores, check if this entry is allowed
                    if (!canEnterScore(player, gameState.editingThrow.round, gameState.editingThrow.distance, gameState.editingThrow.throw)) {
                        gameState.editingThrow = null;
                        renderPlayers();
                        return;
                    }
                }
                
                gameState.editingThrow = null;
            } else {
                roundIndex = player.currentRound - 1;
                distanceIndex = player.currentDistance - 1;
                throwIndex = player.currentThrow - 1;
                
                // Check if this score entry is allowed
                if (!canEnterScore(player, player.currentRound, player.currentDistance, player.currentThrow)) {
                    // Check if previous throws are missing
                    if (!arePreviousThrowsCompleted(player, player.currentRound, player.currentDistance, player.currentThrow)) {
                    } else {
                    }
                    return;
                }
            }

            if (!player.scores[roundIndex]) {
                player.scores[roundIndex] = Array(gameState.distances.length).fill(null).map(function() { return Array(gameState.throwsPerRound).fill(null); });
            }
            if (!player.scores[roundIndex][distanceIndex]) {
                player.scores[roundIndex][distanceIndex] = Array(gameState.throwsPerRound).fill(null);
            }

            // Store the old score for comparison
            var oldScore = player.scores[roundIndex][distanceIndex][throwIndex];
            player.scores[roundIndex][distanceIndex][throwIndex] = score;

            // Force a complete refresh of the display
            if (wasEditingExistingScore) {
                // When editing, ensure the viewing position is maintained
                player.viewingRound = roundIndex + 1;
                player.viewingDistance = distanceIndex + 1;
            }

            // Recalculate player stats
            recalculatePlayerStats(player);

            // Advance player position only if this is a new score at the current position (not editing)
            if (!wasEditingExistingScore && roundIndex === player.currentRound - 1 && distanceIndex === player.currentDistance - 1 && throwIndex === player.currentThrow - 1) {
                if (gameState.playMode === 'consecutive') {
                    // Consecutive mode: complete all rounds at current distance before moving to next distance
                    if (player.currentThrow < gameState.throwsPerRound) {
                        player.currentThrow++;
                    } else {
                        // Reset throw counter
                        player.currentThrow = 1;
                        
                        if (player.currentRound < gameState.rounds) {
                            player.currentRound++;
                            player.viewingRound = player.currentRound;
                            
                            // Round completion notification removed
                        } else if (player.currentDistance < gameState.numDistances) {
                            player.currentDistance++;
                            player.currentRound = 1;
                            player.viewingDistance = player.currentDistance;
                            player.viewingRound = player.currentRound;
                            
                            var distanceName = gameState.distances[player.currentDistance - 1] || 'Distance ' + player.currentDistance;
                            // Distance advancement notification removed
                        } else {
                            player.gameComplete = true;
                            
                            // Update Track Progress window if open
                            if (trackProgressWindow && !trackProgressWindow.closed) {
                                setTimeout(updateTrackProgressWindow, 500);
                            }
                            
                            if (isEntireGameComplete()) {
                                // Show finalize button when all players complete
                                updateFinalizeButtonVisibility();
                                
                                // IMPORTANT: Don't auto-check for tiebreakers - wait for user choice
                                setTimeout(function() {
                                    promptGameFinalization();
                                }, 1500);
                            }
                        }
                    }
                } else {
                    // Sequential mode: complete all distances in current round before moving to next round
                    if (player.currentThrow < gameState.throwsPerRound) {
                        player.currentThrow++;
                    } else {
                        // Reset throw counter
                        player.currentThrow = 1;
                        
                        if (player.currentDistance < gameState.numDistances) {
                            player.currentDistance++;
                            player.viewingDistance = player.currentDistance;
                            
                            var distanceName = gameState.distances[player.currentDistance - 1] || 'Distance ' + player.currentDistance;
                            // Distance advancement notification removed
                        } else if (player.currentRound < gameState.rounds) {
                            player.currentRound++;
                            player.currentDistance = 1;
                            player.viewingRound = player.currentRound;
                            player.viewingDistance = player.currentDistance;
                            
                            // Round advancement notification removed
                        } else {
                            player.gameComplete = true;
                            
                            // Update Track Progress window if open
                            if (trackProgressWindow && !trackProgressWindow.closed) {
                                setTimeout(updateTrackProgressWindow, 500);
                            }
                            
                            if (isEntireGameComplete()) {
                                // IMPORTANT: Don't auto-check for tiebreakers - wait for user choice
                                setTimeout(function() {
                                    promptGameFinalization();
                                }, 1500);
                            }
                        }
                    }
                }
            } else if (wasEditingExistingScore) {
                // When editing, don't change the current position, just update the score
                // Keep the viewing position where the user was when they started editing
                // The viewing position should already be set correctly by the editThrow function
            }

            // Score notifications removed to avoid UI interference

            // Check for game completion
            if (player.gameComplete) {
                if (gameState.players.length === 1) {
                    // Show finalize button for single player
                    updateFinalizeButtonVisibility();
                    // Show confirmation for single player as well
                    setTimeout(function() {
                        promptGameFinalization();
                    }, 1500);
                } else {
                    player.gameComplete = true;
                    showTimedNotification('üèÜ ' + player.name + ' completed the walkback! Click any throw to edit.', 4000);
                    
                    // Update Track Progress window if open
                    if (trackProgressWindow && !trackProgressWindow.closed) {
                        setTimeout(updateTrackProgressWindow, 500);
                    }
                    
                    if (isEntireGameComplete()) {
                        // Show finalize button when all players complete
                        updateFinalizeButtonVisibility();
                        
                        // Show prompt to finalize instead of automatically checking for tiebreakers
                        setTimeout(function() {
                            promptGameFinalization();
                        }, 1500);
                    }
                }
            }

            renderPlayers();
            
            // Force an additional render to ensure display updates
            if (wasEditingExistingScore) {
                setTimeout(function() {
                    renderPlayers();
                }, 50);
            }
            
            // Update leaderboard if open
            refreshLeaderboardIfOpen();
            
            // Update track progress if open
            refreshTrackProgressIfOpen();
            
            updateAddPlayerButton(); // Update button state after scoring
            
            // Set tournament event to in-progress on the first score (but not when editing existing scores)
            if (!wasEditingExistingScore && !gameState.eventSetToInProgress) {
                // Check if we should attempt to update the event status
                if (gameState.playersImported && gameState.gameName) {
                    try {
                        // Call setTournamentEventInProgress which handles matching and status checking
                        // This function has better matching logic (exact + partial matching)
                        if (setTournamentEventInProgress()) {
                            gameState.eventSetToInProgress = true; // Flag to prevent multiple calls
                        } else {
                            // If it returns false, check if event is already in-progress
                            const events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
                            const matchingEvent = events.find(event => 
                                event.name.trim().toLowerCase() === gameState.gameName.trim().toLowerCase()
                            ) || events.find(event => {
                                const gameNameLower = gameState.gameName.trim().toLowerCase();
                                const eventNameLower = event.name.trim().toLowerCase();
                                return eventNameLower.includes(gameNameLower) || gameNameLower.includes(eventNameLower);
                            });
                            
                            if (matchingEvent && matchingEvent.status === 'in-progress') {
                                // Event is already in-progress, just set our flag
                                gameState.eventSetToInProgress = true;
                            }
                        }
                    } catch (error) {
                        console.error('Error setting tournament event to in-progress:', error);
                    }
                }
            }
            
            saveGameState(); // Auto-save after every score entry
        }

        function navigateToThrow(playerId, roundNumber, distanceNumber, throwNumber) {
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                player.currentRound = roundNumber;
                player.currentDistance = distanceNumber;
                player.currentThrow = throwNumber;
                player.viewingRound = roundNumber;
                player.viewingDistance = distanceNumber;
                gameState.editingThrow = null;
                updateGameDisplay();
                renderPlayers();
            }
        }

        function navigateToRound(playerId, roundNumber) {
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                player.viewingRound = roundNumber;
                // Keep current distance instead of defaulting to 1
                gameState.editingThrow = null;
                updateGameDisplay();
                renderPlayers();
            }
        }

        function navigateToDistance(playerId, roundNumber, distanceNumber) {
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                // Use the roundNumber parameter instead of calculating a default
                player.viewingRound = roundNumber;
                player.viewingDistance = distanceNumber;
                gameState.editingThrow = null;
                updateGameDisplay();
                renderPlayers();
            }
        }

        function editThrow(playerId, roundNumber, distanceNumber, throwNumber) {
            if (gameState.gameFinalized) {
                alert('Cannot edit scores - game has been finalized and results are locked!');
                return;
            }
            
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                // Check if this is an existing score that can be edited
                var roundIndex = roundNumber - 1;
                var distanceIndex = distanceNumber - 1;
                var throwIndex = throwNumber - 1;
                var isExistingScore = player.scores[roundIndex] && 
                                     player.scores[roundIndex][distanceIndex] && 
                                     player.scores[roundIndex][distanceIndex][throwIndex] !== null;
                
                // Allow editing any existing score during active session (game not finalized)
                if (isExistingScore && !gameState.gameFinalized) {
                    // This is an existing score - allow editing
                    gameState.editingThrow = {
                        playerId: playerId,
                        round: roundNumber,
                        distance: distanceNumber,
                        throw: throwNumber
                    };
                    player.viewingRound = roundNumber;
                    player.viewingDistance = distanceNumber;
                    renderPlayers();
                    
                    // Update leaderboard if open
                    refreshLeaderboardIfOpen();
                    return;
                }
                
                // For new scores or if validation fails, check with canEnterScore
                if (!canEnterScore(player, roundNumber, distanceNumber, throwNumber)) {
                    if (gameState.gameFinalized) {
                        showTimedNotification('‚ùå Cannot edit scores - game has been finalized!', 3000);
                    } else if (!isExistingScore) {
                        showTimedNotification('‚ùå Cannot enter score at this position. Complete previous rounds first.', 3000);
                    } else {
                        showTimedNotification('‚ùå Cannot edit this score.', 3000);
                    }
                    return;
                }
                
                gameState.editingThrow = {
                    playerId: playerId,
                    round: roundNumber,
                    distance: distanceNumber,
                    throw: throwNumber
                };
                player.viewingRound = roundNumber;
                player.viewingDistance = distanceNumber;
                renderPlayers();
                
                // Update leaderboard if open
                refreshLeaderboardIfOpen();
            }
        }

        function isRoundComplete(player, roundIndex) {
            if (!player.scores[roundIndex]) return false;
            
            if (gameState.playMode === 'consecutive') {
                // In Consecutive mode, a round is complete when the current distance for that round is complete
                // We need to check if the round has been completed at the current distance level
                var currentDistanceIndex = player.currentDistance - 1;
                
                // If we're past this round at the current distance, it's complete
                if (roundIndex < player.currentRound - 1) {
                    return true;
                }
                
                // If this is the current round, check if the current distance is complete
                if (roundIndex === player.currentRound - 1) {
                    return isDistanceComplete(player, roundIndex, currentDistanceIndex);
                }
                
                // Future rounds are not complete
                return false;
            } else {
                // Sequential mode: complete all distances in current round before moving to next round
                return player.scores[roundIndex].every(function(distance) {
                    return distance && distance.every(function(throwScore) {
                        return throwScore !== null;
                    });
                });
            }
        }

        function isDistanceComplete(player, roundIndex, distanceIndex) {
            if (!player.scores[roundIndex] || !player.scores[roundIndex][distanceIndex]) return false;
            
            return player.scores[roundIndex][distanceIndex].every(function(throwScore) {
                return throwScore !== null;
            });
        }

        function checkForTiebreaker() {
            console.log('üîç checkForTiebreaker() called');
            console.log('üîç DEBUG: === ENTERING checkForTiebreaker() ===');
            console.log('üîç DEBUG: Current tiebreaker mode:', gameState.tiebreakerMode);
            console.log('üîç DEBUG: Current inTiebreaker state:', gameState.inTiebreaker);
            console.log('üîç Checking for tiebreaker need...');
            
            if (gameState.tiebreakerMode === 'no-tiebreaker') {
                console.log('üîç No tiebreaker mode selected - proceeding to finalization');
                finalizeGame();
                return;
            }
            
            // STORE ORIGINAL REGULATION SCORES IMMEDIATELY WHEN REGULATION ENDS
            if (!gameState.originalRegulationScoresStored) {
                console.log('üîç DEBUG: === STORING ORIGINAL REGULATION SCORES ===');
                gameState.players.forEach(function(player) {
                    // Store the current total as the regulation score (before any tiebreaker points)
                    player.originalRegulationScore = player.total;
                    console.log('üîç DEBUG: ' + player.name + ': stored regulation score = ' + player.originalRegulationScore);
                });
                gameState.originalRegulationScoresStored = true;
                console.log('üîç DEBUG: Original regulation scores stored for all players');
                console.log('üîç DEBUG: ===========================================');
            }
            
            // Sort by regulation scores only (using stored original regulation scores)
            var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                var aRegulation = a.originalRegulationScore !== undefined ? a.originalRegulationScore : (a.total - (a.podiumTiebreakerPoints || 0));
                var bRegulation = b.originalRegulationScore !== undefined ? b.originalRegulationScore : (b.total - (b.podiumTiebreakerPoints || 0));
                return bRegulation - aRegulation; 
            });
            
            // Debug: Show current standings with regulation scores
            console.log('üîç DEBUG: Current standings (regulation scores only):');
            sortedPlayers.forEach(function(player, index) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                console.log((index + 1) + '. ' + player.name + ': ' + regulation + ' pts (total: ' + player.total + ', tb: ' + (player.podiumTiebreakerPoints || 0) + ')');
            });
            
            if (gameState.tiebreakerMode === 'sudden-death-podium' || gameState.tiebreakerMode === 'sudden-death-podium-match') {
                // Check for podium position ties (1st, 2nd, 3rd)
                checkPodiumTies(sortedPlayers);
            } else {
                // Standard tiebreaker - check for ties and handle multi-way ties appropriately
                var topScore = sortedPlayers[0].originalRegulationScore !== undefined ? sortedPlayers[0].originalRegulationScore : (sortedPlayers[0].total - (sortedPlayers[0].podiumTiebreakerPoints || 0));
                var tiedPlayers = sortedPlayers.filter(function(player) { 
                    var playerRegulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                    return playerRegulation === topScore; 
                });
                
                console.log('Top score:', topScore, 'Tied players:', tiedPlayers.length);
                
                if (tiedPlayers.length > 1) {
                    console.log('üî• TIE DETECTED! Starting tiebreaker...');
                    console.log('üîç DEBUG: About to call startTiebreaker() with players:', tiedPlayers.map(p => p.name));
                    
                    // For three-way ties, use multi-position tiebreaker to assign all positions
                    if (tiedPlayers.length === 3) {
                        console.log('üîç DEBUG: Three-way tie detected in standard mode - using multi-position tiebreaker');
                        startMultiPositionTiebreaker(tiedPlayers, ['first', 'second', 'third']);
                    } else {
                        startTiebreaker(tiedPlayers);
                    }
                    console.log('üîç DEBUG: Tiebreaker call completed');
                } else {
                    console.log('No tie - proceeding to finalization');
                    console.log('üîç DEBUG: About to call finalizeGame() from checkForTiebreaker()');
                    finalizeGame();
                }
            }
            console.log('üîç DEBUG: === EXITING checkForTiebreaker() ===');
        }

        function checkPodiumTies(sortedPlayers) {
            console.log('üèÜ Checking for podium position ties...');
            console.log('Current tiebreaker mode: ' + gameState.tiebreakerMode);
            
            // Original regulation scores should already be stored by checkForTiebreaker()
            console.log('üîç DEBUG: Using pre-stored regulation scores for tie detection');
            
            // Visual debugging for Electron
            console.log('üîç DEBUG: Checking podium ties. Mode: ' + gameState.tiebreakerMode);
            
            // Sort players by REGULATION scores only (excluding tiebreaker points)
            console.log('üîç DEBUG: Raw player data before regulation sorting:');
            sortedPlayers.forEach(function(player) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                console.log('  ' + player.name + ': total=' + player.total + ', podiumTiebreakerPoints=' + (player.podiumTiebreakerPoints || 0) + ', regulation=' + regulation);
            });
            
            var regulationSortedPlayers = sortedPlayers.slice().sort(function(a, b) {
                var aRegulation = a.originalRegulationScore !== undefined ? a.originalRegulationScore : (a.total - (a.podiumTiebreakerPoints || 0));
                var bRegulation = b.originalRegulationScore !== undefined ? b.originalRegulationScore : (b.total - (b.podiumTiebreakerPoints || 0));
                return bRegulation - aRegulation; // Higher scores first
            });
            
            console.log('üîç DEBUG: Players sorted by regulation scores:');
            regulationSortedPlayers.forEach(function(player, index) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                console.log('  ' + (index + 1) + '. ' + player.name + ': ' + regulation + ' pts (reg) + ' + (player.podiumTiebreakerPoints || 0) + ' pts (tb) = ' + player.total + ' pts (total)');
            });
            
            // Exclude players who have already won a podium position (not just participated in tiebreakers)
            var unresolvedPlayers = regulationSortedPlayers.filter(function(player) {
                var hasWonPosition = player.podiumTiebreakerInfo && player.podiumTiebreakerInfo.isWinner;
                if (hasWonPosition) {
                    console.log('üîç DEBUG: Excluding ' + player.name + ' - already won ' + player.podiumTiebreakerInfo.position + ' position');
                }
                return !hasWonPosition;
            });
            
            // Debug: Show which players are unresolved and their regulation scores
            console.log('üîç DEBUG: Unresolved players after filtering:');
            unresolvedPlayers.forEach(function(player, index) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                console.log('  ' + (index + 1) + '. ' + player.name + ': ' + regulation + ' pts (reg)');
            });

            console.log('üîç DEBUG: Unresolved players (by regulation score):', unresolvedPlayers.map(p => p.name + ' (' + (p.total - (p.podiumTiebreakerPoints || 0)) + ' pts reg)'));

            // Only consider the top 4 players for tiebreaker purposes
            // Players beyond 4th place can never be tied for podium positions (1st, 2nd, 3rd)
            // Take top 4 from regulation-sorted players BEFORE filtering out winners
            var topFourPlayers = regulationSortedPlayers.slice(0, 4);
            
            // Filter out any players from top 4 who have already won positions
            topFourPlayers = topFourPlayers.filter(function(player) {
                var hasWonPosition = player.podiumTiebreakerInfo && player.podiumTiebreakerInfo.isWinner;
                if (hasWonPosition) {
                    console.log('üîç DEBUG: Excluding ' + player.name + ' from top 4 - already won ' + player.podiumTiebreakerInfo.position + ' position');
                }
                return !hasWonPosition;
            });
            
            console.log('üîç DEBUG: Only considering top 4 players for tiebreakers:');
            console.log('üîç DEBUG: Total players in regulationSortedPlayers:', regulationSortedPlayers.length);
            console.log('üîç DEBUG: Top 4 players selected:');
            topFourPlayers.forEach(function(player, index) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                console.log('  ' + (index + 1) + '. ' + player.name + ': ' + regulation + ' pts (reg)');
            });
            
            // Debug: Show what the actual regulation scores are for all players
            console.log('üîç DEBUG: All players regulation scores:');
            regulationSortedPlayers.forEach(function(player, index) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                console.log('  ' + (index + 1) + '. ' + player.name + ': ' + regulation + ' pts (reg)');
            });
            
            // Determine actual final standings based on regulation scores for top 4 only
            var finalStandings = [];
            var currentPosition = 1;
            var currentScore = null;
            var playersAtCurrentScore = [];
            
            // Group top 4 players by regulation score and assign positions
            topFourPlayers.forEach(function(player) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                
                if (currentScore === null || regulation !== currentScore) {
                    // New score group - finalize previous group and start new one
                    if (currentScore !== null) {
                        // Add all players from previous score group to final standings
                        playersAtCurrentScore.forEach(function(p) {
                            finalStandings.push({
                                player: p,
                                position: currentPosition,
                                score: currentScore,
                                tied: playersAtCurrentScore.length > 1
                            });
                        });
                        currentPosition += playersAtCurrentScore.length;
                    }
                    
                    // Start new score group
                    currentScore = regulation;
                    playersAtCurrentScore = [player];
                } else {
                    // Same score as current group
                    playersAtCurrentScore.push(player);
                }
            });
            
            // Don't forget the last group
            if (currentScore !== null) {
                playersAtCurrentScore.forEach(function(p) {
                    finalStandings.push({
                        player: p,
                        position: currentPosition,
                        score: currentScore,
                        tied: playersAtCurrentScore.length > 1
                    });
                });
            }
            
            console.log('üîç DEBUG: Final standings determined for top 4 players:');
            finalStandings.forEach(function(standing) {
                console.log('  Position ' + standing.position + ': ' + standing.player.name + ' (' + standing.score + ' pts)' + (standing.tied ? ' - TIED' : ''));
            });
            
            // Debug: Show which players are being considered for each podium position
            console.log('üîç DEBUG: Players being considered for podium positions:');
            console.log('  Players in final standings:', finalStandings.length);
            console.log('  Top 4 players count:', topFourPlayers.length);
            
            // Find players tied for podium positions (1st, 2nd, 3rd place)
            var podiumTies = { first: [], second: [], third: [] };
            
            finalStandings.forEach(function(standing) {
                if (standing.position === 1 && standing.tied) {
                    podiumTies.first.push(standing.player);
                } else if (standing.position === 2 && standing.tied) {
                    podiumTies.second.push(standing.player);
                } else if (standing.position === 3 && standing.tied) {
                    podiumTies.third.push(standing.player);
                }
            });
            
            console.log('üîç DEBUG: Podium ties detected:');
            console.log('  1st place ties:', podiumTies.first.length, 'players:', podiumTies.first.map(p => p.name).join(', '));
            console.log('  2nd place ties:', podiumTies.second.length, 'players:', podiumTies.second.map(p => p.name).join(', '));
            console.log('  3rd place ties:', podiumTies.third.length, 'players:', podiumTies.third.map(p => p.name).join(', '));
            
            // Run tiebreakers only for actual podium position ties
            if (podiumTies.first.length > 1) {
                console.log('üîç DEBUG: Starting 1ST place tiebreaker with: ' + podiumTies.first.map(p => p.name).join(', '));
                startPodiumTiebreaker(podiumTies.first, 'first');
            } else if (podiumTies.second.length > 1) {
                console.log('üîç DEBUG: Starting 2ND place tiebreaker with: ' + podiumTies.second.map(p => p.name).join(', '));
                startPodiumTiebreaker(podiumTies.second, 'second');
            } else if (podiumTies.third.length > 1) {
                console.log('üîç DEBUG: Starting 3RD place tiebreaker with: ' + podiumTies.third.map(p => p.name).join(', '));
                startPodiumTiebreaker(podiumTies.third, 'third');
            } else {
                console.log('üîç DEBUG: No podium ties found, about to call finalizeGame() from checkPodiumTies');
                finalizeGame();
            }
            console.log('üîç DEBUG: === EXITING checkPodiumTies() ===');
        }

        function startPodiumTiebreaker(tiedPlayers, position) {
            // Capture standings before tiebreaker starts
            var sortedPlayers = gameState.players.slice().sort(function(a, b) {
                var aTotal = a.total + (a.podiumTiebreakerPoints || 0);
                var bTotal = b.total + (b.podiumTiebreakerPoints || 0);
                return gameState.isGolf ? aTotal - bTotal : bTotal - aTotal;
            });
            
            // Store the pre-tiebreaker standings with frozen player data
            gameState.preTiebreakerStandings = sortedPlayers.map(function(player, index) {
                // Use regulation scores only (excluding tiebreaker points)
                var regulationScore = player.total - (player.podiumTiebreakerPoints || 0);
                return {
                    rank: index + 1,
                    player: {
                        id: player.id,
                        name: player.name,
                        total: regulationScore, // Store regulation score only
                        average: player.average,
                        bullseyes: player.bullseyes,
                        tripleNickels: player.tripleNickels,
                        noDrops: player.noDrops,
                        percentage: player.percentage
                    },
                    total: regulationScore // Only regulation game score, no tiebreaker points
                };
            });
            
            gameState.inTiebreaker = true;
            gameState.tiebreakerRound = 1;
            gameState.tiebreakerPlayers = tiedPlayers;
            gameState.podiumPosition = position; // Track which position we're resolving
            
            console.log('üîç DEBUG: === TIEBREAKER STATE SET ===');
            console.log('üîç DEBUG: gameState.inTiebreaker set to:', gameState.inTiebreaker);
            console.log('üîç DEBUG: gameState.tiebreakerRound set to:', gameState.tiebreakerRound);
            console.log('üîç DEBUG: gameState.tiebreakerPlayers set to:', gameState.tiebreakerPlayers.map(p => p.name));
            console.log('üîç DEBUG: gameState.podiumPosition set to:', gameState.podiumPosition);
            console.log('üîç DEBUG: ===============================');
            
            // Store the position in a backup variable to ensure it's not lost
            gameState.currentTiebreakerPosition = position;
            
            // Store the position in a dedicated variable that won't get cleared
            gameState.resolvingTiebreakerPosition = position;
            console.log('üîç DEBUG: Stored resolvingTiebreakerPosition: ' + position);
            
            // Also store the position in the tiebreaker players so it's preserved
            tiedPlayers.forEach(function(player) {
                player.currentTiebreakerPosition = position;
                console.log('üîç DEBUG: Stored position ' + position + ' for player ' + player.name);
            });
            
            // Debug: Verify the position was stored correctly
            console.log('üîç DEBUG: === POSITION STORAGE VERIFICATION ===');
            console.log('üîç DEBUG: gameState.resolvingTiebreakerPosition: ' + gameState.resolvingTiebreakerPosition);
            console.log('üîç DEBUG: gameState.currentTiebreakerPosition: ' + gameState.currentTiebreakerPosition);
            console.log('üîç DEBUG: gameState.podiumPosition: ' + gameState.podiumPosition);
            console.log('üîç DEBUG: ===========================================');
            console.log('üî• PODIUM TIEBREAKER STARTED - Position:', position, 'Players:', tiedPlayers.length);
            
            console.log('Starting tiebreaker for position ' + position + ' with players:', tiedPlayers.map(p => p.name));
            console.log('Set gameState.podiumPosition to: ' + position);
            
            // Debug: Show regulation scores for tiebreaker players
            console.log('üîç DEBUG: Tiebreaker players regulation scores:');
            tiedPlayers.forEach(function(player) {
                var regulation = player.total - (player.podiumTiebreakerPoints || 0);
                console.log('  ' + player.name + ': ' + regulation + ' pts (reg) + ' + (player.podiumTiebreakerPoints || 0) + ' pts (tb) = ' + player.total + ' pts (total)');
            });
            
            // Debug: Verify the position is set correctly
            console.log('üîç DEBUG: startPodiumTiebreaker - Position: ' + gameState.podiumPosition);
            console.log('üîç DEBUG: Players: ' + tiedPlayers.map(p => p.name + ' (' + (p.total - (p.podiumTiebreakerPoints || 0)) + ' pts)').join(', '));
            
            // Visual debugging for Electron (reduced frequency)
            console.log('üîç DEBUG: startPodiumTiebreaker called with position: ' + position + ', players: ' + tiedPlayers.map(p => p.name).join(', '));
            
            // Debug: Show current allTiebreakerParticipants before starting new tiebreaker
            if (gameState.allTiebreakerParticipants && gameState.allTiebreakerParticipants.length > 0) {
                var debugMsg = 'Before starting ' + position + ' tiebreaker:\n';
                gameState.allTiebreakerParticipants.forEach(function(tb) {
                    debugMsg += tb.playerName + ': ' + tb.positionName + ' (' + tb.position + ') - ' + (tb.isWinner ? 'Winner' : 'Runner-up') + '\n';
                });
                console.log('üîç DEBUG: ' + debugMsg);
            }
            
            // Hide non-tied players
            gameState.players.forEach(function(player) {
                player.hiddenForTiebreaker = !tiedPlayers.some(function(tp) { 
                    return tp.id === player.id; 
                });
            });
            
            // Setup tiebreaker scoring for tied players (1 throw each for podium, 3 throws for podium round)
            var throwsPerRound = (gameState.tiebreakerMode === 'sudden-death-podium-match') ? 3 : 1;
            tiedPlayers.forEach(function(player) {
                if (!player.tiebreakerScores) {
                    player.tiebreakerScores = [];
                }
                player.tiebreakerScores.push(Array(throwsPerRound).fill(null)); // 1 or 3 throws based on mode
                player.tiebreakerComplete = false;
                player.tiebreakerCurrentThrow = 1;
                player.tiebreakerTotal = 0;
            });
            
                        var positionNames = {
                first: '1st Place',
                second: '2nd Place',
                third: '3rd Place'
            };
            
            var playerNames = tiedPlayers.map(function(p) { return p.name; }).join(', ');
            var throwsText = (gameState.tiebreakerMode === 'sudden-death-podium-match') ? 'Sudden Death Podium Round (3 throws each)' : 'Sudden Death (1 throw each)';
            showTimedNotification('üèÜ ' + positionNames[position].toUpperCase() + ' TIEBREAKER! ' + tiedPlayers.length + ' players tied for ' + positionNames[position] + ': ' + playerNames + '. ' + throwsText + '!', 6000);
            
            updateGameDisplay();
            renderPlayers();
            
            // Show frozen leaderboard if open
            if (leaderboardWindow && !leaderboardWindow.closed) {
                showFrozenLeaderboard();
            }
            
            // Show finalize button during tiebreaker
            updateFinalizeButtonVisibility();
            
            console.log('üîç DEBUG: === EXITING startPodiumTiebreaker() ===');
            console.log('üîç DEBUG: Final tiebreaker state:');
            console.log('üîç DEBUG: - inTiebreaker:', gameState.inTiebreaker);
            console.log('üîç DEBUG: - tiebreakerPlayers:', gameState.tiebreakerPlayers ? gameState.tiebreakerPlayers.map(p => p.name) : 'undefined');
            console.log('üîç DEBUG: - podiumPosition:', gameState.podiumPosition);
            console.log('üîç DEBUG: ===========================================');
            
            // Force a re-render to ensure tiebreaker UI is visible
            setTimeout(() => {
                console.log('üîç DEBUG: Forcing re-render after tiebreaker start');
                renderPlayers();
                updateGameDisplay();
            }, 100);
        }

        function startMultiPositionTiebreaker(tiedPlayers, positions) {
            console.log('üîç DEBUG: startMultiPositionTiebreaker called with players:', tiedPlayers.map(p => p.name), 'and positions:', positions);
            console.log('üîç DEBUG: Current gameState.inTiebreaker:', gameState.inTiebreaker);
            console.log('üîç DEBUG: Current gameState.tiebreakerMode:', gameState.tiebreakerMode);
            
            // Capture standings before tiebreaker starts
            var sortedPlayers = gameState.players.slice().sort(function(a, b) {
                var aTotal = a.total + (a.podiumTiebreakerPoints || 0);
                var bTotal = b.total + (b.podiumTiebreakerPoints || 0);
                return gameState.isGolf ? aTotal - bTotal : bTotal - aTotal;
            });
            
            // Store the pre-tiebreaker standings with frozen player data
            gameState.preTiebreakerStandings = sortedPlayers.map(function(player, index) {
                // Use regulation scores only (excluding tiebreaker points)
                var regulationScore = player.total - (player.podiumTiebreakerPoints || 0);
                return {
                    rank: index + 1,
                    player: {
                        id: player.id,
                        name: player.name,
                        total: regulationScore, // Store regulation score only
                        average: player.average,
                        bullseyes: player.bullseyes,
                        tripleNickels: player.tripleNickels,
                        noDrops: player.noDrops,
                        percentage: player.percentage
                    },
                    total: regulationScore // Only regulation game score, no tiebreaker points
                };
            });
            
            // Set up tiebreaker state
            gameState.inTiebreaker = true;
            gameState.tiebreakerRound = 1;
            gameState.tiebreakerPlayers = tiedPlayers;
            gameState.multiPositionTiebreaker = true; // Flag to indicate this is a multi-position tiebreaker
            gameState.multiPositionTiebreakerPositions = positions; // Store the positions to be assigned
            
            // Store the original regulation scores for all players before any tiebreaker points
            gameState.players.forEach(function(player) {
                if (player.originalRegulationScore === undefined) {
                    player.originalRegulationScore = player.total - (player.podiumTiebreakerPoints || 0);
                }
            });
            
            // Hide non-tied players
            gameState.players.forEach(function(player) {
                player.hiddenForTiebreaker = !tiedPlayers.some(function(tp) { 
                    return tp.id === player.id; 
                });
            });
            
            // Setup tiebreaker scoring for tied players (1 throw each for podium, 3 throws for podium round)
            var throwsPerRound = (gameState.tiebreakerMode === 'sudden-death-podium-match') ? 3 : 1;
            tiedPlayers.forEach(function(player) {
                if (!player.tiebreakerScores) {
                    player.tiebreakerScores = [];
                }
                player.tiebreakerScores.push(Array(throwsPerRound).fill(null)); // 1 or 3 throws based on mode
                player.tiebreakerComplete = false;
                player.tiebreakerCurrentThrow = 1;
                player.tiebreakerTotal = 0;
            });
            
            var positionNames = {
                first: '1st Place',
                second: '2nd Place',
                third: '3rd Place'
            };
            
            var playerNames = tiedPlayers.map(function(p) { return p.name; }).join(', ');
            var throwsText = (gameState.tiebreakerMode === 'sudden-death-podium-match') ? 'Sudden Death Podium Round (3 throws each)' : 'Sudden Death (1 throw each)';
            var positionsText = positions.map(function(pos) { return positionNames[pos]; }).join(', ');
            showTimedNotification('üèÜ MULTI-POSITION TIEBREAKER! ' + tiedPlayers.length + ' players tied for ' + positionsText + ': ' + playerNames + '. ' + throwsText + '!', 6000);
            
            updateGameDisplay();
            renderPlayers();
            
            // Show frozen leaderboard if open
            if (leaderboardWindow && !leaderboardWindow.closed) {
                showFrozenLeaderboard();
            }
            
            // Show finalize button during tiebreaker
            updateFinalizeButtonVisibility();
            
            console.log('üîç DEBUG: === EXITING startMultiPositionTiebreaker() ===');
            console.log('üîç DEBUG: Final tiebreaker state:');
            console.log('üîç DEBUG: - inTiebreaker:', gameState.inTiebreaker);
            console.log('üîç DEBUG: - tiebreakerPlayers:', gameState.tiebreakerPlayers ? gameState.tiebreakerPlayers.map(p => p.name) : 'undefined');
            console.log('üîç DEBUG: - multiPositionTiebreaker:', gameState.multiPositionTiebreaker);
            console.log('üîç DEBUG: - multiPositionTiebreakerPositions:', gameState.multiPositionTiebreakerPositions);
            console.log('üîç DEBUG: ===========================================');
            
            // Force a re-render to ensure tiebreaker UI is visible
            setTimeout(() => {
                console.log('üîç DEBUG: Forcing re-render after multi-position tiebreaker start');
                renderPlayers();
                updateGameDisplay();
            }, 100);
        }

        function startTiebreaker(tiedPlayers) {
            gameState.inTiebreaker = true;
            gameState.tiebreakerRound = 1;
            gameState.tiebreakerPlayers = tiedPlayers;
            console.log('üî• STANDARD TIEBREAKER STARTED - Players:', tiedPlayers.length);
            
            // Hide non-tied players
            gameState.players.forEach(function(player) {
                player.hiddenForTiebreaker = !tiedPlayers.some(function(tp) { 
                    return tp.id === player.id; 
                });
            });
            
            // Setup tiebreaker scoring for tied players
            var throwsPerRound = gameState.tiebreakerMode === 'sudden-death' ? 1 : 3;
            
            tiedPlayers.forEach(function(player) {
                if (!player.tiebreakerScores) {
                    player.tiebreakerScores = [];
                }
                player.tiebreakerScores.push(Array(throwsPerRound).fill(null));
                player.tiebreakerComplete = false;
                player.tiebreakerCurrentThrow = 1;
                player.tiebreakerTotal = 0;
            });
            
            var tiebreakerName = gameState.tiebreakerMode === 'sudden-death' ? 
                'Sudden Death (1 throw each)' : 
                'Sudden Death Round (3 throws each)';
            
            var playerNames = tiedPlayers.map(function(p) { return p.name; }).join(', ');
            showTimedNotification('üî• TIEBREAKER! ' + tiedPlayers.length + ' players tied with ' + tiedPlayers[0].total + ' points: ' + playerNames + '. Starting ' + tiebreakerName + '!', 6000);
            
            updateGameDisplay();
            renderPlayers();
            
            // Show frozen leaderboard if open
            if (leaderboardWindow && !leaderboardWindow.closed) {
                showFrozenLeaderboard();
            }
            
            // Show finalize button during tiebreaker
            updateFinalizeButtonVisibility();
            
            console.log('üîç DEBUG: === EXITING startTiebreaker() ===');
            console.log('üîç DEBUG: Final tiebreaker state:');
            console.log('üîç DEBUG: - inTiebreaker:', gameState.inTiebreaker);
            console.log('üîç DEBUG: - tiebreakerPlayers:', gameState.tiebreakerPlayers ? gameState.tiebreakerPlayers.map(p => p.name) : 'undefined');
            console.log('üîç DEBUG: ===========================================');
        }

        function addTiebreakerScore(playerId, score) {
            console.log('Adding tiebreaker score:', playerId, score);
            console.log('Current tiebreaker mode: ' + gameState.tiebreakerMode + ', podiumPosition: ' + gameState.podiumPosition);
            
            // Debug info moved to console only
            console.log('üîç DEBUG: addTiebreakerScore - Mode: ' + gameState.tiebreakerMode + ', Position: ' + gameState.podiumPosition);
            
            var player = gameState.tiebreakerPlayers.find(function(p) { return p.id === playerId; });
            if (!player) return;
            
            var currentRound = gameState.tiebreakerRound - 1;
            var currentThrow = player.tiebreakerCurrentThrow - 1;
            
            if (!player.tiebreakerScores[currentRound]) {
                var throwsPerRound = 1; // Default for podium tiebreakers
                if (gameState.tiebreakerMode === 'sudden-death-podium-match') {
                    throwsPerRound = 3; // 3 throws for podium round
                } else if (gameState.tiebreakerMode !== 'sudden-death-podium') {
                    throwsPerRound = gameState.tiebreakerMode === 'sudden-death' ? 1 : 3;
                }
                player.tiebreakerScores[currentRound] = Array(throwsPerRound).fill(null);
            }
            
            player.tiebreakerScores[currentRound][currentThrow] = score;
            
            // Calculate tiebreaker total
            player.tiebreakerTotal = 0;
            player.tiebreakerScores.forEach(function(round) {
                if (round) {
                    round.forEach(function(throwScore) {
                        if (throwScore !== null) {
                            player.tiebreakerTotal += throwScore;
                        }
                    });
                }
            });
            
            var throwsPerRound = 1; // Default for podium tiebreakers
            if (gameState.tiebreakerMode === 'sudden-death-podium-match') {
                throwsPerRound = 3; // 3 throws for podium round
            } else if (gameState.tiebreakerMode !== 'sudden-death-podium') {
                throwsPerRound = gameState.tiebreakerMode === 'sudden-death' ? 1 : 3;
            }
            
            // Advance throw/round
            if (player.tiebreakerCurrentThrow < throwsPerRound) {
                player.tiebreakerCurrentThrow++;
            } else {
                player.tiebreakerComplete = true;
                
                if (gameState.multiPositionTiebreaker && gameState.multiPositionTiebreakerPositions) {
                    var positionNames = {
                        first: '1st Place',
                        second: '2nd Place',
                        third: '3rd Place'
                    };
                    var positionsText = gameState.multiPositionTiebreakerPositions.map(function(pos) { return positionNames[pos]; }).join(', ');
                    console.log('Player completed multi-position tiebreaker - positions: ' + positionsText);
                    console.log('üîç DEBUG: Completed multi-position tiebreaker - Positions: ' + positionsText);
                } else if (gameState.tiebreakerMode === 'sudden-death-podium' || gameState.tiebreakerMode === 'sudden-death-podium-match') {
                    var positionNames = {
                        first: '1st Place',
                        second: '2nd Place',
                        third: '3rd Place'
                    };
                    var positionName = gameState.podiumPosition ? positionNames[gameState.podiumPosition] : 'Unknown Position';
                    console.log('Player completed tiebreaker - podiumPosition: ' + gameState.podiumPosition + ', positionName: ' + positionName);
                    console.log('üîç DEBUG: Completed tiebreaker - Mode: ' + gameState.tiebreakerMode + ', Position: ' + gameState.podiumPosition + ', PositionName: ' + positionName);
                } else {
                }
            }
            
            // Check if all tied players completed tiebreaker
            var allComplete = gameState.tiebreakerPlayers.every(function(p) { 
                return p.tiebreakerComplete; 
            });
            
            if (allComplete) {
                checkTiebreakerResults();
            }
            
            renderPlayers();
            
            // Update track progress if open
            refreshTrackProgressIfOpen();
        }

        function checkTiebreakerResults() {
            console.log('üîç Checking tiebreaker results...');
            
            // Sort by tiebreaker total
            var sortedTiedPlayers = gameState.tiebreakerPlayers.slice().sort(function(a, b) { 
                return (b.tiebreakerTotal || 0) - (a.tiebreakerTotal || 0); 
            });
            
            var topTiebreakerScore = sortedTiedPlayers[0].tiebreakerTotal || 0;
            var stillTiedPlayers = sortedTiedPlayers.filter(function(player) { 
                return (player.tiebreakerTotal || 0) === topTiebreakerScore; 
            });
            
            console.log('Tiebreaker top score:', topTiebreakerScore, 'Still tied:', stillTiedPlayers.length);
            
            if (stillTiedPlayers.length > 1) {
                // Still tied - continue tiebreaker
                gameState.tiebreakerRound++;
                
                stillTiedPlayers.forEach(function(player) {
                    var throwsPerRound = 1; // Default
                    if (gameState.tiebreakerMode === 'sudden-death-podium-match') {
                        throwsPerRound = 3; // 3 throws for podium round
                    } else if (gameState.tiebreakerMode === 'sudden-death-podium') {
                        throwsPerRound = 1; // 1 throw for podium
                    } else {
                        throwsPerRound = gameState.tiebreakerMode === 'sudden-death' ? 1 : 3;
                    }
                    player.tiebreakerScores.push(Array(throwsPerRound).fill(null));
                    player.tiebreakerComplete = false;
                    player.tiebreakerCurrentThrow = 1;
                });
                
                // Hide players who are no longer tied
                gameState.tiebreakerPlayers.forEach(function(player) {
                    player.hiddenForTiebreaker = !stillTiedPlayers.some(function(stp) { 
                        return stp.id === player.id; 
                    });
                });
                
                gameState.tiebreakerPlayers = stillTiedPlayers;
                
                
                updateGameDisplay();
                renderPlayers();
                
                // Update track progress if open
                refreshTrackProgressIfOpen();
            } else {
                // Tiebreaker resolved
                var winner = sortedTiedPlayers[0];
                
                // Check if this is a multi-position tiebreaker
                if (gameState.multiPositionTiebreaker && gameState.multiPositionTiebreakerPositions) {
                    console.log('üîç DEBUG: Multi-position tiebreaker resolved - assigning positions based on scores');
                    resolveMultiPositionTiebreaker(sortedTiedPlayers, gameState.multiPositionTiebreakerPositions);
                } else if (gameState.tiebreakerMode === 'sudden-death-podium' || gameState.tiebreakerMode === 'sudden-death-podium-match') {
                    // Handle podium tiebreaker resolution - pass the current position
                    var currentPosition = null;
                    // Try to get position from the dedicated resolving position first (most reliable)
                    if (gameState.resolvingTiebreakerPosition) {
                        currentPosition = gameState.resolvingTiebreakerPosition;
                        console.log('üîç DEBUG: Retrieved position from resolvingTiebreakerPosition: ' + currentPosition);
                    } else {
                        console.log('üîç DEBUG: No resolvingTiebreakerPosition found');
                    }
                    // Fallback to tiebreaker players
                    if (!currentPosition && gameState.tiebreakerPlayers && gameState.tiebreakerPlayers.length > 0) {
                        currentPosition = gameState.tiebreakerPlayers[0].currentTiebreakerPosition;
                        console.log('üîç DEBUG: Retrieved position from tiebreaker player: ' + currentPosition);
                    }
                    // Fallback to global variables if not found in players
                    if (!currentPosition) {
                        currentPosition = gameState.currentTiebreakerPosition;
                    }
                    if (!currentPosition) {
                        currentPosition = gameState.podiumPosition;
                    }
                    console.log('üîç DEBUG: About to resolve tiebreaker - currentPosition:', currentPosition, 'winner:', winner.name);
                    console.log('üîç DEBUG: gameState.podiumPosition at resolution:', gameState.podiumPosition);
                    console.log('üîç DEBUG: gameState.currentTiebreakerPosition at resolution:', gameState.currentTiebreakerPosition);
                    console.log('üîç DEBUG: gameState.resolvingTiebreakerPosition at resolution:', gameState.resolvingTiebreakerPosition);
                    console.log('üîç DEBUG: Tiebreaker players currentTiebreakerPosition:', gameState.tiebreakerPlayers.map(p => p.name + ':' + (p.currentTiebreakerPosition || 'null')).join(', '));
                    
                    // Debug: Show what position we're about to pass
                    console.log('üîç DEBUG: === ABOUT TO CALL resolvePodiumTiebreaker ===');
                    console.log('üîç DEBUG: Winner:', winner.name);
                    console.log('üîç DEBUG: Position being passed:', currentPosition);
                    console.log('üîç DEBUG: ===========================================');
                    console.log('üîç DEBUG: Winner regulation score:', (winner.total - (winner.podiumTiebreakerPoints || 0)));
                    console.log('üîç DEBUG: All tiebreaker players:');
                    gameState.tiebreakerPlayers.forEach(function(player) {
                        var regulation = player.total - (player.podiumTiebreakerPoints || 0);
                        console.log('  ' + player.name + ': ' + regulation + ' pts (reg) + ' + (player.podiumTiebreakerPoints || 0) + ' pts (tb) = ' + player.total + ' pts (total)');
                    });
                    // Test: If currentPosition is null, try to determine it from the winner's regulation score
                    if (!currentPosition) {
                        console.log('üîç DEBUG: currentPosition is null, trying to determine from winner score');
                        var winnerRegulation = winner.total - (winner.podiumTiebreakerPoints || 0);
                        var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                            var aRegulation = a.total - (a.podiumTiebreakerPoints || 0);
                            var bRegulation = b.total - (b.podiumTiebreakerPoints || 0);
                            return bRegulation - aRegulation; 
                        });
                        var firstPlaceScore = sortedPlayers[0].total - (sortedPlayers[0].podiumTiebreakerPoints || 0);
                        
                        if (winnerRegulation === firstPlaceScore) {
                            currentPosition = 'first';
                            console.log('üîç DEBUG: Determined position as first based on regulation score');
                        } else {
                            // Find second place score
                            var secondPlaceScore = null;
                            for (var i = 0; i < sortedPlayers.length; i++) {
                                var playerRegulation = sortedPlayers[i].total - (sortedPlayers[i].podiumTiebreakerPoints || 0);
                                if (playerRegulation < firstPlaceScore) {
                                    secondPlaceScore = playerRegulation;
                                    break;
                                }
                            }
                            if (winnerRegulation === secondPlaceScore) {
                                currentPosition = 'second';
                                console.log('üîç DEBUG: Determined position as second based on regulation score');
                            } else {
                                currentPosition = 'third';
                                console.log('üîç DEBUG: Determined position as third based on regulation score');
                            }
                        }
                    }
                    
                    resolvePodiumTiebreaker(winner, currentPosition);
                } else {
                    // Standard tiebreaker resolved
                    showTimedNotification('üèÜ TIEBREAKER RESOLVED! ' + winner.name + ' wins with ' + (winner.tiebreakerTotal || 0) + ' tiebreaker points!', 5000);
                    
                    setTimeout(function() {
                        finalizeGame();
                    }, 2000);
                }
            }
        }

        function resolvePodiumTiebreaker(winner, position) {
            // Immediate debugging at function entry
            console.log('üîç DEBUG: resolvePodiumTiebreaker ENTRY - winner:', winner.name, 'position parameter:', position);
            console.log('üîç DEBUG: Function call stack:', new Error().stack);
            var positionNames = {
                first: '1st Place',
                second: '2nd Place',
                third: '3rd Place'
            };
            
            // Use the passed position parameter, with multiple fallbacks
            if (!position) {
                // Try to get position from the dedicated resolving position first
                if (gameState.resolvingTiebreakerPosition) {
                    position = gameState.resolvingTiebreakerPosition;
                    console.log('üîç DEBUG: resolvePodiumTiebreaker - Got position from resolvingTiebreakerPosition: ' + position);
                } else {
                    console.log('üîç DEBUG: resolvePodiumTiebreaker - No resolvingTiebreakerPosition available');
                }
            } else {
                console.log('üîç DEBUG: resolvePodiumTiebreaker - Position passed as parameter: ' + position);
            }
            // Fallback to tiebreaker players if still no position
            if (!position && gameState.tiebreakerPlayers && gameState.tiebreakerPlayers.length > 0) {
                position = gameState.tiebreakerPlayers[0].currentTiebreakerPosition;
                console.log('üîç DEBUG: resolvePodiumTiebreaker - Got position from player: ' + position);
            }
            if (!position) {
                position = gameState.currentTiebreakerPosition; // Second fallback
            }
            if (!position) {
                position = gameState.podiumPosition; // Third fallback
            }
            
            // Visual debugging for Electron
            console.log('üîç DEBUG: resolvePodiumTiebreaker - Winner: ' + winner.name + ', Position: ' + position);
            
            // Comprehensive debugging to show all position sources
            console.log('üîç DEBUG: === POSITION DEBUGGING ===');
            console.log('üîç DEBUG: Passed position parameter: ' + position);
            console.log('üîç DEBUG: gameState.resolvingTiebreakerPosition: ' + gameState.resolvingTiebreakerPosition);
            console.log('üîç DEBUG: gameState.currentTiebreakerPosition: ' + gameState.currentTiebreakerPosition);
            console.log('üîç DEBUG: gameState.podiumPosition: ' + gameState.podiumPosition);
            console.log('üîç DEBUG: gameState.tiebreakerPlayers length: ' + (gameState.tiebreakerPlayers ? gameState.tiebreakerPlayers.length : 'null'));
            if (gameState.tiebreakerPlayers && gameState.tiebreakerPlayers.length > 0) {
                console.log('üîç DEBUG: First tiebreaker player currentTiebreakerPosition: ' + gameState.tiebreakerPlayers[0].currentTiebreakerPosition);
            }
            console.log('üîç DEBUG: === END POSITION DEBUGGING ===');
            
            // Additional debugging to show where the position came from
            var positionSource = 'unknown';
            if (gameState.tiebreakerPlayers && gameState.tiebreakerPlayers.length > 0 && gameState.tiebreakerPlayers[0].currentTiebreakerPosition) {
                positionSource = 'player.currentTiebreakerPosition';
            } else if (gameState.currentTiebreakerPosition) {
                positionSource = 'gameState.currentTiebreakerPosition';
            } else if (gameState.podiumPosition) {
                positionSource = 'gameState.podiumPosition';
            }
            console.log('üîç DEBUG: Position source: ' + positionSource + ' = ' + position);
            
            // If position is null, this is a serious error - we should never get here
            if (!position) {
                console.log('üîç DEBUG: Tiebreaker players: ' + gameState.tiebreakerPlayers.map(p => p.name).join(', '));
                console.log('üîç DEBUG: Winner: ' + winner.name);
                
                // Try to determine it from the original regulation standings (before any tiebreaker points)
                var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                    var aRegulation = a.total - (a.podiumTiebreakerPoints || 0);
                    var bRegulation = b.total - (b.podiumTiebreakerPoints || 0);
                    return bRegulation - aRegulation; 
                });
                
                // Show regulation standings
                var standingsMsg = 'Regulation standings:\n';
                sortedPlayers.forEach(function(player, index) {
                    var regulation = player.total - (player.podiumTiebreakerPoints || 0);
                    standingsMsg += (index + 1) + '. ' + player.name + ': ' + regulation + ' pts\n';
                });
                console.log('üîç DEBUG: ' + standingsMsg);
                
                // Find which position this tiebreaker was for based on regulation scores
                var winnerRegulation = winner.total - (winner.podiumTiebreakerPoints || 0);
                var firstPlaceRegulation = sortedPlayers[0].total - (sortedPlayers[0].podiumTiebreakerPoints || 0);
                
                if (winnerRegulation === firstPlaceRegulation) {
                    position = 'first';
                } else {
                    // Find the second place regulation score
                    var secondPlaceRegulation = null;
                    for (var i = 0; i < sortedPlayers.length; i++) {
                        var playerRegulation = sortedPlayers[i].total - (sortedPlayers[i].podiumTiebreakerPoints || 0);
                        if (playerRegulation < firstPlaceRegulation) {
                            secondPlaceRegulation = playerRegulation;
                            break;
                        }
                    }
                    
                    if (winnerRegulation === secondPlaceRegulation) {
                        position = 'second';
                    } else {
                        position = 'third';
                    }
                }
                console.log('üîç DEBUG: Determined position: ' + position + ' for ' + winner.name + ' (reg: ' + winnerRegulation + ' pts)');
            }

            // Find runner-ups (all other tiebreaker players except the winner)
            var lastTiebreakerPlayers = (gameState.tiebreakerPlayers || []).slice();
            var runnerUps = lastTiebreakerPlayers.filter(function(p) { return p.id !== winner.id; }).map(function(p) { return p.name; });
            
            console.log('Tiebreaker resolution - Position: ' + position + ', Winner: ' + winner.name + ', Runner-ups: ' + runnerUps.join(', '));
            console.log('All tiebreaker players: ' + lastTiebreakerPlayers.map(p => p.name).join(', '));
            
            // Only store tiebreaker data if there were actually multiple players in the tiebreaker (indicating a real tie was resolved)
            if (lastTiebreakerPlayers.length > 1) {
                if (!gameState.podiumTiebreakers) gameState.podiumTiebreakers = {};
                
                // Store the tiebreaker data for this position
                gameState.podiumTiebreakers[position] = {
                    winner: winner.name,
                    runnerUps: runnerUps
                };
                
                console.log('üîç DEBUG: Stored tiebreaker data for position: ' + position + ', winner: ' + winner.name + ', runners: ' + runnerUps.join(', '));
                console.log('üîç DEBUG: Current podiumTiebreakers keys: ' + Object.keys(gameState.podiumTiebreakers).join(', '));
                
                // Also store a backup copy to ensure data persistence
                if (!gameState.podiumTiebreakersBackup) gameState.podiumTiebreakersBackup = {};
                gameState.podiumTiebreakersBackup[position] = {
                    winner: winner.name,
                    runnerUps: runnerUps
                };
            }

            // Store tiebreaker points and position info for all participants before resetting
            console.log('Resolving tiebreaker for position ' + position + ' with players:', gameState.tiebreakerPlayers.map(p => p.name));
            console.log('Winner: ' + winner.name + ', Runner-ups: ' + runnerUps.join(', '));
            
            gameState.tiebreakerPlayers.forEach(function(player) {
                var playerTiebreakerPoints = player.tiebreakerTotal || 0;
                
                // Store tiebreaker points in a persistent property for export (replace, don't accumulate)
                player.podiumTiebreakerPoints = playerTiebreakerPoints;
                
                // Store which position this player tied for (only if not already set)
                if (!player.podiumTiebreakerPosition) {
                    player.podiumTiebreakerPosition = position;
                }
                
                // Create a unique key for this tiebreaker to avoid conflicts
                var tiebreakerKey = position + '_' + Date.now();
                
                // Store complete tiebreaker info for this player
                // IMPORTANT: Only store if this player doesn't already have tiebreaker data for a different position
                if (!player.podiumTiebreakerInfo || player.podiumTiebreakerInfo.position === position) {
                    player.podiumTiebreakerInfo = {
                        position: position,
                        positionName: positionNames[position],
                        points: playerTiebreakerPoints,
                        isWinner: player.id === winner.id,
                        winner: winner.name,
                        runnerUps: runnerUps.slice(), // Create a copy to avoid reference issues
                        tiebreakerKey: tiebreakerKey
                    };
                    
                    console.log('Stored tiebreaker info for ' + player.name + ': position=' + position + ', runnerUps=' + runnerUps.join(', ') + ', key=' + tiebreakerKey);
                } else {
                    console.log('Preserving existing tiebreaker data for ' + player.name + ': original position=' + player.podiumTiebreakerInfo.position + ', current position=' + position);
                }
                
                // Store tiebreaker data for this specific position in a multi-position array
                if (!player.podiumTiebreakerData) player.podiumTiebreakerData = [];
                
                // Check if we already have data for this position
                var existingPositionIndex = player.podiumTiebreakerData.findIndex(function(data) { return data.position === position; });
                if (existingPositionIndex >= 0) {
                    // Update existing data for this position
                    player.podiumTiebreakerData[existingPositionIndex] = {
                        position: position,
                        positionName: positionNames[position],
                        points: playerTiebreakerPoints,
                        isWinner: player.id === winner.id,
                        winner: winner.name,
                        runnerUps: runnerUps.slice(),
                        tiebreakerKey: tiebreakerKey
                    };
                } else {
                    // Add new data for this position
                    player.podiumTiebreakerData.push({
                        position: position,
                        positionName: positionNames[position],
                        points: playerTiebreakerPoints,
                        isWinner: player.id === winner.id,
                        winner: winner.name,
                        runnerUps: runnerUps.slice(),
                        tiebreakerKey: tiebreakerKey
                    });
                }
                
                console.log('Final tiebreaker data for ' + player.name + ': position=' + (player.podiumTiebreakerPosition || position) + ', points=' + playerTiebreakerPoints + ', isWinner=' + (player.id === winner.id) + ', runnerUps=' + (player.podiumTiebreakerInfo ? player.podiumTiebreakerInfo.runnerUps.join(', ') : 'none'));
            });
            
            // Also store this tiebreaker data in a global list to ensure we don't lose any data
            if (!gameState.allTiebreakerParticipants) gameState.allTiebreakerParticipants = [];
            
            // Visual debugging for Electron (reduced frequency)
            console.log('üîç DEBUG: Storing tiebreaker data for position: ' + position + ', players: ' + gameState.tiebreakerPlayers.map(p => p.name).join(', '));
            
            // Debug: Show current allTiebreakerParticipants before adding new data
            if (gameState.allTiebreakerParticipants && gameState.allTiebreakerParticipants.length > 0) {
                var debugMsg = 'Before adding new data:\n';
                gameState.allTiebreakerParticipants.forEach(function(tb) {
                    debugMsg += tb.playerName + ': ' + tb.positionName + ' (' + tb.position + ')\n';
                });
                console.log('üîç DEBUG: ' + debugMsg);
            }
            
            gameState.tiebreakerPlayers.forEach(function(player) {
                var existingIndex = gameState.allTiebreakerParticipants.findIndex(function(p) { return p.playerId === player.id && p.position === position; });
                if (existingIndex >= 0) {
                    // Update existing entry for this specific position
                    gameState.allTiebreakerParticipants[existingIndex] = {
                        playerId: player.id,
                        playerName: player.name,
                        position: position,
                        positionName: positionNames[position],
                        points: player.tiebreakerTotal || 0,
                        isWinner: player.id === winner.id,
                        winner: winner.name,
                        runnerUps: runnerUps.slice() // Create a copy to avoid reference issues
                    };
                    console.log('Updated tiebreaker participant: ' + player.name + ' for position: ' + position);
                    console.log('üîç DEBUG: Updated participant ' + player.name + ' for position: ' + position);
                } else {
                    // Add new entry
                    gameState.allTiebreakerParticipants.push({
                        playerId: player.id,
                        playerName: player.name,
                        position: position,
                        positionName: positionNames[position],
                        points: player.tiebreakerTotal || 0,
                        isWinner: player.id === winner.id,
                        winner: winner.name,
                        runnerUps: runnerUps.slice() // Create a copy to avoid reference issues
                    });
                    console.log('Added new tiebreaker participant: ' + player.name + ' for position: ' + position);
                    console.log('üîç DEBUG: Added new participant ' + player.name + ' for position: ' + position);
                }
                
                // Debug: Check if this player already has data for a different position
                var otherPositions = gameState.allTiebreakerParticipants.filter(function(p) { 
                    return p.playerId === player.id && p.position !== position; 
                });
                if (otherPositions.length > 0) {
                    var debugMsg = 'Player ' + player.name + ' already has data for other positions:\n';
                    otherPositions.forEach(function(p) {
                        debugMsg += '  ' + p.positionName + ' (' + p.position + ') - ' + (p.isWinner ? 'Winner' : 'Runner-up') + '\n';
                    });
                    console.log('üîç DEBUG: ' + debugMsg);
                }
            });
            
            console.log('All tiebreaker participants:', gameState.allTiebreakerParticipants);
            console.log('Tiebreaker data by position:');
            gameState.allTiebreakerParticipants.forEach(function(tb) {
                console.log('  ' + tb.playerName + ': ' + tb.positionName + ' (position: ' + tb.position + ') - ' + (tb.isWinner ? 'Winner' : 'Runner-up') + ' with ' + tb.points + ' points');
            });
            
            // Debug: Show final allTiebreakerParticipants after adding new data
            if (gameState.allTiebreakerParticipants && gameState.allTiebreakerParticipants.length > 0) {
                var debugMsg = 'After adding new data:\n';
                gameState.allTiebreakerParticipants.forEach(function(tb) {
                    debugMsg += tb.playerName + ': ' + tb.positionName + ' (' + tb.position + ') - ' + (tb.isWinner ? 'Winner' : 'Runner-up') + '\n';
                });
                console.log('üîç DEBUG: ' + debugMsg);
            }
            
            // Store tiebreaker points separately - don't add to total
            var winnerTiebreakerPoints = winner.tiebreakerTotal || 0;
            winner.podiumTiebreakerPoints = winnerTiebreakerPoints;
            
            showTimedNotification('üèÜ ' + positionNames[position].toUpperCase() + ' RESOLVED! ' + winner.name + ' wins with ' + winnerTiebreakerPoints + ' tiebreaker points!', 5000);
            
            // Store the current position before clearing tiebreaker players
            var resolvedPosition = position;
            console.log('üîç DEBUG: Stored resolved position: ' + resolvedPosition + ' before clearing tiebreaker players');
            
            // Reset tiebreaker state for all players
            gameState.players.forEach(function(player) {
                player.tiebreakerScores = [];
                player.tiebreakerTotal = 0;
                player.tiebreakerComplete = false;
                player.tiebreakerCurrentThrow = 1;
                player.hiddenForTiebreaker = false;
            });
            
            // Reset game tiebreaker state (but keep podiumPosition for now)
            gameState.inTiebreaker = false;
            gameState.tiebreakerPlayers = [];
            gameState.tiebreakerRound = 0;
            // Clear the resolving position after we've used it
            gameState.resolvingTiebreakerPosition = null;
            // Don't reset podiumPosition yet - it will be reset after all tiebreakers are done
            
            // Clear frozen standings to allow fresh leaderboard update
            gameState.preTiebreakerStandings = null;
            

            
            // Update display
            updateGameDisplay();
            renderPlayers();
            
            // Refresh leaderboard if open
            refreshLeaderboardIfOpen();
            
            // Refresh track progress if open
            refreshTrackProgressIfOpen();
            
            // Check if there are more podium positions to resolve
            setTimeout(function() {
                console.log('üîç DEBUG: About to check for remaining podium ties...');
                console.log('üîç DEBUG: Current podiumPosition before check: ' + gameState.podiumPosition);
                console.log('üîç DEBUG: Calling checkForRemainingPodiumTies after resolving position: ' + resolvedPosition);
                checkForRemainingPodiumTies();
            }, 2000);
            
            // Force refresh leaderboard to show updated standings
            setTimeout(function() {
                refreshLeaderboardIfOpen();
                refreshTrackProgressIfOpen();
            }, 1000);
        }

        function resolveMultiPositionTiebreaker(sortedTiedPlayers, positions) {
            console.log('üîç DEBUG: resolveMultiPositionTiebreaker called with players:', sortedTiedPlayers.map(p => p.name), 'and positions:', positions);
            
            var positionNames = {
                first: '1st Place',
                second: '2nd Place',
                third: '3rd Place'
            };
            
            // Assign positions based on tiebreaker scores (highest to lowest)
            var positionAssignments = {};
            sortedTiedPlayers.forEach(function(player, index) {
                if (index < positions.length) {
                    var position = positions[index];
                    positionAssignments[position] = player;
                    console.log('üîç DEBUG: Assigned ' + player.name + ' to ' + positionNames[position] + ' with ' + (player.tiebreakerTotal || 0) + ' tiebreaker points');
                }
            });
            
            // Store tiebreaker data for all participants
            sortedTiedPlayers.forEach(function(player, index) {
                var position = positions[index];
                var playerTiebreakerPoints = player.tiebreakerTotal || 0;
                
                // Store tiebreaker points
                player.podiumTiebreakerPoints = playerTiebreakerPoints;
                
                // Store position info
                player.podiumTiebreakerPosition = position;
                
                // Store complete tiebreaker info
                player.podiumTiebreakerInfo = {
                    position: position,
                    positionName: positionNames[position],
                    points: playerTiebreakerPoints,
                    isWinner: true, // All players in multi-position tiebreaker are "winners" of their assigned position
                    winner: player.name,
                    runnerUps: sortedTiedPlayers.filter(function(p) { return p.id !== player.id; }).map(function(p) { return p.name; }),
                    tiebreakerKey: position + '_' + Date.now() + '_' + player.id
                };
                
                // Store in multi-position array
                if (!player.podiumTiebreakerData) player.podiumTiebreakerData = [];
                player.podiumTiebreakerData.push({
                    position: position,
                    positionName: positionNames[position],
                    points: playerTiebreakerPoints,
                    isWinner: true,
                    winner: player.name,
                    runnerUps: sortedTiedPlayers.filter(function(p) { return p.id !== player.id; }).map(function(p) { return p.name; }),
                    tiebreakerKey: position + '_' + Date.now() + '_' + player.id
                });
                
                console.log('üîç DEBUG: Stored tiebreaker data for ' + player.name + ': position=' + position + ', points=' + playerTiebreakerPoints);
            });
            
            // Store in global tiebreaker participants
            if (!gameState.allTiebreakerParticipants) gameState.allTiebreakerParticipants = [];
            sortedTiedPlayers.forEach(function(player, index) {
                var position = positions[index];
                gameState.allTiebreakerParticipants.push({
                    playerId: player.id,
                    playerName: player.name,
                    position: position,
                    positionName: positionNames[position],
                    points: player.tiebreakerTotal || 0,
                    isWinner: true,
                    winner: player.name,
                    runnerUps: sortedTiedPlayers.filter(function(p) { return p.id !== player.id; }).map(function(p) { return p.name; })
                });
            });
            
            // Also store in podiumTiebreakers for victory screen compatibility
            if (!gameState.podiumTiebreakers) gameState.podiumTiebreakers = {};
            positions.forEach(function(position, index) {
                var player = sortedTiedPlayers[index];
                var runnerUps = sortedTiedPlayers.filter(function(p) { return p.id !== player.id; }).map(function(p) { return p.name; });
                gameState.podiumTiebreakers[position] = {
                    winner: player.name,
                    runnerUps: runnerUps
                };
            });
            
            // Show notification with all position assignments
            var assignmentText = positions.map(function(pos, index) {
                return positionNames[pos] + ': ' + sortedTiedPlayers[index].name + ' (' + (sortedTiedPlayers[index].tiebreakerTotal || 0) + ' pts)';
            }).join(', ');
            showTimedNotification('üèÜ MULTI-POSITION TIEBREAKER RESOLVED! ' + assignmentText, 6000);
            
            // Reset tiebreaker state for all players
            gameState.players.forEach(function(player) {
                player.tiebreakerScores = [];
                player.tiebreakerTotal = 0;
                player.tiebreakerComplete = false;
                player.tiebreakerCurrentThrow = 1;
                player.hiddenForTiebreaker = false;
            });
            
            // Reset game tiebreaker state
            gameState.inTiebreaker = false;
            gameState.tiebreakerPlayers = [];
            gameState.tiebreakerRound = 0;
            gameState.multiPositionTiebreaker = false;
            gameState.multiPositionTiebreakerPositions = null;
            gameState.preTiebreakerStandings = null;
            
            // Update display
            updateGameDisplay();
            renderPlayers();
            
            // Refresh leaderboard if open
            refreshLeaderboardIfOpen();
            
            // Refresh track progress if open
            refreshTrackProgressIfOpen();
            
            // Check if there are more podium positions to resolve
            // For three-way ties for first place, all podium positions are resolved
            if (positions.length === 3 && positions.includes('first') && positions.includes('second') && positions.includes('third')) {
                console.log('üîç DEBUG: Three-way tie for first place resolved - all podium positions assigned, proceeding to finalization');
                setTimeout(function() {
                    finalizeGame();
                }, 2000);
            } else {
                setTimeout(function() {
                    console.log('üîç DEBUG: About to check for remaining podium ties after multi-position resolution...');
                    checkForRemainingPodiumTies();
                }, 2000);
            }
            
            // Force refresh leaderboard to show updated standings
            setTimeout(function() {
                refreshLeaderboardIfOpen();
                refreshTrackProgressIfOpen();
            }, 1000);
        }

        function checkForRemainingPodiumTies() {
            console.log('üîç DEBUG: checkForRemainingPodiumTies called');
            console.log('üîç DEBUG: checkForRemainingPodiumTies called - checking for remaining ties');
            
            // Prevent infinite loops by tracking calls
            if (!gameState.remainingTiesCheckCount) {
                gameState.remainingTiesCheckCount = 0;
            }
            gameState.remainingTiesCheckCount++;
            console.log('üîç DEBUG: checkForRemainingPodiumTies call count:', gameState.remainingTiesCheckCount);
            
            // Safety check to prevent infinite loops
            if (gameState.remainingTiesCheckCount > 5) {
                console.log('üîç DEBUG: Too many remaining ties checks - forcing finalization to prevent infinite loop');
                gameState.remainingTiesCheckCount = 0;
                finalizeGame();
                return;
            }
            
            // SIMPLIFIED APPROACH: Just check if all top 3 positions are resolved
            var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                var aRegulation = a.originalRegulationScore !== undefined ? a.originalRegulationScore : (a.total - (a.podiumTiebreakerPoints || 0));
                var bRegulation = b.originalRegulationScore !== undefined ? b.originalRegulationScore : (b.total - (b.podiumTiebreakerPoints || 0));
                return bRegulation - aRegulation; 
            });
            
            console.log('üîç DEBUG: Current standings (top 4 only):');
            sortedPlayers.slice(0, 4).forEach(function(player, index) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                var hasWon = player.podiumTiebreakerInfo && player.podiumTiebreakerInfo.isWinner;
                console.log('  ' + (index + 1) + '. ' + player.name + ': ' + regulation + ' pts (won: ' + hasWon + ')');
            });
            
            // Check if top 3 positions are resolved
            var top3Resolved = 0;
            for (var i = 0; i < Math.min(3, sortedPlayers.length); i++) {
                var player = sortedPlayers[i];
                var hasWon = player.podiumTiebreakerInfo && player.podiumTiebreakerInfo.isWinner;
                if (hasWon) {
                    top3Resolved++;
                }
            }
            
            console.log('üîç DEBUG: Top 3 positions resolved:', top3Resolved + '/3');
            
            if (top3Resolved >= 3) {
                console.log('üîç DEBUG: All top 3 positions resolved - proceeding to finalization');
                gameState.remainingTiesCheckCount = 0;
                finalizeGame();
                return;
            }
            
            // If not all resolved, check for remaining ties in top 4 only
            var top4Players = sortedPlayers.slice(0, 4);
            var unresolvedPlayers = top4Players.filter(function(player) {
                var hasWon = player.podiumTiebreakerInfo && player.podiumTiebreakerInfo.isWinner;
                return !hasWon;
            });
            
            console.log('üîç DEBUG: Unresolved players in top 4:', unresolvedPlayers.map(p => p.name).join(', '));
            
            if (unresolvedPlayers.length === 0) {
                console.log('üîç DEBUG: No unresolved players - proceeding to finalization');
                gameState.remainingTiesCheckCount = 0;
                finalizeGame();
                return;
            }
            
            // Check for ties among unresolved players
            var ties = { first: [], second: [], third: [] };
            var currentPosition = 1;
            var currentScore = null;
            var playersAtCurrentScore = [];
            
            unresolvedPlayers.forEach(function(player) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                
                if (currentScore === null || regulation !== currentScore) {
                    // Finalize previous group
                    if (currentScore !== null && playersAtCurrentScore.length > 1) {
                        if (currentPosition === 1) ties.first = playersAtCurrentScore.slice();
                        else if (currentPosition === 2) ties.second = playersAtCurrentScore.slice();
                        else if (currentPosition === 3) ties.third = playersAtCurrentScore.slice();
                    }
                    
                    // Start new group
                    currentScore = regulation;
                    playersAtCurrentScore = [player];
                    currentPosition++;
                } else {
                    playersAtCurrentScore.push(player);
                }
            });
            
            // Finalize last group
            if (playersAtCurrentScore.length > 1) {
                if (currentPosition === 1) ties.first = playersAtCurrentScore.slice();
                else if (currentPosition === 2) ties.second = playersAtCurrentScore.slice();
                else if (currentPosition === 3) ties.third = playersAtCurrentScore.slice();
            }
            
            console.log('üîç DEBUG: Ties found - 1st:', ties.first.length, '2nd:', ties.second.length, '3rd:', ties.third.length);
            
            // Start tiebreaker for highest priority tie
            if (ties.third.length > 1) {
                console.log('üîç DEBUG: Starting 3rd place tiebreaker');
                gameState.remainingTiesCheckCount = 0;
                startPodiumTiebreaker(ties.third, 'third');
            } else if (ties.second.length > 1) {
                console.log('üîç DEBUG: Starting 2nd place tiebreaker');
                gameState.remainingTiesCheckCount = 0;
                startPodiumTiebreaker(ties.second, 'second');
            } else if (ties.first.length > 1) {
                console.log('üîç DEBUG: Starting 1st place tiebreaker');
                gameState.remainingTiesCheckCount = 0;
                startPodiumTiebreaker(ties.first, 'first');
            } else {
                console.log('üîç DEBUG: No ties found - proceeding to finalization');
                gameState.remainingTiesCheckCount = 0;
                finalizeGame();
            }
        }

        function promptGameFinalization() {
            console.log('üèÜ promptGameFinalization() called');
            showTimedNotification('üèÜ ALL PLAYERS FINISHED! Review scores and click "Finalize Game" when ready! üèÜ', 4000);
            
            // IMPORTANT: Only show modal, don't auto-finalize anything
            sortedPlayers.forEach(function(player, index) {
                var regulation = player.total - (player.podiumTiebreakerPoints || 0);
                console.log('  ' + (index + 1) + '. ' + player.name + ': ' + regulation + ' pts (regulation only)');
            });
            console.log('üîç DEBUG: ===============================');
            
            // Debug: Show current standings by regulation score
            var debugMsg = 'Current standings by regulation score:\n';
            sortedPlayers.forEach(function(player, index) {
                var regulation = player.total - (player.podiumTiebreakerPoints || 0);
                debugMsg += (index + 1) + '. ' + player.name + ': ' + regulation + ' pts (reg) + ' + (player.podiumTiebreakerPoints || 0) + ' pts (tb) = ' + player.total + ' pts (total)\n';
            });
            console.log('üîç DEBUG: ' + debugMsg);
            
            // Check for remaining podium ties
            var podiumTies = {
                first: [],
                second: [],
                third: []
            };
            
            // Only consider the top 4 players for remaining tiebreakers
            // Players beyond 4th place can never be tied for podium positions (1st, 2nd, 3rd)
            var topFourPlayers = sortedPlayers.slice(0, 4);
            
            console.log('üîç DEBUG: Only considering top 4 players for remaining tiebreakers:');
            console.log('üîç DEBUG: Total players in sortedPlayers:', sortedPlayers.length);
            console.log('üîç DEBUG: Top 4 players selected:');
            topFourPlayers.forEach(function(player, index) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                console.log('  ' + (index + 1) + '. ' + player.name + ': ' + regulation + ' pts (reg)');
            });
            
            // CRITICAL: Force exclusion of players beyond top 4
            console.log('üîç DEBUG: FORCING EXCLUSION of players beyond top 4:');
            sortedPlayers.forEach(function(player, index) {
                if (index >= 4) {
                    console.log('  EXCLUDED: ' + player.name + ' (position ' + (index + 1) + ') - beyond top 4');
                }
            });
            
            // Exclude players who have already won their podium position (not just participated in a tiebreaker)
            var unresolvedPlayers = topFourPlayers.filter(function(player) {
                var hasWonPosition = player.podiumTiebreakerInfo && player.podiumTiebreakerInfo.isWinner;
                var hasPodiumPosition = player.podiumTiebreakerPosition && ['first', 'second', 'third'].includes(player.podiumTiebreakerPosition);
                
                // Debug: Show each player's status
                console.log('üîç DEBUG: Player ' + player.name + ' - hasWonPosition:', hasWonPosition, 'hasPodiumPosition:', hasPodiumPosition, 'podiumTiebreakerInfo:', player.podiumTiebreakerInfo);
                
                if (hasWonPosition || hasPodiumPosition) {
                    console.log('üîç DEBUG: Excluding ' + player.name + ' from remaining ties - already won ' + (player.podiumTiebreakerInfo ? player.podiumTiebreakerInfo.position : player.podiumTiebreakerPosition) + ' position');
                }
                return !hasWonPosition && !hasPodiumPosition;
            });
            
            console.log('üîç DEBUG: Remaining unresolved players:', unresolvedPlayers.map(p => p.name + ' (' + (p.total - (p.podiumTiebreakerPoints || 0)) + ' pts reg)'));
            
            // Check if all podium positions have been assigned
            var assignedPodiumPositions = gameState.players.filter(function(player) {
                return player.podiumTiebreakerPosition && ['first', 'second', 'third'].includes(player.podiumTiebreakerPosition);
            });
            
            if (assignedPodiumPositions.length >= 3) {
                console.log('üîç DEBUG: All podium positions (1st, 2nd, 3rd) have been assigned - no more tiebreakers needed');
                console.log('üîç DEBUG: Assigned positions:', assignedPodiumPositions.map(p => p.name + ' (' + p.podiumTiebreakerPosition + ')').join(', '));
                finalizeGame();
                return;
            }
            
            // Debug: Show regulation scores for unresolved players in order
            console.log('üîç DEBUG: === UNRESOLVED PLAYERS BY REGULATION SCORE ===');
            unresolvedPlayers.forEach(function(player, index) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                console.log('  ' + (index + 1) + '. ' + player.name + ': ' + regulation + ' pts (reg)');
            });
            console.log('üîç DEBUG: ===========================================');
            
            // Debug: Show ALL players and their scores
            console.log('üîç DEBUG: === ALL PLAYERS SCORES ===');
            gameState.players.forEach(function(player) {
                var regulation = player.total - (player.podiumTiebreakerPoints || 0);
                var tiebreaker = player.podiumTiebreakerPoints || 0;
                var wonPosition = player.podiumTiebreakerInfo && player.podiumTiebreakerInfo.isWinner ? player.podiumTiebreakerInfo.position : 'none';
                console.log('  ' + player.name + ': reg=' + regulation + ', tb=' + tiebreaker + ', total=' + player.total + ', won=' + wonPosition);
            });
            console.log('üîç DEBUG: =========================');
            
            // Debug: Show which players were excluded and why
            var excludedPlayers = sortedPlayers.filter(function(player) {
                var hasWonPosition = player.podiumTiebreakerInfo && player.podiumTiebreakerInfo.isWinner;
                return hasWonPosition;
            });
            if (excludedPlayers.length > 0) {
                console.log('üîç DEBUG: Excluded players (already won positions):', excludedPlayers.map(p => p.name + ' (won ' + p.podiumTiebreakerInfo.position + ')').join(', '));
            } else {
                console.log('üîç DEBUG: No players excluded');
            }
            
            // Debug: Show all players and their status in remaining ties check
            console.log('üîç DEBUG: All players status in remaining ties check:');
            sortedPlayers.forEach(function(player, index) {
                var regulation = player.total - (player.podiumTiebreakerPoints || 0);
                console.log('  ' + (index + 1) + '. ' + player.name + ': total=' + player.total + ', regulation=' + regulation + ', tb=' + (player.podiumTiebreakerPoints || 0) + ', position=' + (player.podiumTiebreakerPosition || 'none'));
            });
            
            // Determine actual final standings based on regulation scores for top 4 only
            var finalStandings = [];
            var currentPosition = 1;
            var currentScore = null;
            var playersAtCurrentScore = [];
            
            // Group top 4 players by regulation score and assign positions
            topFourPlayers.forEach(function(player) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : (player.total - (player.podiumTiebreakerPoints || 0));
                
                if (currentScore === null || regulation !== currentScore) {
                    // New score group - finalize previous group and start new one
                    if (currentScore !== null) {
                        // Add all players from previous score group to final standings
                        playersAtCurrentScore.forEach(function(p) {
                            finalStandings.push({
                                player: p,
                                position: currentPosition,
                                score: currentScore,
                                tied: playersAtCurrentScore.length > 1
                            });
                        });
                        currentPosition += playersAtCurrentScore.length;
                    }
                    
                    // Start new score group
                    currentScore = regulation;
                    playersAtCurrentScore = [player];
                } else {
                    // Same score as current group
                    playersAtCurrentScore.push(player);
                }
            });
            
            // Don't forget the last group
            if (currentScore !== null) {
                playersAtCurrentScore.forEach(function(p) {
                    finalStandings.push({
                        player: p,
                        position: currentPosition,
                        score: currentScore,
                        tied: playersAtCurrentScore.length > 1
                    });
                });
            }
            
            console.log('üîç DEBUG: Final standings determined for remaining tiebreakers:');
            finalStandings.forEach(function(standing) {
                console.log('  Position ' + standing.position + ': ' + standing.player.name + ' (' + standing.score + ' pts)' + (standing.tied ? ' - TIED' : ''));
            });
            
            // Find players tied for podium positions (1st, 2nd, 3rd place)
            finalStandings.forEach(function(standing) {
                if (standing.position === 1 && standing.tied) {
                    podiumTies.first.push(standing.player);
                } else if (standing.position === 2 && standing.tied) {
                    podiumTies.second.push(standing.player);
                } else if (standing.position === 3 && standing.tied) {
                    podiumTies.third.push(standing.player);
                }
            });
            
            console.log('üîç DEBUG: Podium ties detected for remaining:');
            console.log('  1st place ties:', podiumTies.first.length, 'players:', podiumTies.first.map(p => p.name).join(', '));
            console.log('  2nd place ties:', podiumTies.second.length, 'players:', podiumTies.second.map(p => p.name).join(', '));
            console.log('  3rd place ties:', podiumTies.third.length, 'players:', podiumTies.third.map(p => p.name).join(', '));
            
            // Debug: Show why we might be in a loop
            var totalTies = podiumTies.first.length + podiumTies.second.length + podiumTies.third.length;
            console.log('üîç DEBUG: Total ties detected:', totalTies);
            if (totalTies === 0) {
                console.log('üîç DEBUG: No ties detected - should proceed to finalization');
            } else {
                console.log('üîç DEBUG: Ties detected - will start tiebreaker');
            }
            

            
            // Debug: Show what ties were found
            var tieDebugMsg = 'Ties found:\n';
            if (podiumTies.first.length > 1) {
                tieDebugMsg += '1st Place: ' + podiumTies.first.map(p => p.name).join(', ') + '\n';
            }
            if (podiumTies.second.length > 1) {
                tieDebugMsg += '2nd Place: ' + podiumTies.second.map(p => p.name).join(', ') + '\n';
            }
            if (podiumTies.third.length > 1) {
                tieDebugMsg += '3rd Place: ' + podiumTies.third.map(p => p.name).join(', ') + '\n';
            }
            if (tieDebugMsg === 'Ties found:\n') {
                tieDebugMsg += 'No ties found';
            }
            console.log('üîç DEBUG: ' + tieDebugMsg);
            
            // Additional debugging to show tie detection details
            console.log('üîç DEBUG: === TIE DETECTION DETAILS ===');
            console.log('üîç DEBUG: podiumTies.first.length:', podiumTies.first.length, 'players:', podiumTies.first.map(p => p.name).join(', '));
            console.log('üîç DEBUG: podiumTies.second.length:', podiumTies.second.length, 'players:', podiumTies.second.map(p => p.name).join(', '));
            console.log('üîç DEBUG: podiumTies.third.length:', podiumTies.third.length, 'players:', podiumTies.third.map(p => p.name).join(', '));
            console.log('üîç DEBUG: ===============================');
            
            // Visual debugging for tie detection
            var tieAlertMsg = 'Tie Detection Results:\n';
            tieAlertMsg += '1st place ties: ' + (podiumTies.first.length > 1 ? podiumTies.first.length + ' players (' + podiumTies.first.map(p => p.name).join(', ') + ')' : 'None') + '\n';
            tieAlertMsg += '2nd place ties: ' + (podiumTies.second.length > 1 ? podiumTies.second.length + ' players (' + podiumTies.second.map(p => p.name).join(', ') + ')' : 'None') + '\n';
            tieAlertMsg += '3rd place ties: ' + (podiumTies.third.length > 1 ? podiumTies.third.length + ' players (' + podiumTies.third.map(p => p.name).join(', ') + ')' : 'None') + '\n\n';
            tieAlertMsg += 'All Players:\n';
            gameState.players.forEach(function(player) {
                var regulation = player.originalRegulationScore !== undefined ? player.originalRegulationScore : player.total;
                var tiebreaker = player.podiumTiebreakerPoints || 0;
                var wonPosition = player.podiumTiebreakerInfo && player.podiumTiebreakerInfo.isWinner ? player.podiumTiebreakerInfo.position : 'none';
                tieAlertMsg += player.name + ': reg=' + regulation + ', tb=' + tiebreaker + ', won=' + wonPosition + '\n';
            });
            console.log('üîç DEBUG: ' + tieAlertMsg);
            
            // Debug: Show regulation scores for each position
            console.log('üîç DEBUG: Regulation scores by position:');
            if (podiumTies.first.length > 0) {
                var firstScore = sortedPlayers[0].total - (sortedPlayers[0].podiumTiebreakerPoints || 0);
                console.log('  1st place score:', firstScore, 'Players:', podiumTies.first.map(p => p.name).join(', '));
            }
            if (podiumTies.second.length > 0) {
                var secondScore = null;
                for (var i = 0; i < sortedPlayers.length; i++) {
                    var playerRegulation = sortedPlayers[i].total - (sortedPlayers[i].podiumTiebreakerPoints || 0);
                    var firstScore = sortedPlayers[0].total - (sortedPlayers[0].podiumTiebreakerPoints || 0);
                    if (playerRegulation < firstScore) {
                        secondScore = playerRegulation;
                        break;
                    }
                }
                console.log('  2nd place score:', secondScore, 'Players:', podiumTies.second.map(p => p.name).join(', '));
            }
            if (podiumTies.third.length > 0) {
                var thirdScore = null;
                var firstScore = sortedPlayers[0].total - (sortedPlayers[0].podiumTiebreakerPoints || 0);
                var secondScore = null;
                for (var i = 0; i < sortedPlayers.length; i++) {
                    var playerRegulation = sortedPlayers[i].total - (sortedPlayers[i].podiumTiebreakerPoints || 0);
                    if (playerRegulation < firstScore) {
                        secondScore = playerRegulation;
                        break;
                    }
                }
                if (secondScore !== null) {
                    for (var j = 0; j < sortedPlayers.length; j++) {
                        var playerRegulation = sortedPlayers[j].total - (sortedPlayers[j].podiumTiebreakerPoints || 0);
                        if (playerRegulation < secondScore) {
                            thirdScore = playerRegulation;
                            break;
                        }
                    }
                }
                console.log('  3rd place score:', thirdScore, 'Players:', podiumTies.third.map(p => p.name).join(', '));
            }
            
            // Determine which tiebreaker to start next (resolve lower positions first)
            if (podiumTies.third.length > 1) {
                console.log('üî• 3RD PLACE TIE! Starting tiebreaker...');
                console.log('üîç DEBUG: About to call startPodiumTiebreaker with position: third');
                // Reset the counter when starting a new tiebreaker
                gameState.remainingTiesCheckCount = 0;
                startPodiumTiebreaker(podiumTies.third, 'third');
            } else if (podiumTies.second.length > 1) {
                console.log('üî• 2ND PLACE TIE! Starting tiebreaker...');
                console.log('üîç DEBUG: About to call startPodiumTiebreaker with position: second');
                console.log('üîç DEBUG: Second place tie players:', podiumTies.second.map(p => p.name).join(', '));
                // Reset the counter when starting a new tiebreaker
                gameState.remainingTiesCheckCount = 0;
                startPodiumTiebreaker(podiumTies.second, 'second');
            } else if (podiumTies.first.length > 1) {
                console.log('üî• 1ST PLACE TIE! Starting tiebreaker...');
                console.log('üîç DEBUG: About to call startPodiumTiebreaker with position: first');
                console.log('üîç DEBUG: First place tie players:', podiumTies.first.map(p => p.name).join(', '));
                // Reset the counter when starting a new tiebreaker
                gameState.remainingTiesCheckCount = 0;
                startPodiumTiebreaker(podiumTies.first, 'first');
            } else {
                console.log('All podium positions resolved - proceeding to finalization');
                console.log('üîç DEBUG: Resetting podiumPosition to null - all tiebreakers complete');
                // Reset podiumPosition now that all tiebreakers are done
                gameState.podiumPosition = null;
                gameState.currentTiebreakerPosition = null;
                // Clear frozen standings and refresh leaderboard
                gameState.preTiebreakerStandings = null;
                refreshLeaderboardIfOpen();
                finalizeGame(); // Go directly to finalization after tiebreakers complete
            }
        }

        function promptGameFinalization() {
            console.log('üèÜ promptGameFinalization() called');
            showTimedNotification('üèÜ ALL PLAYERS FINISHED! Review scores and click "Finalize Game" when ready! üèÜ', 4000);
            
            // IMPORTANT: Only show modal, don't auto-finalize anything
            
            // Check if tiebreakers will be needed to customize the dialog
            var tiebreakerWillBeNeeded = false;
            var tiebreakerMessage = '';
            
            if (gameState.tiebreakerMode !== 'no-tiebreaker') {
                // Quick check for ties to customize the message
                var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                    return b.total - a.total; 
                });
                
                if (gameState.tiebreakerMode === 'sudden-death-podium' || gameState.tiebreakerMode === 'sudden-death-podium-match') {
                    // Check for podium ties (1st, 2nd, or 3rd place)
                    var scores = sortedPlayers.map(p => p.total);
                    var uniqueScores = [...new Set(scores)].sort((a, b) => b - a); // Sort descending
                    
                    // Check for ties in top 3 positions
                    var topScore = sortedPlayers[0].total;
                    var tiedForFirst = sortedPlayers.filter(p => p.total === topScore);
                    
                    if (tiedForFirst.length > 1) {
                        // Tie for first place
                        tiebreakerWillBeNeeded = true;
                        tiebreakerMessage = '\nüî• TIE DETECTED! ' + tiedForFirst.length + ' players tied for 1st place with ' + topScore + ' points.';
                    } else if (sortedPlayers.length >= 2) {
                        // Check for ties in 2nd place
                        var secondScore = null;
                        for (var i = 1; i < sortedPlayers.length; i++) {
                            if (sortedPlayers[i].total < topScore) {
                                secondScore = sortedPlayers[i].total;
                                break;
                            }
                        }
                        if (secondScore !== null) {
                            var tiedForSecond = sortedPlayers.filter(p => p.total === secondScore);
                            if (tiedForSecond.length > 1) {
                                tiebreakerWillBeNeeded = true;
                                tiebreakerMessage = '\nüî• TIE DETECTED! ' + tiedForSecond.length + ' players tied for 2nd place with ' + secondScore + ' points.';
                            } else if (sortedPlayers.length >= 3) {
                                // Check for ties in 3rd place
                                var thirdScore = null;
                                for (var j = 0; j < sortedPlayers.length; j++) {
                                    if (sortedPlayers[j].total < secondScore) {
                                        thirdScore = sortedPlayers[j].total;
                                        break;
                                    }
                                }
                                if (thirdScore !== null) {
                                    var tiedForThird = sortedPlayers.filter(p => p.total === thirdScore);
                                    if (tiedForThird.length > 1) {
                                        tiebreakerWillBeNeeded = true;
                                        tiebreakerMessage = '\nüî• TIE DETECTED! ' + tiedForThird.length + ' players tied for 3rd place with ' + thirdScore + ' points.';
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Standard tiebreaker mode - check for any ties
                    var topScore = sortedPlayers[0].total;
                    var tiedForFirst = sortedPlayers.filter(p => p.total === topScore);
                    if (tiedForFirst.length > 1) {
                        tiebreakerWillBeNeeded = true;
                        tiebreakerMessage = '\nüî• TIE DETECTED! ' + tiedForFirst.length + ' players tied for 1st place with ' + topScore + ' points.';
                    }
                }
            }
            
            var dialogMessage = 'üèÜ ALL PLAYERS HAVE COMPLETED THE WALKBACK!' + tiebreakerMessage + '\n\n';
            
            if (tiebreakerWillBeNeeded) {
                dialogMessage += 'Would you like to review scores first or proceed to tiebreakers?\n\n' +
                    'üìù Click "Review Scores" to review and edit scores\n' +
                    'üî• Click "Proceed to Tiebreaker" to resolve ties now\n\n' +
                    'Note: Once tiebreakers start, regulation scores are locked.';
            } else {
                dialogMessage += 'Would you like to review and edit any scores before finalizing the game?\n\n' +
                    '‚úÖ Click "Finalize Now" to lock in the results permanently\n' +
                    'üìù Click "Review Scores" to review and edit scores\n\n' +
                    'Note: Once finalized, scores cannot be changed.';
            }
            
            // Show confirmation dialog for finalization with dynamic button text
            if (tiebreakerWillBeNeeded) {
                var confirmButtonText = 'üìù Review Scores';
                var cancelButtonText = 'üî• Proceed to Tiebreaker';
                
                showFinalizationConfirm(
                    dialogMessage,
                    confirmButtonText,
                    cancelButtonText,
                    function() {
                        // User chose to review scores first
                        console.log('üìù User chose to review scores first');
                        console.log('üîç DEBUG: Review Scores callback executed - modal should be closed by showFinalizationConfirm');
                        showTimedNotification('üìù Review and edit scores as needed. Click "Finalize Game" button when ready to lock in results.', 5000);
                        
                        // Ensure modal is closed immediately
                        const remainingModals = document.querySelectorAll('div[style*="z-index: 10005"]');
                        console.log('üîç DEBUG: After Review Scores callback, remaining modals:', remainingModals.length);
                        if (remainingModals.length > 0) {
                            console.log('üîç DEBUG: Modal still visible, force removing immediately');
                            remainingModals.forEach(modal => {
                                console.log('üîç DEBUG: Force removing remaining modal:', modal);
                                modal.remove();
                            });
                        }
                    },
                    function() {
                        // User chose to proceed to tiebreakers
                        console.log('üî• User chose to proceed to tiebreakers');
                        console.log('üîç DEBUG: Modal onCancel callback executed - about to call startFinalizationProcess()');
                        
                        // Force remove any remaining modals to ensure they don't block the tiebreaker
                        const existingModals = document.querySelectorAll('[style*="z-index: 10005"]');
                        console.log('üîç DEBUG: Found existing modals:', existingModals.length);
                        existingModals.forEach(modal => {
                            console.log('üîç DEBUG: Force removing modal:', modal);
                            if (modal.parentNode) {
                                modal.parentNode.removeChild(modal);
                            } else if (document.body.contains(modal)) {
                                document.body.removeChild(modal);
                            }
                        });
                        
                        // Also try to remove by class or other selectors
                        const modalElements = document.querySelectorAll('div[style*="position: fixed"][style*="z-index: 10005"]');
                        console.log('üîç DEBUG: Found modal elements by style:', modalElements.length);
                        modalElements.forEach(modal => {
                            console.log('üîç DEBUG: Force removing modal element:', modal);
                            if (modal.parentNode) {
                                modal.parentNode.removeChild(modal);
                            } else if (document.body.contains(modal)) {
                                document.body.removeChild(modal);
                            }
                        });
                        
                        // Try to remove by any fixed positioning elements
                        const fixedElements = document.querySelectorAll('div[style*="position: fixed"]');
                        console.log('üîç DEBUG: Found fixed position elements:', fixedElements.length);
                        fixedElements.forEach(element => {
                            if (element.style.zIndex === '10005' || element.style.zIndex === '10005px') {
                                console.log('üîç DEBUG: Force removing fixed element:', element);
                                if (element.parentNode) {
                                    element.parentNode.removeChild(element);
                                } else if (document.body.contains(element)) {
                                    document.body.removeChild(element);
                                }
                            }
                        });
                        
                        // Final check - try to remove any elements that might be blocking
                        setTimeout(() => {
                            const remainingModals = document.querySelectorAll('div[style*="position: fixed"][style*="z-index: 10005"]');
                            console.log('üîç DEBUG: After removal, remaining modals:', remainingModals.length);
                            if (remainingModals.length > 0) {
                                console.log('üîç DEBUG: Still have modals, forcing removal again');
                                remainingModals.forEach(modal => {
                                    modal.remove();
                                });
                            }
                        }, 100);
                        
                        console.log('üîç DEBUG: About to call startFinalizationProcess()');
                        startFinalizationProcess();
                    }
                );
            } else {
                var confirmButtonText = '‚úÖ Finalize Now';
                var cancelButtonText = 'üìù Review Scores';
                
                showFinalizationConfirm(
                    dialogMessage,
                    confirmButtonText,
                    cancelButtonText,
                    function() {
                        // User confirmed immediate finalization
                        console.log('üèÜ User confirmed immediate finalization');
                        console.log('üîç DEBUG: Callback executing, checking for modals before finalizeGame...');
                        const modalsBefore = document.querySelectorAll('div[style*="z-index: 10005"]');
                        console.log('üîç DEBUG: Modals before finalizeGame:', modalsBefore.length);
                        
                        gameState.waitingForUserFinalizationChoice = false;
                        finalizeGame();
                        
                        console.log('üîç DEBUG: After finalizeGame, checking for modals...');
                        const modalsAfter = document.querySelectorAll('div[style*="z-index: 10005"]');
                        console.log('üîç DEBUG: Modals after finalizeGame:', modalsAfter.length);
                    },
                    function() {
                        // User chose to review scores first
                        console.log('üìù User chose to review scores first');
                        console.log('üîç DEBUG: Review Scores callback executed - modal should be closed by showFinalizationConfirm');
                        showTimedNotification('üìù Review and edit scores as needed. Click "Finalize Game" button when ready to lock in results.', 5000);
                        
                        // Ensure modal is closed immediately
                        const remainingModals = document.querySelectorAll('div[style*="z-index: 10005"]');
                        console.log('üîç DEBUG: After Review Scores callback, remaining modals:', remainingModals.length);
                        if (remainingModals.length > 0) {
                            console.log('üîç DEBUG: Modal still visible, force removing immediately');
                            remainingModals.forEach(modal => {
                                console.log('üîç DEBUG: Force removing remaining modal:', modal);
                                modal.remove();
                            });
                        }
                    }
                );
            }
            
            // IMPORTANT: Do NOT auto-finalize - wait for user choice in modal
            console.log('üîç DEBUG: promptGameFinalization completed - waiting for user choice');
            
            // DEBUG: Add a flag to prevent automatic finalization
            gameState.waitingForUserFinalizationChoice = true;
        }

        // Function to handle the finalization process including tiebreaker checking
        function startFinalizationProcess() {
            console.log('üèÜ Starting finalization process...');
            console.log('üîç DEBUG: startFinalizationProcess called - this should only happen from user button clicks');
            console.log('üîç DEBUG: Current gameState.inTiebreaker:', gameState.inTiebreaker);
            console.log('üîç DEBUG: Current gameState.waitingForUserFinalizationChoice:', gameState.waitingForUserFinalizationChoice);
            
            // Clear the waiting flag since user has made a choice
            gameState.waitingForUserFinalizationChoice = false;
            
            // Store regulation scores if not already stored
            if (!gameState.originalRegulationScoresStored) {
                gameState.players.forEach(function(player) {
                    player.originalRegulationScore = player.total;
                });
                gameState.originalRegulationScoresStored = true;
            }
            
            // Check if we're already in tiebreakers
            if (gameState.inTiebreaker) {
                console.log('üîç Already in tiebreakers, proceeding to finalization');
                console.log('üîç DEBUG: Already in tiebreakers, calling finalizeGame()');
                finalizeGame();
                return;
            }
            
            // Check if tiebreakers are needed based on current game state
            if (gameState.tiebreakerMode !== 'no-tiebreaker') {
                console.log('üîç Checking for tiebreakers before finalization...');
                
                // Use the SAME tie detection logic as promptGameFinalization for consistency
                var tiebreakerNeeded = false;
                
                if (gameState.tiebreakerMode === 'sudden-death-podium' || gameState.tiebreakerMode === 'sudden-death-podium-match') {
                    // Check for podium ties using the same logic as promptGameFinalization
                    var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                        return b.total - a.total; 
                    });
                    
                    var scores = sortedPlayers.map(p => p.total);
                    var uniqueScores = [...new Set(scores)].sort((a, b) => b - a); // Sort descending
                    
                    // Check for ties in top 3 positions
                    var topScore = sortedPlayers[0].total;
                    var tiedForFirst = sortedPlayers.filter(p => p.total === topScore);
                    
                    if (tiedForFirst.length > 1) {
                        // Tie for first place
                        tiebreakerNeeded = true;
                    } else if (sortedPlayers.length >= 2) {
                        // Check for ties in 2nd place
                        var secondScore = null;
                        for (var i = 1; i < sortedPlayers.length; i++) {
                            if (sortedPlayers[i].total < topScore) {
                                secondScore = sortedPlayers[i].total;
                                break;
                            }
                        }
                        if (secondScore !== null) {
                            var tiedForSecond = sortedPlayers.filter(p => p.total === secondScore);
                            if (tiedForSecond.length > 1) {
                                tiebreakerNeeded = true;
                            } else if (sortedPlayers.length >= 3) {
                                // Check for ties in 3rd place
                                var thirdScore = null;
                                for (var j = 0; j < sortedPlayers.length; j++) {
                                    if (sortedPlayers[j].total < secondScore) {
                                        thirdScore = sortedPlayers[j].total;
                                        break;
                                    }
                                }
                                if (thirdScore !== null) {
                                    var tiedForThird = sortedPlayers.filter(p => p.total === thirdScore);
                                    if (tiedForThird.length > 1) {
                                        tiebreakerNeeded = true;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Standard tiebreaker mode - check for any ties using the same logic
                    var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                        return b.total - a.total; 
                    });
                    
                    var topScore = sortedPlayers[0].total;
                    var tiedForFirst = sortedPlayers.filter(p => p.total === topScore);
                    if (tiedForFirst.length > 1) {
                        tiebreakerNeeded = true;
                    }
                }
                
                console.log('üîç Tiebreaker check result: tiebreakerNeeded =', tiebreakerNeeded);
                console.log('üîç Top scores:', sortedPlayers.map(p => p.name + ': ' + p.total).join(', '));
                
                if (tiebreakerNeeded) {
                    console.log('üî• Tiebreakers needed! Starting tiebreaker process...');
                    console.log('üîç DEBUG: About to call checkForTiebreaker() - this should start tiebreakers, not finalize');
                    console.log('üîç DEBUG: Tie detection details:');
                    console.log('üîç DEBUG: - tiebreakerMode:', gameState.tiebreakerMode);
                    console.log('üîç DEBUG: - players:', gameState.players.map(p => p.name + ': ' + p.total).join(', '));
                    
                    // Ensure any remaining modals are removed before starting tiebreaker
                    const remainingModals = document.querySelectorAll('div[style*="position: fixed"][style*="z-index: 10005"]');
                    console.log('üîç DEBUG: Removing remaining modals before tiebreaker:', remainingModals.length);
                    remainingModals.forEach(modal => {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    });
                    
                    checkForTiebreaker();
                    console.log('üîç DEBUG: checkForTiebreaker() completed - if you see this, tiebreakers should have started');
                    return; // Don't finalize yet - let tiebreakers complete first
                }
            } else {
                console.log('üîç DEBUG: No tiebreaker mode selected, proceeding to finalization');
                finalizeGame();
                return;
            }
            
            // No tiebreakers needed - proceed with finalization
            console.log('üèÜ No tiebreakers needed - proceeding to finalization');
            console.log('üîç DEBUG: No tie detected, proceeding to finalization');
            finalizeGame();
        }

        function finalizeGame() {
            console.log('üîç DEBUG: === ENTERING finalizeGame() ===');
            console.log('üîç DEBUG: Called from:', new Error().stack.split('\n')[2] || 'unknown location');
            console.log('üîç DEBUG: Current gameState.inTiebreaker:', gameState.inTiebreaker);
            console.log('üîç DEBUG: Current gameState.gameFinalized:', gameState.gameFinalized);
            
            // Guard: prevent double finalization
            if (gameFinalizedOnce) {
                console.log('‚ùå Game already finalized once, skipping...');
                return;
            }
            
            // Guard: prevent finalization if we're still waiting for user choice
            if (gameState.waitingForUserFinalizationChoice) {
                console.log('‚ùå Still waiting for user finalization choice, skipping automatic finalization');
                return;
            }
            
            gameFinalizedOnce = true;
            
            console.log('üèÜ Finalizing game...');
            console.log('Finalizing game - podiumTiebreakers before finalization:', gameState.podiumTiebreakers);
            gameState.gameFinalized = true;
            gameState.inTiebreaker = false;
            
            // Show all players again
            gameState.players.forEach(function(player) {
                player.hiddenForTiebreaker = false;
            });
            
            // Hide finalize button and show reset button
            var finalizeBtn = document.getElementById('finalizeBtn');
            if (finalizeBtn) {
                finalizeBtn.style.display = 'none';
            }
            
            var resetGameBtn = document.getElementById('resetGameBtn');
            if (resetGameBtn) {
                resetGameBtn.style.display = 'inline-block';
            }
            
            updateGameDisplay();
            renderPlayers();
            
            // Refresh leaderboard to show final standings
            refreshLeaderboardIfOpen();
            
            // Refresh track progress if open
            refreshTrackProgressIfOpen();
            
            showTimedNotification('üèÜ Walkback Game Finalized! Results are now locked.', 3000);
            
            // Update tournament status if players were imported from an event
            updateTournamentEventStatus();
            
            console.log('üèÜ About to auto-export and show victory screen in 2 seconds...');
            // Auto-export and show victory screen
            setTimeout(function() {
                console.log('üèÜ Executing auto-export first...');
                try {
                    exportData();
                    console.log('‚úÖ exportData() completed successfully');
                    
                    // Wait a moment for download to complete, then show victory screen
                    setTimeout(function() {
                        console.log('üèÜ Now showing victory screen...');
                        try {
                            // Only show victory screen if game is actually finalized
                            if (gameState.gameFinalized) {
                                showGameVictoryScreen();
                                console.log('‚úÖ showGameVictoryScreen() completed successfully');
                            } else {
                                console.log('‚ùå Game not finalized, skipping victory screen');
                            }
                        } catch (error) {
                            console.error('‚ùå Error in showGameVictoryScreen():', error);
                        }
                    }, 500); // Small delay to ensure download completes
                    
                } catch (error) {
                    console.error('‚ùå Error in exportData():', error);
                }
            }, 2000);
            
            console.log('üîç DEBUG: === EXITING finalizeGame() ===');
        }

        function storeGameReportForTournament(htmlContent, filename) {
            try {
                // Get events from localStorage
                const events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
                
                // Find the matching event
                let matchingEvent = events.find(event => 
                    event.name.trim().toLowerCase() === gameState.gameName.trim().toLowerCase()
                );
                
                // If no exact match, try partial matching
                if (!matchingEvent) {
                    const gameNameLower = gameState.gameName.trim().toLowerCase();
                    matchingEvent = events.find(event => {
                        const eventNameLower = event.name.trim().toLowerCase();
                        return eventNameLower.includes(gameNameLower) || gameNameLower.includes(eventNameLower);
                    });
                }
                
                if (matchingEvent) {
                    // Store the complete HTML report
                    matchingEvent.gameReport = {
                        htmlContent: htmlContent,
                        filename: filename,
                        exportDate: new Date().toISOString()
                    };
                    
                    // Save back to localStorage
                    localStorage.setItem('tournamentEvents', JSON.stringify(events));
                    
                    console.log(`üìÑ Game report stored for tournament event: ${matchingEvent.name}`);
                    return true;
                }
            } catch (error) {
                console.error('Error storing game report:', error);
            }
            return false;
        }

        function setTournamentEventInProgress() {
            // Only update if players were imported and we have a game name that matches an event
            if (!gameState.playersImported || !gameState.gameName) {
                console.log(`‚ùå Cannot set event to in-progress: playersImported=${gameState.playersImported}, gameName="${gameState.gameName}"`);
                return false;
            }
            
            try {
                // Get events from localStorage
                const events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
                console.log(`üîç Looking for event matching: "${gameState.gameName}" among ${events.length} events`);
                
                // Try exact match first (case-insensitive and trim whitespace)
                let matchingEvent = events.find(event => {
                    if (!event || !event.name) return false;
                    return event.name.trim().toLowerCase() === gameState.gameName.trim().toLowerCase();
                });
                
                // If no exact match, try partial matching
                if (!matchingEvent) {
                    const gameNameLower = gameState.gameName.trim().toLowerCase();
                    matchingEvent = events.find(event => {
                        if (!event || !event.name) return false;
                        const eventNameLower = event.name.trim().toLowerCase();
                        // Check if game name is contained in event name or vice versa
                        return eventNameLower.includes(gameNameLower) || gameNameLower.includes(eventNameLower);
                    });
                }
                
                if (matchingEvent) {
                    // Ensure status exists (events imported from JSON might not have status)
                    if (!matchingEvent.status) {
                        matchingEvent.status = 'pending';
                        console.log(`‚ö†Ô∏è Event "${matchingEvent.name}" had no status, setting to 'pending'`);
                    }
                    
                    console.log(`‚úÖ Found matching event: "${matchingEvent.name}" with status: "${matchingEvent.status}"`);
                    
                    // Set to in-progress if not already in-progress (allow from any status including completed)
                    // This handles events imported from JSON that may have different statuses
                    if (matchingEvent.status !== 'in-progress') {
                        const previousStatus = matchingEvent.status || 'unknown';
                        matchingEvent.status = 'in-progress';
                        
                        // Save the updated events back to localStorage
                        localStorage.setItem('tournamentEvents', JSON.stringify(events));
                        
                        // Update management displays if available
                        if (typeof updateTournamentSummary === 'function') {
                            updateTournamentSummary();
                        }
                        if (typeof updateEventsGrid === 'function') {
                            updateEventsGrid();
                        }
                        if (typeof updateEventsList === 'function') {
                            updateEventsList();
                        }
                        if (typeof forceRefreshOverview === 'function') {
                            forceRefreshOverview();
                        }
                        
                        console.log(`üîÑ Tournament event "${matchingEvent.name}" set to in-progress (was: ${previousStatus})`);
                        showTimedNotification(`üîÑ Tournament event "${matchingEvent.name}" is now in progress`, 3000);
                        return true;
                    } else {
                        console.log(`‚ÑπÔ∏è Event "${matchingEvent.name}" is already in-progress`);
                        return true; // Return true even if already in-progress - the game can proceed
                    }
                } else {
                    console.log(`‚ùå No matching event found for game name: "${gameState.gameName}"`);
                    console.log('Available events:', events.map(e => ({ name: e.name, status: e.status || 'undefined' })));
                    showTimedNotification(`‚ùå No tournament event found matching "${gameState.gameName}"`, 3000);
                }
                return false;
            } catch (error) {
                console.error('Error setting tournament event to in-progress:', error);
                return false;
            }
        }



        function updateTournamentEventStatus() {
            // Only update if players were imported and we have a game name that matches an event
            if (!gameState.playersImported || !gameState.gameName) {
                return false;
            }
            
            try {
                // Get events from localStorage
                const events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
                
                // Try exact match first (case-insensitive and trim whitespace)
                let matchingEvent = events.find(event => {
                    if (!event || !event.name) return false;
                    return event.name.trim().toLowerCase() === gameState.gameName.trim().toLowerCase();
                });
                
                // If no exact match, try partial matching
                if (!matchingEvent) {
                    const gameNameLower = gameState.gameName.trim().toLowerCase();
                    matchingEvent = events.find(event => {
                        if (!event || !event.name) return false;
                        const eventNameLower = event.name.trim().toLowerCase();
                        // Check if game name is contained in event name or vice versa
                        return eventNameLower.includes(gameNameLower) || gameNameLower.includes(eventNameLower);
                    });
                }
                
                if (matchingEvent) {
                    // Ensure status exists (events imported from JSON might not have status)
                    if (!matchingEvent.status) {
                        matchingEvent.status = 'pending';
                        console.log(`‚ö†Ô∏è Event "${matchingEvent.name}" had no status, setting to 'pending'`);
                    }
                    
                    console.log(`‚úÖ Found matching event: "${matchingEvent.name}" with status: "${matchingEvent.status}"`);
                    
                    // Check if event is already completed recently (within last 5 minutes)
                    let skipStatusUpdate = false;
                    if (matchingEvent.status === 'completed' && matchingEvent.dateCompleted) {
                        const lastCompleted = new Date(matchingEvent.dateCompleted);
                        const now = new Date();
                        const timeDiff = (now - lastCompleted) / (1000 * 60); // minutes
                        
                        // Only skip status update if completed very recently (likely same session)
                        if (timeDiff < 5) {
                            const currentPlayerIds = gameState.players.map(p => p.id).sort();
                            const storedPlayerIds = (matchingEvent.gameResults?.players || []).map(p => p.id).sort();
                            
                            // If same players AND completed recently, skip status update but still archive
                            if (JSON.stringify(currentPlayerIds) === JSON.stringify(storedPlayerIds)) {
                                console.log(`‚ÑπÔ∏è Tournament event "${matchingEvent.name}" completed recently with same players - skipping status update but will still archive`);
                                skipStatusUpdate = true;
                            }
                        }
                        
                        // Allow completion if enough time has passed or different players
                        if (!skipStatusUpdate) {
                            console.log(`üîÑ Tournament event "${matchingEvent.name}" allowing new completion`);
                        }
                    }
                    
                    // Store the game results for report generation (create new instance if different players)
                    const currentPlayerIds = gameState.players.map(p => p.id).sort();
                    const storedPlayerIds = (matchingEvent.gameResults?.players || []).map(p => p.id).sort();
                    const isNewInstance = JSON.stringify(currentPlayerIds) !== JSON.stringify(storedPlayerIds);
                    
                    // Update the event status to completed (always update dateCompleted when finalizing a game)
                    const completionDate = new Date().toISOString();
                    if (!skipStatusUpdate) {
                        if (matchingEvent.status !== 'completed') {
                            matchingEvent.status = 'completed';
                            matchingEvent.dateCompleted = completionDate;
                            
                            // Update management displays if available
                            if (typeof updateTournamentSummary === 'function') {
                                updateTournamentSummary();
                            }
                            if (typeof updateEventsGrid === 'function') {
                                updateEventsGrid();
                            }
                            if (typeof updateEventsList === 'function') {
                                updateEventsList();
                            }
                            if (typeof forceRefreshOverview === 'function') {
                                forceRefreshOverview();
                            }
                        } else {
                            // Even if already completed, update dateCompleted for this new game completion
                            matchingEvent.dateCompleted = completionDate;
                        }
                    } else {
                        // Still update dateCompleted even if skipping status update, for proper archiving
                        matchingEvent.dateCompleted = completionDate;
                    }
                    
                    if (isNewInstance) {
                        // Store multiple instances if this event has different player sets
                        if (!matchingEvent.gameInstances) {
                            matchingEvent.gameInstances = [];
                            // Move existing gameResults to instances array if it exists
                            if (matchingEvent.gameResults) {
                                matchingEvent.gameInstances.push(matchingEvent.gameResults);
                            }
                        }
                    }
                    
                    // Store the current game results
                    matchingEvent.gameResults = {
                        tournamentType: 'Walkback',
                        tournamentName: localStorage.getItem('tournamentName') || gameState.gameName || 'Walkback Tournament',
                        gameName: gameState.gameName,
                        gameType: gameState.gameType || 'walkback',
                        finalizedDate: new Date().toISOString(),
                        completed: true,
                        dateCompleted: completionDate,
                        players: gameState.players.map(player => ({
                            id: player.id,
                            name: player.name,
                            className: player.className || 'N/A',
                            divisionName: player.divisionName || 'N/A',
                            total: player.total,
                            finalPosition: player.finalPosition || 0,
                            scores: player.scores || [],
                            originalRegulationScore: player.originalRegulationScore || player.total,
                            tiebreakerPoints: player.tiebreakerPoints || 0,
                            podiumTiebreakerInfo: player.podiumTiebreakerInfo || null,
                            isEliminated: player.isEliminated || false,
                            // Add calculated stats for archive reports
                            average: player.average || 0,
                            percentage: player.percentage || 0,
                            bullseyes: player.bullseyes || 0,
                            tripleNickels: player.tripleNickels || 0,
                            noDrops: player.noDrops || 0,
                            // Add missing tiebreaker fields for archive
                            podiumTiebreakerPoints: player.podiumTiebreakerPoints || 0,
                            podiumTiebreakerPosition: player.podiumTiebreakerPosition || null,
                            podiumTiebreakerData: player.podiumTiebreakerData || []
                        })),
                        gameSettings: {
                            distances: gameState.distances || [],
                            throwsPerDistance: gameState.throwsPerDistance || 3,
                            tiebreakerMode: gameState.tiebreakerMode || 'no-tiebreaker',
                            rounds: gameState.rounds || 1,
                            numDistances: gameState.numDistances || 1,
                            maxScore: gameState.maxScore || 5,
                            playMode: gameState.playMode || 'consecutive'
                        },
                        podiumTiebreakers: gameState.podiumTiebreakers || {},
                        allTiebreakerParticipants: gameState.allTiebreakerParticipants || [],
                        gameFinalized: gameState.gameFinalized || false
                    };
                    
                    // Add current instance to instances array if this is a new instance
                    if (isNewInstance && matchingEvent.gameInstances) {
                        matchingEvent.gameInstances.push({
                            ...matchingEvent.gameResults,
                            instanceDate: new Date().toISOString()
                        });
                    }
                    
                    // Always save the updated events back to localStorage (even if status update was skipped)
                    // This ensures gameResults and dateCompleted are saved for archiving
                    localStorage.setItem('tournamentEvents', JSON.stringify(events));
                    
                    // Also save to permanent archive storage
                    try {
                        const archivedEvents = JSON.parse(localStorage.getItem('archivedEvents') || '[]');
                        
                        // Check if this exact game instance is already archived (avoid duplicates)
                        // Use gameResults.dateCompleted for comparison since that's the actual completion date of this game
                        const gameCompletionDate = matchingEvent.gameResults.dateCompleted;
                        const existingIndex = archivedEvents.findIndex(archived => 
                            archived.name === matchingEvent.name && 
                            archived.tournamentName === localStorage.getItem('tournamentName') &&
                            (archived.gameResults?.dateCompleted === gameCompletionDate || archived.dateCompleted === gameCompletionDate) &&
                            JSON.stringify((archived.gameResults?.players || []).map(p => p.id).sort()) === JSON.stringify(currentPlayerIds)
                        );
                        
                        // Create archive entry with tournament context - explicitly include gameResults
                        const archiveEntry = {
                            name: matchingEvent.name,
                            type: matchingEvent.type || 'walkback',
                            status: matchingEvent.status,
                            dateCompleted: matchingEvent.dateCompleted,
                            gameResults: matchingEvent.gameResults, // Explicitly include the gameResults
                            tournamentName: localStorage.getItem('tournamentName') || 'Unknown Tournament',
                            archivedDate: new Date().toISOString()
                        };
                        
                        if (existingIndex !== -1) {
                            // Update existing archive entry
                            archivedEvents[existingIndex] = archiveEntry;
                            console.log(`üì¶ Updated existing archive entry for event "${matchingEvent.name}"`);
                        } else {
                            // Add new archive entry
                            archivedEvents.push(archiveEntry);
                            console.log(`üì¶ Event "${matchingEvent.name}" archived permanently`);
                        }
                        
                        localStorage.setItem('archivedEvents', JSON.stringify(archivedEvents));
                    } catch (archiveError) {
                        console.error('Error archiving event:', archiveError);
                    }
                    
                    if (skipStatusUpdate) {
                        console.log(`‚úÖ Tournament event "${matchingEvent.name}" game results saved and archived (status update skipped - recently completed)`);
                        showTimedNotification(`üì¶ Tournament event "${matchingEvent.name}" game results archived`, 4000);
                    } else {
                        console.log(`‚úÖ Tournament event "${matchingEvent.name}" marked as completed and archived (matched game: "${gameState.gameName}")`);
                        showTimedNotification(`üèÜ Tournament event "${matchingEvent.name}" marked as completed and archived`, 4000);
                    }
                    return true;
                } else {
                    console.log(`‚ö†Ô∏è No matching event found for game name: "${gameState.gameName}"`);
                    console.log('Available events:', events.map(e => e.name));
                    return false;
                }
            } catch (error) {
                console.error('Error updating tournament event status:', error);
                return false;
            }
        }

        function checkTournamentEventStatus() {
            // Only check if players were imported and we have a game name
            if (!gameState.playersImported || !gameState.gameName) {
                showTimedNotification('‚ùå No imported players or game name found to check tournament status', 3000);
                return false;
            }
            
            try {
                // Get events from localStorage
                const events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
                
                // Try exact match first (case-insensitive and trim whitespace)
                let matchingEvent = events.find(event => 
                    event.name.trim().toLowerCase() === gameState.gameName.trim().toLowerCase()
                );
                
                // If no exact match, try partial matching
                if (!matchingEvent) {
                    const gameNameLower = gameState.gameName.trim().toLowerCase();
                    matchingEvent = events.find(event => {
                        const eventNameLower = event.name.trim().toLowerCase();
                        // Check if game name is contained in event name or vice versa
                        return eventNameLower.includes(gameNameLower) || gameNameLower.includes(eventNameLower);
                    });
                }
                
                if (matchingEvent) {
                    const statusText = matchingEvent.status === 'completed' ? 'Completed' : 
                                     matchingEvent.status === 'in-progress' ? 'In Progress' : 'Pending';
                    const statusIcon = matchingEvent.status === 'completed' ? '‚úÖ' : 
                                     matchingEvent.status === 'in-progress' ? 'üîÑ' : '‚è≥';
                    
                    let completionInfo = '';
                    if (matchingEvent.status === 'completed' && matchingEvent.dateCompleted) {
                        const completionDate = new Date(matchingEvent.dateCompleted);
                        completionInfo = `\nCompleted on: ${completionDate.toLocaleDateString()} at ${completionDate.toLocaleTimeString()}`;
                    }
                    
                    showTimedNotification(`${statusIcon} Event "${matchingEvent.name}" status: ${statusText}${completionInfo}`, 5000);
                    return true;
                } else {
                    showTimedNotification('‚ùå No matching tournament event found to check status', 3000);
                    return false;
                }
            } catch (error) {
                console.error('Error checking tournament event status:', error);
                showTimedNotification('‚ùå Error checking tournament event status', 3000);
                return false;
            }
        }

        function revertTournamentEventStatus() {
            // Only revert if players were imported and we have a game name that matches an event
            if (!gameState.playersImported || !gameState.gameName) {
                showTimedNotification('‚ùå No imported players or game name found to revert tournament status', 3000);
                return false;
            }
            
            try {
                // Get events from localStorage
                const events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
                
                // Try exact match first (case-insensitive and trim whitespace)
                let matchingEvent = events.find(event => 
                    event.name.trim().toLowerCase() === gameState.gameName.trim().toLowerCase()
                );
                
                // If no exact match, try partial matching
                if (!matchingEvent) {
                    const gameNameLower = gameState.gameName.trim().toLowerCase();
                    matchingEvent = events.find(event => {
                        const eventNameLower = event.name.trim().toLowerCase();
                        // Check if game name is contained in event name or vice versa
                        return eventNameLower.includes(gameNameLower) || gameNameLower.includes(eventNameLower);
                    });
                }
                
                if (matchingEvent) {
                    // Revert the event status to in-progress
                    matchingEvent.status = 'in-progress';
                    matchingEvent.dateCompleted = null;
                    
                    // Save the updated events back to localStorage
                    localStorage.setItem('tournamentEvents', JSON.stringify(events));
                    
                    // Update management displays if available
                    if (typeof updateTournamentSummary === 'function') {
                        updateTournamentSummary();
                    }
                    if (typeof updateEventsGrid === 'function') {
                        updateEventsGrid();
                    }
                    if (typeof updateEventsList === 'function') {
                        updateEventsList();
                    }
                    if (typeof forceRefreshOverview === 'function') {
                        forceRefreshOverview();
                    }
                    
                    console.log(`üîÑ Tournament event "${matchingEvent.name}" status reverted to in-progress`);
                    
                    // Show notification about the status update
                    showTimedNotification(`üîÑ Tournament event "${matchingEvent.name}" status reverted to in-progress`, 4000);
                    return true;
                } else {
                    console.log(`‚ö†Ô∏è No matching event found for game name: "${gameState.gameName}"`);
                    showTimedNotification('‚ùå No matching tournament event found to revert status', 3000);
                    return false;
                }
            } catch (error) {
                console.error('Error reverting tournament event status:', error);
                showTimedNotification('‚ùå Error reverting tournament event status', 3000);
                return false;
            }
        }

        function showGameVictoryScreen() {
            console.log('üèÜ showGameVictoryScreen() called');
            
            // Debug: Log the current tiebreaker data
            console.log('Current gameState.podiumTiebreakers:', gameState.podiumTiebreakers);
            console.log('Current gameState.allTiebreakerParticipants:', gameState.allTiebreakerParticipants);
            console.log('Players with podiumTiebreakerPoints:', gameState.players.filter(p => p.podiumTiebreakerPoints && p.podiumTiebreakerPoints > 0).map(p => ({name: p.name, points: p.podiumTiebreakerPoints, position: p.podiumTiebreakerPosition, info: p.podiumTiebreakerInfo})));
            
            // Debug info removed - issue identified and fixed
            
            // Debug: Check which positions actually had tiebreakers
            if (gameState.podiumTiebreakers) {
                Object.keys(gameState.podiumTiebreakers).forEach(function(position) {
                    var tb = gameState.podiumTiebreakers[position];
                    console.log('Position ' + position + ' tiebreaker:', tb);
                });
            }
            
            // Debug: Check comprehensive tiebreaker data
            if (gameState.allTiebreakerParticipants) {
                console.log('Comprehensive tiebreaker data:');
                gameState.allTiebreakerParticipants.forEach(function(tb) {
                    console.log('  ' + tb.playerName + ': ' + tb.positionName + ' - ' + (tb.isWinner ? 'Winner' : 'Runner-up') + ' with ' + tb.points + ' points');
                });
            }
            
            // Debug: Check each player's tiebreaker data
            console.log('Individual player tiebreaker data:');
            gameState.players.forEach(function(player) {
                if (player.podiumTiebreakerInfo) {
                    console.log('  ' + player.name + ': position=' + player.podiumTiebreakerInfo.position + ', runnerUps=' + player.podiumTiebreakerInfo.runnerUps.join(', ') + ', isWinner=' + player.podiumTiebreakerInfo.isWinner);
                }
            });
            
            var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                // Sort by regulation scores only - tiebreakers are only for breaking ties, not adding points
                return b.total - a.total;
            });
            
            // Create new window for victory screen
            console.log('üèÜ Creating victory window...');
            var windowFeatures = 'width=1400,height=1400,left=50,top=50,scrollbars=no,resizable=yes,location=no,menubar=no,toolbar=no';
            victoryWindow = window.open('', 'victory', windowFeatures);
            
            if (!victoryWindow) {
                console.error('‚ùå Popup blocked! Victory window could not be created.');
                alert('Pop-up blocked! Please allow pop-ups for this site to view the victory screen.');
                return;
            }
            
            console.log('‚úÖ Victory window created successfully');
            
            // Build enhanced podium layout
            var podiumHtml = '';
            if (sortedPlayers.length >= 1) {
                var maxPossibleScore = gameState.rounds * gameState.numDistances * gameState.throwsPerRound * gameState.maxScore;
                var maxScoreLabel = gameState.maxScore === 5 ? 'Bullseyes' : 'Max Scores';
                
                podiumHtml += '<div style="margin-bottom: 1vh; flex-shrink: 0;"><h3 style="font-size: clamp(1.2rem, 3vw, 1.8rem); color: #f1f5f9; margin-bottom: 1vh; padding-bottom: 0.5vh; border-bottom: 0.3vh solid #fbbf24; text-align: center; display: flex; align-items: center; justify-content: center; gap: 1vw;"><span style="font-size: clamp(1rem, 2.5vw, 1.5rem);">üèÜ</span>Final Results</h3></div>';
                
                // Enhanced podium with proper positioning - better scaling for expanded windows
                podiumHtml += '<div id="podiumResults" style="display: flex; justify-content: center; align-items: flex-end; gap: clamp(1vw, 3vw, 4vw); margin: 2vh 0; flex-wrap: wrap; flex: 1; min-height: 0; max-height: 60vh;">';
                
                // Generate podium cards for top 3
                var topThree = sortedPlayers.slice(0, 3);
                var podiumOrder = [1, 0, 2]; // 2nd, 1st, 3rd for proper podium arrangement
                
                podiumOrder.forEach(function(playerIndex, displayIndex) {
                    if (topThree[playerIndex]) {
                        var player = topThree[playerIndex];
                        // Find the actual rank of this player in the sorted list
                        var actualRank = sortedPlayers.findIndex(function(p) { return p.id === player.id; }) + 1;
                        var rank = actualRank;
                        var medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : 'ü•â';
                        var place = rank === 1 ? '1st Place' : rank === 2 ? '2nd Place' : '3rd Place';
                        var regulationScore = player.total; // player.total should be regulation only
                        var tiebreakerScore = player.podiumTiebreakerPoints || 0;
                        var playerTotal = regulationScore + tiebreakerScore;
                        var cardClass = rank === 1 ? 'podium-first' : rank === 2 ? 'podium-second' : 'podium-third';
                        var cardStyle = '';
                        var nameStyle = '';
                        var statValueStyle = '';
                        if (rank === 1) {
                            cardStyle = 'border: 0.4vh solid #fbbf24; background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), #1e293b, rgba(251, 191, 36, 0.1)); box-shadow: 0 2vh 4vh rgba(0, 0, 0, 0.5), 0 0 2vh rgba(251, 191, 36, 0.4); animation: championGlow 2s ease-in-out infinite alternate; transform: scale(1.05); transform-origin: bottom; height: 55vh; order: 2;';
                            nameStyle = 'font-size: clamp(1.2rem, 2.5vw, 1.6rem); color: #fbbf24; text-shadow: 0 0.2vh 0.4vh rgba(251, 191, 36, 0.5);';
                            statValueStyle = 'color: #fbbf24;';
                        } else if (rank === 2) {
                            cardStyle = 'border: 0.3vh solid #94a3b8; background: linear-gradient(135deg, rgba(148, 163, 184, 0.15), #1e293b); box-shadow: 0 1.5vh 3vh rgba(0, 0, 0, 0.4), 0 0 2vh rgba(148, 163, 184, 0.3); transform: scale(1.0); transform-origin: bottom; height: 50vh; order: 1;';
                            nameStyle = 'color: #cbd5e1; text-shadow: 0 0.2vh 0.4vh rgba(148, 163, 184, 0.5);';
                            statValueStyle = 'color: #cbd5e1;';
                        } else {
                            cardStyle = 'border: 0.3vh solid #d97706; background: linear-gradient(135deg, rgba(217, 119, 6, 0.15), #1e293b); box-shadow: 0 1vh 2.5vh rgba(0, 0, 0, 0.4), 0 0 1.5vh rgba(217, 119, 6, 0.3); transform: scale(0.98); transform-origin: bottom; height: 45vh; order: 3;';
                            nameStyle = 'color: #fdba74; text-shadow: 0 0.2vh 0.4vh rgba(217, 119, 6, 0.5);';
                            statValueStyle = 'color: #fdba74;';
                        }
                        
                        // Get team information for this player
                        var playerTeam = getPlayerTeam(player.name);
                        var teamInfoHtml = '';
                        if (playerTeam) {
                            var teamColor = playerTeam.color || '#3b82f6'; // Default to blue if no color
                            teamInfoHtml = '<div style="margin: 0.5vh 0; padding: 0.4vh 0.8vw; background: ' + teamColor + '33; border: 1px solid ' + teamColor + '; border-radius: 0.4vh; display: inline-flex; align-items: center; gap: 0.4vw; font-size: clamp(0.5rem, 1.2vw, 0.8rem); flex-shrink: 0;">' +
                                '<span style="color: ' + teamColor + ';">üèÜ</span>' +
                                '<span style="color: ' + teamColor + '; font-weight: 500;">' + playerTeam.name + '</span>' +
                                (playerTeam.captainId && playerTeam.members.find(m => m.id === player.id && m.id === playerTeam.captainId) ? 
                                    '<span style="color: #f59e0b;">üëë</span>' : '') +
                                '</div>';
                        }

                        podiumHtml += '<div class="podium-card ' + cardClass + '" style="background: linear-gradient(135deg, #334155 0%, #475569 100%); border-radius: 1vh; padding: 1.5vh 1vw; width: clamp(200px, 20vw, 350px); display: flex; flex-direction: column; justify-content: space-between; transition: all 0.3s ease; position: relative; overflow: hidden; ' + cardStyle + '">' +
                            '<div class="podium-player-info" style="color: #e2e8f0; text-align: center; height: 100%; display: flex; flex-direction: column; justify-content: space-between;">' +
                                '<div class="podium-medal" style="font-size: clamp(1.8rem, 4vw, ' + (rank === 1 ? '3.5rem' : '3rem') + '); margin-bottom: 0.5vh; filter: drop-shadow(0 0.4vh 0.8vh rgba(0, 0, 0, 0.3)); flex-shrink: 0;">' + medal + '</div>' +
                                '<div class="podium-player-name" style="font-size: clamp(1rem, 2vw, 1.3rem); font-weight: bold; margin-bottom: 0.3vh; text-shadow: 0 0.2vh 0.4vh rgba(0, 0, 0, 0.3); flex-shrink: 0; ' + nameStyle + '">' + player.name + '</div>' +
                                teamInfoHtml +
                                '<div class="podium-place" style="font-size: clamp(0.7rem, 1.5vw, 1rem); margin-bottom: 0.8vh; font-weight: bold; text-transform: uppercase; letter-spacing: 0.1em; flex-shrink: 0; ' + (rank === 1 ? 'color: #fbbf24; font-size: clamp(0.8rem, 1.7vw, 1.1rem); text-shadow: 0 0.2vh 0.4vh rgba(251, 191, 36, 0.5);' : rank === 2 ? 'color: #94a3b8;' : 'color: #d97706;') + '">' + place + '</div>';
                        // Tiebreaker indicator and runner-up(s) - only show for positions that actually went to tiebreaker
                        var tbKey = (rank === 1 ? 'first' : rank === 2 ? 'second' : 'third');
                        
                        // Check if this position actually had a tiebreaker by looking at the comprehensive data
                        var shouldShowTiebreaker = false;
                        var tiebreakerRunnerUps = [];
                        
                        if (gameState.allTiebreakerParticipants && gameState.allTiebreakerParticipants.length > 0) {
                            // Check if any players participated in a tiebreaker for this position
                            var positionTbData = gameState.allTiebreakerParticipants.filter(function(tb) { 
                                return tb.position === tbKey; 
                            });
                            
                            if (positionTbData.length > 0) {
                                // This position had a tiebreaker - find the runner-ups
                                var runnersUp = positionTbData.filter(function(tb) { 
                                    return !tb.isWinner; 
                                }).map(function(tb) { 
                                    return tb.playerName; 
                                });
                                
                                if (runnersUp.length > 0) {
                                    shouldShowTiebreaker = true;
                                    tiebreakerRunnerUps = runnersUp;
                                }
                            }
                        }
                        
                        // Fallback to position-based data if comprehensive data is not available
                        if (!shouldShowTiebreaker) {
                            var tb = (gameState.podiumTiebreakers && gameState.podiumTiebreakers[tbKey]) || 
                                    (gameState.podiumTiebreakersBackup && gameState.podiumTiebreakersBackup[tbKey]);
                            
                            if (tb && tb.runnerUps && tb.runnerUps.length > 0) {
                                shouldShowTiebreaker = true;
                                tiebreakerRunnerUps = tb.runnerUps;
                            }
                        }
                        
                        // Show tiebreaker banner if this player actually participated in a tiebreaker for this position
                        if (shouldShowTiebreaker) {
                            podiumHtml += '<div style="margin: 8px 0 0 0; padding: 6px 10px; background: linear-gradient(90deg, #ef4444 0%, #fbbf24 100%); color: #1e293b; border-radius: 6px; font-weight: bold; font-size: 0.95rem; display: inline-block;">üèÖ Decided by Tiebreaker</div>';
                            podiumHtml += '<div style="margin-top: 4px; color: #fca5a5; font-size: 0.9rem;">Runner-up: ' + tiebreakerRunnerUps.join(', ') + '</div>';
                        }
                        

                        podiumHtml += '<div class="podium-stats" style="display: flex; flex-direction: column; gap: clamp(0.2vh, 0.5vh, 0.8vh); flex: 1; justify-content: space-around; min-height: 0; overflow: hidden;">' +
                                                            '<div class="podium-stat" style="display: flex; justify-content: space-between; align-items: center; padding: clamp(0.3vh, 0.6vh, 0.8vh) clamp(0.6vw, 1vw, 1.5vw); background: rgba(15, 23, 42, 0.6); border-radius: 0.4vh; transition: all 0.3s ease; flex-shrink: 0;">' +
                                '<span class="podium-stat-label" style="font-size: clamp(0.5rem, 1.2vw, 0.9rem); color: #94a3b8;">Regulation</span>' +
                                '<span class="podium-stat-value" style="font-size: clamp(0.6rem, 1.4vw, 1rem); font-weight: bold; ' + statValueStyle + '">' + regulationScore + '</span>' +
                                    '</div>' +
                                (tiebreakerScore > 0 ? '<div class="podium-stat" style="display: flex; justify-content: space-between; align-items: center; padding: clamp(0.3vh, 0.6vh, 0.8vh) clamp(0.6vw, 1vw, 1.5vw); background: rgba(15, 23, 42, 0.6); border-radius: 0.4vh; transition: all 0.3s ease; flex-shrink: 0;">' +
                                '<span class="podium-stat-label" style="font-size: clamp(0.5rem, 1.2vw, 0.9rem); color: #94a3b8;">Tiebreaker</span>' +
                                '<span class="podium-stat-value" style="font-size: clamp(0.6rem, 1.4vw, 1rem); font-weight: bold; color: #ef4444;">+' + tiebreakerScore + '</span>' +
                                    '</div>' : '') +
                            '<div class="podium-stat" style="display: flex; justify-content: space-between; align-items: center; padding: clamp(0.3vh, 0.6vh, 0.8vh) clamp(0.6vw, 1vw, 1.5vw); background: rgba(15, 23, 42, 0.6); border-radius: 0.4vh; transition: all 0.3s ease; flex-shrink: 0;">' +
                                '<span class="podium-stat-label" style="font-size: clamp(0.5rem, 1.2vw, 0.9rem); color: #94a3b8;">Average</span>' +
                                '<span class="podium-stat-value" style="font-size: clamp(0.6rem, 1.4vw, 1rem); font-weight: bold; ' + statValueStyle + '">' + player.average + '</span>' +
                            '</div>' +
                            '<div class="podium-stat" style="display: flex; justify-content: space-between; align-items: center; padding: clamp(0.3vh, 0.6vh, 0.8vh) clamp(0.6vw, 1vw, 1.5vw); background: rgba(15, 23, 42, 0.6); border-radius: 0.4vh; transition: all 0.3s ease; flex-shrink: 0;">' +
                                '<span class="podium-stat-label" style="font-size: clamp(0.5rem, 1.2vw, 0.9rem); color: #94a3b8;">Efficiency</span>' +
                                '<span class="podium-stat-value" style="font-size: clamp(0.6rem, 1.4vw, 1rem); font-weight: bold; ' + statValueStyle + '">' + (player.percentage || 0) + '%</span>' +
                            '</div>' +
                            '<div class="podium-stat" style="display: flex; justify-content: space-between; align-items: center; padding: clamp(0.3vh, 0.6vh, 0.8vh) clamp(0.6vw, 1vw, 1.5vw); background: rgba(15, 23, 42, 0.6); border-radius: 0.4vh; transition: all 0.3s ease; flex-shrink: 0;">' +
                                '<span class="podium-stat-label" style="font-size: clamp(0.5rem, 1.2vw, 0.9rem); color: #94a3b8;">' + maxScoreLabel + '</span>' +
                                '<span class="podium-stat-value" style="font-size: clamp(0.6rem, 1.4vw, 1rem); font-weight: bold; ' + statValueStyle + '">' + player.bullseyes + '</span>' +
                            '</div>' +
                            (player.tripleNickels > 0 ? '<div class="podium-stat" style="display: flex; justify-content: space-between; align-items: center; padding: clamp(0.3vh, 0.6vh, 0.8vh) clamp(0.6vw, 1vw, 1.5vw); background: rgba(15, 23, 42, 0.6); border-radius: 0.4vh; transition: all 0.3s ease; flex-shrink: 0;">' +
                                '<span class="podium-stat-label" style="font-size: clamp(0.5rem, 1.2vw, 0.9rem); color: #94a3b8;">üî• Triple Nickels</span>' +
                                '<span class="podium-stat-value" style="font-size: clamp(0.6rem, 1.4vw, 1rem); font-weight: bold; color: #ef4444;">' + player.tripleNickels + '</span>' +
                            '</div>' : '') +
                            (player.noDrops > 0 ? '<div class="podium-stat" style="display: flex; justify-content: space-between; align-items: center; padding: clamp(0.3vh, 0.6vh, 0.8vh) clamp(0.6vw, 1vw, 1.5vw); background: rgba(15, 23, 42, 0.6); border-radius: 0.4vh; transition: all 0.3s ease; flex-shrink: 0;">' +
                                '<span class="podium-stat-label" style="font-size: clamp(0.5rem, 1.2vw, 0.9rem); color: #94a3b8;">üíé No Drops</span>' +
                                '<span class="podium-stat-value" style="font-size: clamp(0.6rem, 1.4vw, 1rem); font-weight: bold; color: #22c55e;">' + player.noDrops + '</span>' +
                            '</div>' : '') +
                        '</div>' +
                    '</div>' +
                '</div>';
                    }
                });
                
                podiumHtml += '</div>';
                

            }
            
            // Set up the victory window content
            victoryWindow.document.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>üèÜ ${gameState.gameName || 'Walkback Championship'} - Victory!</title>
                    <style>
                        * { margin: 0; padding: 0; box-sizing: border-box; }
                        body {
                            margin: 0;
                            padding: 0;
                            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
                            height: 100vh;
                            width: 100vw;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            color: #e2e8f0;
                            overflow: hidden;
                        }
                        .victory-container {
                            background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%);
                            border: 0.3vh solid #fbbf24;
                            border-radius: 2vh;
                            padding: 2vh 2vw;
                            margin: 1vh 1vw;
                            text-align: center;
                            box-shadow: 0 2vh 4vh rgba(0, 0, 0, 0.7);
                            height: calc(100vh - 2vh);
                            width: calc(100vw - 2vw);
                            display: flex;
                            flex-direction: column;
                            justify-content: space-between;
                            overflow: hidden;
                        }
                        .victory-header {
                            font-size: clamp(1.5rem, 4vw, 3rem);
                            font-weight: bold;
                            color: #fbbf24;
                            margin-bottom: 1vh;
                            text-shadow: 0.2vh 0.2vh 0.4vh rgba(0,0,0,0.5);
                        }
                        .victory-subtitle {
                            font-size: clamp(1rem, 2vw, 1.3rem);
                            color: #cbd5e1;
                            margin-bottom: 2vh;
                            font-weight: 500;
                        }
                        .victory-buttons {
                            display: flex;
                            gap: 1vw;
                            justify-content: center;
                            flex-wrap: wrap;
                            margin-top: 1vh;
                            padding-top: 1vh;
                            border-top: 1px solid rgba(148, 163, 184, 0.2);
                            flex-shrink: 0;
                        }
                        .victory-button {
                            border: none;
                            color: white;
                            padding: 1vh 2vw;
                            border-radius: 1vh;
                            font-size: clamp(0.8rem, 1.5vw, 1.1rem);
                            font-weight: bold;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            min-width: 8vw;
                        }
                        .victory-button:hover {
                            transform: translateY(-0.2vh);
                            box-shadow: 0 0.8vh 2vh rgba(0, 0, 0, 0.3);
                        }
                        .btn-continue { background: linear-gradient(45deg, #3b82f6, #1d4ed8); }
                        .btn-export { background: linear-gradient(45deg, #10b981, #059669); }
                        .btn-new { background: linear-gradient(45deg, #f59e0b, #d97706); }
                        @keyframes championGlow {
                            0% { 
                                box-shadow: 0 2vh 4vh rgba(0, 0, 0, 0.5), 0 0 2vh rgba(251, 191, 36, 0.4);
                            }
                            100% { 
                                box-shadow: 0 2.5vh 5vh rgba(0, 0, 0, 0.6), 0 0 3vh rgba(251, 191, 36, 0.6);
                            }
                        }
                        .podium-card:hover {
                            transform: translateY(-0.5vh);
                            box-shadow: 0 1.5vh 4vh rgba(0, 0, 0, 0.5);
                        }
                        .podium-card.podium-first:hover {
                            transform: translateY(-0.8vh) scale(1.02);
                            transform-origin: bottom;
                        }
                        .podium-card.podium-second:hover {
                            transform: translateY(-0.6vh) scale(1.01);
                            transform-origin: bottom;
                            box-shadow: 0 2vh 4vh rgba(0, 0, 0, 0.5), 0 0 2vh rgba(148, 163, 184, 0.4);
                        }
                        .podium-card.podium-third:hover {
                            transform: translateY(-0.4vh) scale(1.01);
                            transform-origin: bottom;
                            box-shadow: 0 1.5vh 3vh rgba(0, 0, 0, 0.5), 0 0 2vh rgba(217, 119, 6, 0.4);
                        }
                        .podium-stat:hover {
                            background: rgba(15, 23, 42, 0.8);
                            transform: scale(1.02);
                        }
                        @media (max-width: 768px) {
                            .victory-container { 
                                padding: 1.5vh 2vw; 
                                margin: 0.5vh 1vw; 
                                height: calc(100vh - 1vh);
                                overflow-y: auto;
                            }
                            .victory-header { font-size: clamp(1rem, 5vw, 1.5rem); margin-bottom: 0.5vh; }
                            .victory-subtitle { font-size: clamp(0.8rem, 3vw, 1rem); margin-bottom: 1vh; }
                            #podiumResults {
                                flex-direction: column !important;
                                align-items: center !important;
                                gap: 1.5vh !important;
                                max-height: none !important;
                                overflow-y: visible !important;
                            }
                            .podium-card {
                                width: 85vw !important;
                                max-width: 350px !important;
                                height: auto !important;
                                min-height: 120px !important;
                                max-height: 25vh !important;
                                margin-bottom: 0 !important;
                                padding: 1.5vh 2vw !important;
                            }
                            .podium-card.podium-first {
                                transform: scale(1.0) !important;
                                min-height: 140px !important;
                                max-height: 28vh !important;
                            }
                            .podium-card.podium-second {
                                transform: scale(1.0) !important;
                                min-height: 130px !important;
                                max-height: 26vh !important;
                            }
                            .podium-card.podium-third {
                                transform: scale(1.0) !important;
                                min-height: 120px !important;
                                max-height: 24vh !important;
                            }
                            .podium-stats {
                                gap: 0.3vh !important;
                            }
                            .podium-stat {
                                padding: 0.4vh 1vw !important;
                                font-size: 0.75rem !important;
                            }
                            .victory-buttons {
                                margin-top: 1.5vh;
                                padding: 1.5vh 0;
                                position: sticky;
                                bottom: 0;
                                background: linear-gradient(to top, rgba(30, 41, 59, 1) 0%, rgba(30, 41, 59, 0.95) 80%, transparent 100%);
                            }
                            .victory-button {
                                padding: 1.5vh 4vw !important;
                                font-size: 1rem !important;
                                min-width: 120px !important;
                            }
                        }
                    </style>
                </head>
                <body>
                    <div class="victory-container">
                        <div style="flex-shrink: 0;">
                            <div class="victory-header">üó°Ô∏è WALKBACK COMPLETE! üó°Ô∏è</div>
                            <div class="victory-subtitle">${gameState.gameName || 'Walkback Championship'}</div>
                        </div>
                        <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; min-height: 0; overflow: hidden;">
                            ${podiumHtml}
                        </div>
                        <div class="victory-buttons">
                            <button class="victory-button btn-continue" onclick="window.close()">Continue</button>
                        </div>
                    </div>
                </body>
                </html>
            `);

            victoryWindow.document.close();
            victoryWindow.focus();
            
            // Handle window close
            victoryWindow.addEventListener('beforeunload', function() {
                victoryWindow = null;
            });
        }

        function showStats() {
            if (gameState.players.length === 0) {
                showCustomAlert('No players added yet!');
                return;
            }
            
            var stats = calculateGameStatistics(gameState);
            
            // Create a better modal display for stats
            var statsModal = document.createElement('div');
            statsModal.id = 'statsModal';
            statsModal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.9); display: flex; align-items: center; justify-content: center; z-index: 10001; padding: 20px; box-sizing: border-box;';
            
            var statsContainer = document.createElement('div');
            statsContainer.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 3px solid #fbbf24; border-radius: 20px; padding: 30px; max-width: 800px; width: 100%; max-height: 90vh; overflow-y: auto; color: #e2e8f0;';
            
            var maxScoreLabel = gameState.maxScore === 5 ? 'Bullseyes' : 'Max Scores';
            var maxPossibleScore = gameState.rounds * gameState.numDistances * gameState.throwsPerRound * gameState.maxScore;
            
            // Sort players by regulation score for better display
            var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                // Sort by regulation scores only - tiebreakers are only for breaking ties, not adding points
                return b.total - a.total;
            });
            
            statsContainer.innerHTML = `
                <div style="text-align: center; margin-bottom: 30px;">
                    <h2 style="color: #fbbf24; font-size: 2rem; margin-bottom: 10px;">üìä WALKBACK GAME STATISTICS</h2>
                    <div style="color: #94a3b8; font-size: 1.1rem;">${gameState.gameName || 'Walkback Championship'}</div>
                </div>
                
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 25px; border: 1px solid #334155;">
                    <h3 style="color: #f1f5f9; font-size: 1.3rem; margin-bottom: 15px; text-align: center;">üéØ Game Overview</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; font-size: 0.9rem;">
                        <div><strong>Players:</strong> ${gameState.players.length}</div>
                        <div><strong>Play Mode:</strong> ${gameState.playMode === 'consecutive' ? 'Consecutive Rounds' : 'Sequential Distance'}</div>
                        <div><strong>Rounds:</strong> ${gameState.rounds}</div>
                        <div><strong>Distances per Round:</strong> ${gameState.numDistances}</div>
                        <div><strong>Throws per Distance:</strong> ${gameState.throwsPerRound}</div>
                        <div><strong>Max Points per Throw:</strong> ${gameState.maxScore}</div>
                        <div><strong>Total Throws per Player:</strong> ${gameState.rounds * gameState.numDistances * gameState.throwsPerRound}</div>
                        <div><strong>Max Possible Score:</strong> ${maxPossibleScore}</div>
                    </div>
                </div>
                
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 25px; border: 1px solid #334155;">
                    <h3 style="color: #f1f5f9; font-size: 1.3rem; margin-bottom: 15px; text-align: center;">üèÜ Performance Summary</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; font-size: 0.9rem;">
                        <div><strong>Highest Score:</strong> ${stats.highestScore} (${stats.highestScorePlayer})</div>
                        <div><strong>Lowest Score:</strong> ${stats.lowestScore} (${stats.lowestScorePlayer})</div>
                        <div><strong>Average Score:</strong> ${stats.averageScore}</div>
                        <div><strong>Total ${maxScoreLabel}:</strong> ${stats.totalBullseyes}</div>
                        <div><strong>Total Triple Nickels:</strong> ${stats.totalTripleNickels}</div>
                        <div><strong>Game Status:</strong> ${gameState.gameFinalized ? 'FINALIZED' : gameState.inTiebreaker ? 'IN TIEBREAKER' : 'IN PROGRESS'}</div>
                    </div>
                </div>
                
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #334155;">
                    <h3 style="color: #f1f5f9; font-size: 1.3rem; margin-bottom: 20px; text-align: center;">üë• Individual Players (${gameState.players.length} Total)</h3>
                    <div style="display: grid; gap: 15px;">
                        ${sortedPlayers.map(function(player, index) {
                            var rank = index + 1;
                            var rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '#' + rank;
                            var regulationScore = player.total;
                            var tiebreakerDisplay = player.podiumTiebreakerPoints ? ` (${regulationScore} + ${player.podiumTiebreakerPoints} TB)` : '';
                            var efficiency = player.percentage || 0;
                            
                            return `
                                <div style="background: rgba(30, 41, 59, 0.8); padding: 15px; border-radius: 8px; border: 1px solid #475569; ${rank <= 3 ? 'border-color: #fbbf24; background: rgba(251, 191, 36, 0.1);' : ''}">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <div style="font-size: 1.1rem; font-weight: bold; color: ${rank <= 3 ? '#fbbf24' : '#e2e8f0'};">
                                            ${rankEmoji} ${player.name}
                                        </div>
                                        <div style="font-size: 1.3rem; font-weight: bold; color: #fbbf24;">
                                            ${regulationScore}${tiebreakerDisplay}
                                        </div>
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; font-size: 0.85rem; color: #cbd5e1;">
                                        <div><strong>Average:</strong> ${player.average}</div>
                                        <div><strong>Efficiency:</strong> ${efficiency}%</div>
                                        <div><strong>${maxScoreLabel}:</strong> ${player.bullseyes}</div>
                                        <div><strong>Triple Nickels:</strong> ${player.tripleNickels}</div>
                                        <div><strong>No Drops:</strong> ${player.noDrops}</div>
                                        <div><strong>Score/Max:</strong> ${regulationScore}/${maxPossibleScore}</div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <button onclick="closeStatsModal()" style="background: linear-gradient(45deg, #3b82f6, #1d4ed8); border: none; color: white; padding: 12px 30px; border-radius: 10px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;">Close Statistics</button>
                </div>
            `;
            
            statsModal.appendChild(statsContainer);
            document.body.appendChild(statsModal);
            
            // Add close function
            window.closeStatsModal = function() {
                statsModal.remove();
                delete window.closeStatsModal;
            };
            
            // Close on background click
            statsModal.addEventListener('click', function(e) {
                if (e.target === statsModal) {
                    window.closeStatsModal();
                }
            });
        }

        function getTiebreakerModeName(mode) {
            switch(mode) {
                case 'sudden-death': return 'Sudden Death (1 throw each)';
                case 'sudden-death-round': return 'Sudden Death Round (3 throws each)';
                case 'sudden-death-podium': return 'Sudden Death Podium (1 throw each)';
                case 'sudden-death-podium-match': return 'Sudden Death Podium Round (3 throws each)';
                case 'no-tiebreaker': return 'No Tiebreaker (Allow ties)';
                default: return 'Unknown';
            }
        }

        function getTiebreakerDisplayName(mode) {
            switch(mode) {
                case 'sudden-death': return 'Sudden Death';
                case 'sudden-death-round': return 'Sudden Death Round';
                case 'sudden-death-podium': return 'Sudden Death Podium';
                case 'sudden-death-podium-match': return 'Sudden Death Podium Round';
                case 'no-tiebreaker': return 'No Tiebreaker';
                default: return 'Tiebreaker';
            }
        }

        function exportData() {
            console.log('üìÑ exportData() called');
            
            if (gameState.players.length === 0) {
                console.log('‚ùå No players to export');
                showCustomAlert('No data to export!');
                return;
            }
            
            var sortedPlayers = gameState.players.slice().sort(function(a, b) { 
                // Sort by regulation scores only - tiebreakers are only for breaking ties, not adding points
                return b.total - a.total;
            });
            
            var date = new Date();
            var gameTitle = gameState.gameName || 'Walkback Championship';
            var maxPossibleScore = gameState.rounds * gameState.numDistances * gameState.throwsPerRound * gameState.maxScore;
            var maxScoreLabel = gameState.maxScore === 5 ? 'Bullseyes' : 'Max Scores';
            
            var htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walkback Results - ${gameTitle}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #e2e8f0;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .report-container {
            max-width: 1200px;
            margin: 0 auto;
            background: #1e293b;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            overflow: hidden;
            border: 1px solid #334155;
        }
        .header {
            background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 30%, #3730a3 50%, #1e3a8a 70%, #0f172a 100%);
            color: #e2e8f0;
            padding: 50px;
            text-align: center;
            position: relative;
            border-bottom: 5px solid #fbbf24;
        }
        .header::before {
            content: 'üó°Ô∏è';
            font-size: 5rem;
            position: absolute;
            top: 30px;
            left: 50px;
            opacity: 0.3;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5));
        }
        .header::after {
            content: 'üèÜ';
            font-size: 5rem;
            position: absolute;
            top: 30px;
            right: 50px;
            opacity: 0.3;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5));
        }
        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            color: #f1f5f9;
        }
        .header h2 {
            font-size: 1.5rem;
            color: #fbbf24;
            margin-bottom: 20px;
        }
        .game-info {
            background: rgba(15, 23, 42, 0.6);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            border: 1px solid #334155;
        }
        .info-item {
            text-align: center;
        }
        .info-label {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-bottom: 5px;
            color: #94a3b8;
        }
        .info-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #fbbf24;
        }
        .content {
            padding: 40px;
            background: #1e293b;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h3 {
            font-size: 1.8rem;
            color: #f1f5f9;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #fbbf24;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .podium {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 30px;
            margin-bottom: 50px;
            padding: 140px 40px 20px 40px;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 30%, #334155 70%, #1e293b 100%);
            border-radius: 30px;
            border: 4px solid #475569;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.1);
            min-height: 600px;
            position: relative;
            overflow: visible;
        }
        .podium::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(135deg, #1e293b 0%, #475569 30%, #64748b 70%, #475569 100%);
            border-radius: 0 0 26px 26px;
            box-shadow: 0 -12px 35px rgba(0,0,0,0.6);
        }
        .podium::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center top, rgba(251,191,36,0.1) 0%, transparent 60%);
            pointer-events: none;
        }

        .podium-card {
            background: transparent;
            border-radius: 0;
            padding: 0;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
            min-width: 360px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }
        .podium-card:hover {
            /* Static display - no hover effects for export */
        }
        .rank-1 {
            order: 2;
            z-index: 3;
            height: 420px;
            margin-bottom: 0;
            margin-top: -50px;
        }
        .rank-1::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 160px;
            height: 160px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 30%, #fbbf24 70%, #d97706 100%);
            border-radius: 20px 20px 0 0;
            border: 5px solid #f59e0b;
            box-shadow: 0 15px 50px rgba(251, 191, 36, 0.6), 0 5px 15px rgba(251, 191, 36, 0.4), inset 0 2px 0 rgba(255,255,255,0.3);
        }
        .rank-1::after {
            content: 'ü•á';
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            z-index: 1;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5));
        }
        .rank-2 {
            order: 1;
            z-index: 2;
            height: 360px;
            margin-bottom: 0;
        }
        .rank-2::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 130px;
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 30%, #94a3b8 70%, #cbd5e1 100%);
            border-radius: 16px 16px 0 0;
            border: 4px solid #94a3b8;
            box-shadow: 0 12px 40px rgba(148, 163, 184, 0.6), 0 5px 15px rgba(148, 163, 184, 0.3), inset 0 2px 0 rgba(255,255,255,0.4);
        }
        .rank-2::after {
            content: 'ü•à';
            position: absolute;
            bottom: 65px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.8rem;
            z-index: 1;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));
        }
        .rank-3 {
            order: 3;
            z-index: 1;
            height: 320px;
            margin-bottom: 0;
        }
        .rank-3::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 100px;
            background: linear-gradient(135deg, #fdba74 0%, #fb923c 30%, #ea580c 70%, #fb923c 100%);
            border-radius: 14px 14px 0 0;
            border: 4px solid #fb923c;
            box-shadow: 0 10px 35px rgba(251, 146, 60, 0.6), 0 5px 15px rgba(251, 146, 60, 0.3), inset 0 2px 0 rgba(255,255,255,0.3);
        }
        .rank-3::after {
            content: 'ü•â';
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.6rem;
            z-index: 1;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));
        }
        .trophy {
            font-size: 5rem;
            margin-bottom: 20px;
            filter: drop-shadow(0 6px 12px rgba(0,0,0,0.6));
            position: relative;
            z-index: 2;
        }
        .rank-1 .trophy {
            color: #fbbf24;
            text-shadow: 0 0 30px rgba(251, 191, 36, 0.8), 0 0 60px rgba(251, 191, 36, 0.4);
            font-size: 6rem;
        }
        .rank-2 .trophy {
            color: #cbd5e1;
            text-shadow: 0 0 25px rgba(203, 213, 225, 0.7), 0 0 50px rgba(203, 213, 225, 0.3);
            font-size: 5.5rem;
        }
        .rank-3 .trophy {
            color: #fdba74;
            text-shadow: 0 0 20px rgba(253, 186, 116, 0.7), 0 0 40px rgba(253, 186, 116, 0.3);
            font-size: 5rem;
        }
        .player-name {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 12px;
            text-shadow: 0 3px 6px rgba(0,0,0,0.7);
            color: #f1f5f9;
            background: rgba(0,0,0,0.4);
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
        }
        .player-score {
            font-size: 2.8rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 4px 12px rgba(0,0,0,0.9), 0 2px 6px rgba(0,0,0,0.8);
            color: #fbbf24;
            background: transparent;
            padding: 0;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
        }
        .podium-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            justify-content: flex-start;
            padding: 20px 20px 20px 20px;
            gap: 15px;
            position: absolute;
            top: -120px;
            left: 0;
            right: 0;
            z-index: 2;
        }
        .player-stats {
            font-size: 0.75rem;
            line-height: 1.4;
            background: rgba(0,0,0,0.4);
            padding: 12px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.15);
            text-align: left;
            width: 100%;
            flex-shrink: 0;
            font-weight: 500;
            color: #e2e8f0;
        }
        .yellow { color: #fbbf24; }
        .purple { color: #a855f7; }
        .red { color: #ef4444; }
        .green { color: #22c55e; }

        /* Table wrapper for horizontal scrolling on mobile */
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin: 0 -20px;
            padding: 0 20px;
            scroll-behavior: smooth;
            scrollbar-width: thin;
            scrollbar-color: #64748b #334155;
        }
        
        .table-wrapper::-webkit-scrollbar {
            height: 8px;
        }
        
        .table-wrapper::-webkit-scrollbar-track {
            background: #334155;
            border-radius: 4px;
        }
        
        .table-wrapper::-webkit-scrollbar-thumb {
            background: #64748b;
            border-radius: 4px;
        }
        
        .table-wrapper::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Static display - no animations for export */
        table {
            width: 100%;
            border-collapse: collapse;
            background: linear-gradient(135deg, #334155 0%, #475569 100%);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5), 0 2px 8px rgba(0,0,0,0.3);
            margin-bottom: 30px;
            border: 2px solid #64748b;
            min-width: 800px; /* Ensure table doesn't get too compressed */
        }
        thead {
            background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 50%, #0f172a 100%);
            color: #e2e8f0;
            position: relative;
        }
        thead::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #fbbf24, #f59e0b, #fbbf24);
        }
        th, td {
            padding: 18px 20px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #e2e8f0;
            white-space: nowrap; /* Prevent text wrapping in table cells */
        }
        th {
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.95rem;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        tbody tr:nth-child(even) {
            background: rgba(45, 55, 72, 0.7);
        }
        tbody tr:nth-child(odd) {
            background: rgba(51, 65, 85, 0.7);
        }
        tbody tr:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.1));
            transition: all 0.3s ease;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.2);
        }
        .rank-cell {
            font-weight: bold;
            font-size: 1.3rem;
            text-align: center;
            color: #fbbf24;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .score-cell {
            font-weight: bold;
            font-size: 1.4rem;
            color: #fbbf24;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.05));
            border-radius: 8px;
            padding: 8px 12px;
        }
        .distance-section {
            background: #2d3748;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid #4a5568;
        }
        .distance-section table {
            margin-top: 0;
            background: #334155;
        }
        .distance-section table th {
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            color: #e2e8f0;
            font-size: 0.85rem;
            padding: 12px 8px;
        }
        .distance-section table td {
            padding: 10px 8px;
            vertical-align: middle;
        }
        .tiebreaker-section {
            background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
            border: 2px solid #dc2626;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            color: #fecaca;
        }
        .tiebreaker-section p {
            color: #fecaca;
        }
        .tiebreaker-section table {
            background: #450a0a;
            border: 1px solid #dc2626;
        }
        .tiebreaker-section th {
            background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
            color: #fecaca;
        }
        .tiebreaker-section td {
            color: #fecaca;
            border-bottom: 1px solid #7f1d1d;
        }
        .footer {
            background: #0f172a;
            color: #94a3b8;
            text-align: center;
            padding: 20px;
            font-size: 0.9rem;
            border-top: 1px solid #334155;
        }
        .export-date {
            color: #64748b;
            margin-top: 10px;
        }
        @media print {
            body { background: #1e293b; padding: 0; }
            .report-container { box-shadow: none; }
            .podium-card { break-inside: avoid; }
            table { break-inside: avoid; }
        }
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header::before,
            .header::after {
                font-size: 3rem;
                top: 15px;
            }
            
            .header::before {
                left: 20px;
            }
            
            .header::after {
                right: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
                margin-top: 40px;
            }
            
            .header h2 {
                font-size: 1.2rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .game-info {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                padding: 15px;
            }
            
            .info-label {
                font-size: 0.8rem;
            }
            
            .info-value {
                font-size: 1rem;
            }
            
            .section h3 {
                font-size: 1.4rem;
            }
            
            /* Mobile podium adjustments */
            .podium {
                flex-direction: column;
                align-items: center;
                gap: 20px;
                padding: 40px 20px 20px 20px;
                min-height: auto;
            }
            
            .podium-card {
                min-width: 280px;
                width: 100%;
                max-width: 300px;
                height: 200px !important;
                margin: 0 !important;
                position: relative;
                order: initial !important;
            }
            
            .rank-1::before,
            .rank-2::before,
            .rank-3::before {
                width: 100px;
                height: 80px;
                border-radius: 12px 12px 0 0;
            }
            
            .rank-1::after,
            .rank-2::after,
            .rank-3::after {
                bottom: 40px;
                font-size: 1.5rem;
            }
            
            .podium-content {
                top: -80px;
                padding: 15px;
                gap: 10px;
            }
            
            .trophy {
                font-size: 3rem !important;
                margin-bottom: 10px;
            }
            
            .player-name {
                font-size: 1.2rem;
                padding: 6px 12px;
                margin-bottom: 8px;
            }
            
            .player-score {
                font-size: 2rem;
                margin-bottom: 15px;
            }
            
            /* Table adjustments for mobile */
            .table-wrapper {
                margin: 0 -20px;
                padding: 0 20px;
            }
            
            table {
                min-width: 700px; /* Reduced minimum width for mobile */
            }
            
            th, td {
                padding: 12px 8px;
                font-size: 0.85rem;
            }
            
            .rank-cell {
                font-size: 1.1rem;
            }
            
            .score-cell {
                font-size: 1.2rem;
                padding: 6px 8px;
            }
            
            /* Distance section mobile adjustments */
            .distance-section {
                padding: 15px;
            }
            
            .distance-section table {
                min-width: 600px;
            }
            
            .distance-section table th,
            .distance-section table td {
                padding: 8px 4px;
                font-size: 0.8rem;
            }
            
            /* Tiebreaker section mobile adjustments */
            .tiebreaker-section {
                padding: 15px;
            }
            
            .tiebreaker-section h4 {
                font-size: 1rem !important;
            }
            
            .footer {
                padding: 15px;
                font-size: 0.8rem;
            }
        }

        /* Smaller mobile devices */
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.8rem;
            }
            
            .game-info {
                grid-template-columns: 1fr;
            }
            
            .podium-card {
                min-width: 260px;
                max-width: 280px;
            }
            
            table {
                min-width: 600px;
            }
            
            .distance-section table {
                min-width: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="report-container">
        <div class="header">
            <h1>üó°Ô∏è WALKBACK RESULTS üó°Ô∏è</h1>
            <h2>${gameTitle}</h2>
            <div class="game-info">
                <div class="info-item">
                    <div class="info-label">Players</div>
                    <div class="info-value">${gameState.players.length}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Play Mode</div>
                    <div class="info-value">${gameState.playMode === 'consecutive' ? 'Consecutive' : 'Sequential'}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Rounds</div>
                    <div class="info-value">${gameState.rounds}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Distances</div>
                    <div class="info-value">${gameState.numDistances}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Max Score</div>
                    <div class="info-value">${gameState.maxScore}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Event Date</div>
                    <div class="info-value">${date.toLocaleDateString()}</div>
                </div>
            </div>
        </div>

        <div class="content">
            <div class="section">
                <h3>üèÜ Final Rankings</h3>
                <div class="podium">`;
            
            // Top 3 Podium
            for (var i = 0; i < Math.min(3, sortedPlayers.length); i++) {
                var player = sortedPlayers[i];
                var rank = i + 1;
                var trophy = rank === 1 ? 'üèÜ' : rank === 2 ? 'ü•à' : 'ü•â';
                var rankClass = 'rank-' + rank;
                var regulationScore = player.total; // player.total should be regulation only
                var tiebreakerScore = player.podiumTiebreakerPoints || 0;
                
                // Show regulation score only - tiebreakers are only for breaking ties, not adding points
                var totalScoreDisplay = regulationScore;
                var maxPossibleScore = gameState.rounds * gameState.numDistances * gameState.throwsPerRound * gameState.maxScore;
                
                htmlContent += `
                    <div class="podium-card ${rankClass}">
                        <div class="podium-content">
                            <div class="trophy">${trophy}</div>
                            <div class="player-name">${getPlayerNameWithTeam(player.name)}</div>
                            <div class="player-score">${totalScoreDisplay} pts</div>
                        </div>
                    </div>`;
            }
            
            htmlContent += `
                </div>
                
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Player</th>
                                <th>Regulation Score</th>
                                <th>Regular</th>
                                <th>Average</th>
                                <th>Efficiency (Sets)</th>
                                <th>${maxScoreLabel}</th>
                                <th>Triple Nickels</th>
                                <th>No Drops</th>
                            </tr>
                        </thead>
                        <tbody>`;
            
            sortedPlayers.forEach(function(player, index) {
                var rank = index + 1;
                var regulationScore = player.total; // player.total should be regulation only
                var tiebreakerScore = player.podiumTiebreakerPoints || 0;
                
                // Show regulation score only - tiebreakers are only for breaking ties, not adding points
                var totalScoreDisplay = regulationScore;
                
                htmlContent += `
                        <tr>
                            <td class="rank-cell">#${rank}</td>
                            <td><strong>${getPlayerNameWithTeam(player.name)}</strong></td>
                            <td class="score-cell">${totalScoreDisplay}</td>
                            <td>${regulationScore}</td>
                            <td>${player.average}</td>
                            <td>${player.percentage || 0}%</td>
                            <td>${player.bullseyes}</td>
                            <td>${player.tripleNickels}</td>
                            <td>${player.noDrops}</td>
                        </tr>`;
            });
            
            htmlContent += `
                    </tbody>
                    </table>
                </div>
            </div>`;
            
            // Team Standings Section
            var teams = getAllTeams();
            var teamsWithPlayers = teams.filter(team => 
                team.members && team.members.some(member => 
                    gameState.players.some(player => player.name === member.name)
                )
            );
            
            if (teamsWithPlayers.length > 0) {
                // Calculate team scores
                var teamStandings = teamsWithPlayers.map(team => {
                    var teamScore = 0;
                    var teamMembers = [];
                    
                    team.members.forEach(member => {
                        var player = gameState.players.find(p => p.name === member.name);
                        if (player) {
                            teamScore += player.total;
                            teamMembers.push({
                                name: member.name,
                                score: player.total,
                                isCaptain: team.captainId && member.id === team.captainId
                            });
                        }
                    });
                    
                    return {
                        name: team.name,
                        score: teamScore,
                        members: teamMembers,
                        memberCount: teamMembers.length
                    };
                }).sort((a, b) => b.score - a.score);
                
                htmlContent += `
            <div class="section">
                <h3>üèÜ Team Standings</h3>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Team</th>
                                <th>Total Score</th>
                                <th>Members</th>
                                <th>Average per Player</th>
                            </tr>
                        </thead>
                        <tbody>`;
                
                teamStandings.forEach(function(team, index) {
                    var rank = index + 1;
                    var rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank.toString();
                    var rankStyle = rank <= 3 ? 'font-weight: bold; color: #fbbf24;' : '';
                    var rowStyle = rank <= 3 ? 'background: rgba(251, 191, 36, 0.15);' : '';
                    var avgPerPlayer = team.memberCount > 0 ? (team.score / team.memberCount).toFixed(1) : 0;
                    
                    var membersList = team.members.map(member => 
                        member.name + (member.isCaptain ? ' üëë' : '') + ' (' + member.score + ')'
                    ).join(', ');
                    
                    htmlContent += `
                        <tr style="${rowStyle}">
                            <td style="text-align: center; ${rankStyle}">${rankEmoji}</td>
                            <td><strong>${team.name}</strong></td>
                            <td style="text-align: center; font-weight: bold; ${rankStyle}">${team.score}</td>
                            <td style="font-size: 0.9rem; color: #94a3b8;">${membersList}</td>
                            <td style="text-align: center;">${avgPerPlayer}</td>
                        </tr>`;
                });
                
                htmlContent += `
                    </tbody>
                    </table>
                </div>
            </div>`;
            }
            
            // Tiebreaker section if applicable - only show if there were actual tiebreakers that resolved ties
            var hasTiebreakers = (gameState.podiumTiebreakers && Object.keys(gameState.podiumTiebreakers).length > 0) ||
                                (gameState.podiumTiebreakersBackup && Object.keys(gameState.podiumTiebreakersBackup).length > 0) ||
                                (gameState.allTiebreakerParticipants && gameState.allTiebreakerParticipants.length > 0);
            
            if (hasTiebreakers) {
                // Visual debugging for Electron
                console.log('üîç DEBUG: Export - podiumTiebreakers: ' + JSON.stringify(gameState.podiumTiebreakers));
                
                var playersWithTb = gameState.players.filter(p => p.podiumTiebreakerPoints && p.podiumTiebreakerPoints > 0);
                var tbPlayersMsg = 'Players with tiebreaker points:\n';
                playersWithTb.forEach(function(p) {
                    tbPlayersMsg += p.name + ': ' + p.podiumTiebreakerPoints + ' pts, position: ' + (p.podiumTiebreakerPosition || 'none') + '\n';
                });
                console.log('üîç DEBUG: ' + tbPlayersMsg);
                
                // Debug: Check which positions actually had tiebreakers
                if (gameState.podiumTiebreakers) {
                    var tbPositionsMsg = 'Tiebreaker positions:\n';
                    Object.keys(gameState.podiumTiebreakers).forEach(function(position) {
                        var tb = gameState.podiumTiebreakers[position];
                        tbPositionsMsg += position + ': winner=' + tb.winner + ', runners=' + tb.runnerUps.join(', ') + '\n';
                    });
                    console.log('üîç DEBUG: ' + tbPositionsMsg);
                }
                htmlContent += `
            <div class="section">
                <h3>üî• Tiebreaker Results</h3>
                <div class="tiebreaker-section">
                    <p><strong>Tiebreaker Mode:</strong> ${getTiebreakerModeName(gameState.tiebreakerMode)}</p>`;
                
                // Show tiebreaker details for each position that had a tiebreaker
                var tiebreakerData = gameState.podiumTiebreakers || gameState.podiumTiebreakersBackup || {};
                if (tiebreakerData && Object.keys(tiebreakerData).length > 0) {
                    // Sort positions to show 1st place before 2nd place before 3rd place
                    var positionOrder = ['first', 'second', 'third'];
                    positionOrder.forEach(function(position) {
                        if (tiebreakerData[position]) {
                            var tb = tiebreakerData[position];
                            var positionName = position === 'first' ? '1st Place' : position === 'second' ? '2nd Place' : '3rd Place';
                            
                            htmlContent += `
                    <div style="margin: 20px 0; padding: 15px; background: rgba(220, 38, 38, 0.2); border-radius: 8px; border: 1px solid #dc2626;">
                        <h4 style="color: #fecaca; margin-bottom: 10px; font-size: 1.2rem;">${positionName} Tiebreaker</h4>
                        <p style="color: #fecaca; margin-bottom: 10px;"><strong>Winner:</strong> ${tb.winner}</p>
                        <p style="color: #fecaca; margin-bottom: 10px;"><strong>Tied for ${positionName}:</strong> ${tb.runnerUps.join(', ')}</p>
                    </div>`;
                        }
                    });
                }
                
                htmlContent += `
                    <div class="table-wrapper">
                        <table style="margin-top: 20px;">
                            <thead>
                                <tr>
                                    <th>Player</th>
                                    <th>Tied Position</th>
                                    <th>Tiebreaker Score</th>
                                    <th>Result</th>
                                </tr>
                            </thead>
                            <tbody>`;
                
                // Use the comprehensive tiebreaker data if available, otherwise fall back to player data
                console.log('Export - allTiebreakerParticipants:', gameState.allTiebreakerParticipants);
                
                var tiebreakerPlayers = [];
                if (gameState.allTiebreakerParticipants && gameState.allTiebreakerParticipants.length > 0) {
                    // Use the comprehensive data
                    gameState.allTiebreakerParticipants.forEach(function(tbData) {
                        var player = gameState.players.find(function(p) { return p.id === tbData.playerId; });
                        if (player) {
                            tiebreakerPlayers.push({
                                player: player,
                                tbData: tbData
                            });
                            console.log('Export - Added tiebreaker data for ' + player.name + ': ' + tbData.positionName + ' - ' + (tbData.isWinner ? 'Winner' : 'Runner-up'));
                        }
                    });
                } else {
                    // Fall back to player data using the new multi-position structure
                    var playersWithTiebreaker = gameState.players.filter(function(p) { 
                        return (p.podiumTiebreakerPoints && p.podiumTiebreakerPoints > 0) || (p.podiumTiebreakerData && p.podiumTiebreakerData.length > 0); 
                    });
                    
                    tiebreakerPlayers = [];
                    playersWithTiebreaker.forEach(function(player) {
                        if (player.podiumTiebreakerData && player.podiumTiebreakerData.length > 0) {
                            // Use the new multi-position data structure
                            player.podiumTiebreakerData.forEach(function(positionData) {
                                tiebreakerPlayers.push({
                                    player: player,
                                    tbData: {
                                        playerId: player.id,
                                        playerName: player.name,
                                        position: positionData.position,
                                        positionName: positionData.positionName,
                                        points: positionData.points,
                                        isWinner: positionData.isWinner,
                                        winner: positionData.winner,
                                        runnerUps: positionData.runnerUps
                                    }
                                });
                            });
                        } else {
                            // Fallback to old single-position data
                            tiebreakerPlayers.push({
                                player: player,
                                tbData: null
                            });
                        }
                    });
                    console.log('Export - Using fallback data for players:', playersWithTiebreaker.map(p => p.name));
                }
                
                // Sort tiebreaker players by podium position (1st place first, then 2nd, then 3rd)
                tiebreakerPlayers.sort(function(a, b) {
                    var aPosition = a.tbData ? a.tbData.position : (a.player.podiumTiebreakerPosition || 'unknown');
                    var bPosition = b.tbData ? b.tbData.position : (b.player.podiumTiebreakerPosition || 'unknown');
                    
                    var positionOrder = { 'first': 1, 'second': 2, 'third': 3, 'unknown': 4 };
                    return positionOrder[aPosition] - positionOrder[bPosition];
                });
                
                tiebreakerPlayers.forEach(function(playerData) {
                    var player = playerData.player;
                    var tbData = playerData.tbData;
                    var totalTiebreakerPoints = tbData ? tbData.points : (player.podiumTiebreakerPoints || 0);
                    
                    console.log('Export processing player: ' + player.name + ', tbData: ', tbData);
                    
                    // Use the comprehensive tiebreaker info if available
                    var tiedPosition = 'Unknown';
                    var result = 'Participated';
                    
                    if (tbData) {
                        // Use the comprehensive data
                        tiedPosition = tbData.positionName;
                        result = tbData.isWinner ? 'Winner' : 'Runner-up';
                    } else if (player.podiumTiebreakerInfo) {
                        // Fallback to player's stored info
                        tiedPosition = player.podiumTiebreakerInfo.positionName;
                        result = player.podiumTiebreakerInfo.isWinner ? 'Winner' : 'Runner-up';
                    } else if (player.podiumTiebreakerPosition) {
                        // Fallback to position info if comprehensive info is not available
                        var positionName = player.podiumTiebreakerPosition === 'first' ? '1st Place' : 
                                         player.podiumTiebreakerPosition === 'second' ? '2nd Place' : '3rd Place';
                        tiedPosition = positionName;
                        
                        // Check if this player was the winner of this position's tiebreaker
                        var tb = (gameState.podiumTiebreakers && gameState.podiumTiebreakers[player.podiumTiebreakerPosition]) ||
                                (gameState.podiumTiebreakersBackup && gameState.podiumTiebreakersBackup[player.podiumTiebreakerPosition]);
                        if (tb && tb.winner === player.name) {
                            result = 'Winner';
                        } else if (tb && tb.runnerUps && tb.runnerUps.includes(player.name)) {
                            result = 'Runner-up';
                        }
                    } else {
                        // Fallback to the old logic if position info is not available
                        var fallbackTiebreakerData = gameState.podiumTiebreakers || gameState.podiumTiebreakersBackup || {};
                        if (fallbackTiebreakerData && Object.keys(fallbackTiebreakerData).length > 0) {
                            Object.keys(fallbackTiebreakerData).forEach(function(position) {
                                var tb = fallbackTiebreakerData[position];
                                var positionName = position === 'first' ? '1st Place' : position === 'second' ? '2nd Place' : '3rd Place';
                                
                                if (tb.winner === player.name) {
                                    tiedPosition = positionName;
                                    result = 'Winner';
                                } else if (tb.runnerUps && tb.runnerUps.includes(player.name)) {
                                    tiedPosition = positionName;
                                    result = 'Runner-up';
                                }
                            });
                        }
                    }
                    
                    // If we still can't determine, this might be a data issue - show as participated
                    if (tiedPosition === 'Unknown') {
                        tiedPosition = 'Tiebreaker Participant';
                        result = 'Participated';
                    }
                    
                    console.log('Export final result for ' + player.name + ': tiedPosition=' + tiedPosition + ', result=' + result);
                    
                    htmlContent += `
                            <tr>
                                <td><strong>${getPlayerNameWithTeam(player.name)}</strong></td>
                                <td>${tiedPosition}</td>
                                <td class="score-cell">${totalTiebreakerPoints}</td>
                                <td style="color: ${result === 'Winner' ? '#22c55e' : result === 'Runner-up' ? '#f59e0b' : '#94a3b8'}; font-weight: bold;">${result}</td>
                            </tr>`;
                });
                
                htmlContent += `
                        </tbody>
                        </table>
                    </div>
                </div>
            </div>`;
            }
            
            // Round-by-Round Breakdown
            // The breakdown format depends on play mode
            if (gameState.playMode === 'consecutive') {
                // CONSECUTIVE MODE: Show all rounds at each distance
                htmlContent += `
            <div class="section">
                <h3>üìä Distance-by-Distance Breakdown</h3>`;
                
                for (var distance = 1; distance <= gameState.numDistances; distance++) {
                    var distanceLabel = gameState.distances[distance - 1] || 'Distance ' + distance;
                    
                    htmlContent += `
                <div class="distance-section">
                    <h4 style="color: #f1f5f9; margin-bottom: 20px; font-size: 1.3rem; text-align: center; background: #334155; padding: 15px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 1px solid #475569;">${distanceLabel}</h4>
                    <div class="table-wrapper">
                        <table style="font-size: 0.9rem;">
                            <thead>
                                <tr>
                                    <th style="min-width: 120px;">Player</th>`;
                    
                    // Create column headers for each round
                    for (var round = 1; round <= gameState.rounds; round++) {
                        htmlContent += `<th style="text-align: center; min-width: 80px;">Round ${round}</th>`;
                    }
                    
                    htmlContent += `
                                    <th style="text-align: center; min-width: 60px; background: rgba(251, 191, 36, 0.3); color: #1e293b;">Distance Total</th>
                                </tr>
                            </thead>
                            <tbody>`;
                    
                    // Add rows for each player
                    gameState.players.forEach(function(player) {
                        var distanceTotal = 0;
                        
                        htmlContent += `
                            <tr>
                                <td><strong>${getPlayerNameWithTeam(player.name)}</strong></td>`;
                        
                        // Add score for each round at this distance
                        for (var round = 1; round <= gameState.rounds; round++) {
                            var roundScores = player.scores[round - 1] && player.scores[round - 1][distance - 1] ? 
                                player.scores[round - 1][distance - 1] : Array(gameState.throwsPerRound).fill(null);
                            var roundTotal = roundScores.reduce(function(sum, score) { return sum + (score || 0); }, 0);
                            distanceTotal += roundTotal;
                            
                            var throwsText = roundScores.map(function(score) { 
                                return score !== null ? score : '-'; 
                            }).join(', ');
                            
                            htmlContent += `
                                <td style="text-align: center;" title="${throwsText}">
                                    <div style="display: flex; gap: 2px; justify-content: center; align-items: center; flex-wrap: wrap;">`;
                            
                            // Show individual throw scores as small badges
                            roundScores.forEach(function(score) {
                                var scoreColor = score === null ? '#64748b' : 
                                               score === 0 ? '#dc2626' : 
                                               score === gameState.maxScore ? '#16a34a' : '#2563eb';
                                htmlContent += `<span style="background: ${scoreColor}; color: white; padding: 2px 4px; border-radius: 3px; font-size: 0.8rem; font-weight: bold; min-width: 16px; text-align: center;">${score !== null ? score : '-'}</span>`;
                            });
                            
                            htmlContent += `
                                        <span style="background: #f59e0b; color: #1e293b; padding: 2px 6px; border-radius: 3px; font-weight: bold; margin-left: 4px; font-size: 0.9rem;">${roundTotal}</span>
                                    </div>
                                </td>`;
                        }
                        
                        htmlContent += `
                                <td style="text-align: center; background: rgba(251, 191, 36, 0.2); font-weight: bold; font-size: 1.1rem; color: #fbbf24;">${distanceTotal}</td>
                            </tr>`;
                    });
                    
                    htmlContent += `
                            </tbody>
                            </table>
                        </div>
                    </div>`;
                }
                
                htmlContent += `
            </div>`;
            } else {
                // SEQUENTIAL MODE: Show all distances in each round (original format)
                htmlContent += `
            <div class="section">
                <h3>üìä Round-by-Round Breakdown</h3>`;
                
                for (var round = 1; round <= gameState.rounds; round++) {
                    htmlContent += `
                <div class="distance-section">
                    <h4 style="color: #f1f5f9; margin-bottom: 20px; font-size: 1.3rem; text-align: center; background: #334155; padding: 15px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 1px solid #475569;">Round ${round}</h4>
                    <div class="table-wrapper">
                        <table style="font-size: 0.9rem;">
                            <thead>
                                <tr>
                                    <th style="min-width: 120px;">Player</th>`;
                    
                    // Create column headers for each distance
                    for (var distance = 1; distance <= gameState.numDistances; distance++) {
                        var distanceLabel = gameState.distances[distance - 1] || 'Distance ' + distance;
                        var shortLabel = distanceLabel.includes('Meters') ? 
                            distanceLabel.replace(' Meters', 'M').replace(' meters', 'm') :
                            (distanceLabel.length > 8 ? distanceLabel.substring(0, 6) + '...' : distanceLabel);
                        htmlContent += `<th style="text-align: center; min-width: 80px;">${shortLabel}</th>`;
                    }
                    
                    htmlContent += `
                                    <th style="text-align: center; min-width: 60px; background: rgba(251, 191, 36, 0.3); color: #1e293b;">Round Total</th>
                                </tr>
                            </thead>
                            <tbody>`;
                    
                    // Add rows for each player
                    gameState.players.forEach(function(player) {
                        var roundTotal = 0;
                        
                        htmlContent += `
                            <tr>
                                <td><strong>${getPlayerNameWithTeam(player.name)}</strong></td>`;
                        
                        // Add score for each distance in this round
                        for (var distance = 1; distance <= gameState.numDistances; distance++) {
                            var distanceScores = player.scores[round - 1] && player.scores[round - 1][distance - 1] ? 
                                player.scores[round - 1][distance - 1] : Array(gameState.throwsPerRound).fill(null);
                            var distanceTotal = distanceScores.reduce(function(sum, score) { return sum + (score || 0); }, 0);
                            roundTotal += distanceTotal;
                            
                            var throwsText = distanceScores.map(function(score) { 
                                return score !== null ? score : '-'; 
                            }).join(', ');
                            
                            htmlContent += `
                                <td style="text-align: center;" title="${throwsText}">
                                    <div style="display: flex; gap: 2px; justify-content: center; align-items: center; flex-wrap: wrap;">`;
                            
                            // Show individual throw scores as small badges
                            distanceScores.forEach(function(score) {
                                var scoreColor = score === null ? '#64748b' : 
                                               score === 0 ? '#dc2626' : 
                                               score === gameState.maxScore ? '#16a34a' : '#2563eb';
                                htmlContent += `<span style="background: ${scoreColor}; color: white; padding: 2px 4px; border-radius: 3px; font-size: 0.8rem; font-weight: bold; min-width: 16px; text-align: center;">${score !== null ? score : '-'}</span>`;
                            });
                            
                            htmlContent += `
                                        <span style="background: #f59e0b; color: #1e293b; padding: 2px 6px; border-radius: 3px; font-weight: bold; margin-left: 4px; font-size: 0.9rem;">${distanceTotal}</span>
                                    </div>
                                </td>`;
                        }
                        
                        htmlContent += `
                                <td style="text-align: center; background: rgba(251, 191, 36, 0.2); font-weight: bold; font-size: 1.1rem; color: #fbbf24;">${roundTotal}</td>
                            </tr>`;
                    });
                    
                    htmlContent += `
                            </tbody>
                            </table>
                        </div>
                    </div>`;
                }
                
                htmlContent += `
            </div>`;
            }
            
            // Rankings per Distance
            htmlContent += `
            <div class="section">
                <h3>üéØ Rankings per Distance</h3>`;
            
            for (var distance = 1; distance <= gameState.numDistances; distance++) {
                var distanceLabel = gameState.distances[distance - 1] || 'Distance ' + distance;
                
                // Calculate total score per player for this distance
                var distanceRankings = gameState.players.map(function(player) {
                    var distanceTotal = 0;
                    var throwsCompleted = 0;
                    
                    for (var round = 0; round < gameState.rounds; round++) {
                        if (player.scores[round] && player.scores[round][distance - 1]) {
                            player.scores[round][distance - 1].forEach(function(score) {
                                if (score !== null) {
                                    distanceTotal += score;
                                    throwsCompleted++;
                                }
                            });
                        }
                    }
                    
                    var maxPossibleForDistance = gameState.rounds * gameState.throwsPerRound * gameState.maxScore;
                    var distancePercentage = maxPossibleForDistance > 0 ? ((distanceTotal / maxPossibleForDistance) * 100).toFixed(1) : 0;
                    var distanceAverage = throwsCompleted > 0 ? (distanceTotal / throwsCompleted).toFixed(2) : 0;
                    
                    return {
                        name: player.name,
                        total: distanceTotal,
                        average: distanceAverage,
                        percentage: distancePercentage,
                        throwsCompleted: throwsCompleted,
                        maxPossible: maxPossibleForDistance
                    };
                }).sort(function(a, b) {
                    return b.total - a.total;
                });
                
                htmlContent += `
                <div class="distance-section">
                    <h4 style="margin-bottom: 20px; font-size: 1.3rem; text-align: center; background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1e293b; padding: 15px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${distanceLabel} Rankings</h4>
                    <div class="table-wrapper">
                        <table style="font-size: 0.9rem;">
                            <thead>
                                <tr>
                                    <th style="min-width: 60px;">Rank</th>
                                <th style="min-width: 120px;">Player</th>
                                <th style="text-align: center; min-width: 80px;">Total Score</th>
                                <th style="text-align: center; min-width: 80px;">Average</th>
                                <th style="text-align: center; min-width: 80px;">Efficiency</th>
                                <th style="text-align: center; min-width: 100px;">Throws Completed</th>
                            </tr>
                        </thead>
                        <tbody>`;
                
                distanceRankings.forEach(function(player, index) {
                    var rank = index + 1;
                    var rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank.toString();
                    var rankStyle = rank <= 3 ? 'font-weight: bold; color: #fbbf24;' : '';
                    var rowStyle = rank <= 3 ? 'background: rgba(251, 191, 36, 0.15);' : '';
                    
                    htmlContent += `
                            <tr style="${rowStyle}">
                                <td style="text-align: center; ${rankStyle}">${rankEmoji}</td>
                                <td><strong>${getPlayerNameWithTeam(player.name)}</strong></td>
                                <td style="text-align: center; font-weight: bold; ${rankStyle}">${player.total}</td>
                                <td style="text-align: center;">${player.average}</td>
                                <td style="text-align: center;">${player.percentage}%</td>
                                <td style="text-align: center; color: #94a3b8;">${player.throwsCompleted}/${gameState.rounds * gameState.throwsPerRound}</td>
                            </tr>`;
                });
                
                htmlContent += `
                        </tbody>
                        </table>
                    </div>
                </div>`;
            }
            
            htmlContent += `
            </div>`;
            
            htmlContent += `
        </div>
        
        <div class="footer">
            <div>Report generated by <strong>Triple Nickel Walkback Scoring System</strong></div>
            <div class="export-date">Generated on ${date.toLocaleDateString()} at ${date.toLocaleTimeString()}</div>
        </div>
    </div>
</body>
</html>`;
            
            var filename = 'walkback-game-' + (gameState.gameName ? gameState.gameName.toLowerCase().replace(/[^a-z0-9]/g, '-') + '-' : '') + date.toISOString().split('T')[0] + '.html';
            
            // Store the HTML content for tournament events
            if (gameState.playersImported && gameState.gameName) {
                console.log('üìÑ Storing game report for tournament...');
                storeGameReportForTournament(htmlContent, filename);
            }
            
            console.log('üìÑ Downloading report file...');
            downloadTextFile(htmlContent, filename);
            console.log('‚úÖ exportData() completed - report downloaded');
            // Export notification removed
        }

        function toggleSettings() {
            settingsVisible = !settingsVisible;
            var panel = document.getElementById('settingsPanel');
            if (settingsVisible) {
                panel.style.display = 'block';
                updateSettingsPanel();
            } else {
                panel.style.display = 'none';
            }
        }

        function updateSettingsPanel() {
            var gameStarted = hasGameStarted();
            
            document.getElementById('gameNameInput').value = gameState.gameName || '';
            document.getElementById('roundsSelect').value = gameState.rounds || 4;
            document.getElementById('throwsPerRoundSelect').value = gameState.throwsPerRound || 3;
            
            // Update track progress if open
            refreshTrackProgressIfOpen();
            
            // Update number of distances - handle default presets properly
            var numDistancesSelect = document.getElementById('numDistancesSelect');
            if (numDistancesSelect) {
                if (gameState.distancePreset && gameState.distancePreset !== 'custom') {
                    // For default presets, use the actual number of distances
                    numDistancesSelect.value = gameState.distances.length;
                } else {
                    // For custom, use the stored value
                    numDistancesSelect.value = gameState.numDistances || 5;
                }
            }
            document.getElementById('maxScoreSelect').value = gameState.maxScore || 5;
            
            // Ensure playMode is set to consecutive if not set (new default)
            if (!gameState.playMode) {
                gameState.playMode = 'consecutive';
            }
            document.getElementById('playModeSelect').value = gameState.playMode;
            
            // Update distances on top checkbox
            // Set default based on play mode if not already set
            if (gameState.distancesOnTop === undefined || gameState.distancesOnTop === null) {
                gameState.distancesOnTop = (gameState.playMode === 'sequential');
            }
            var distancesOnTopCheckbox = document.getElementById('distancesOnTopCheckbox');
            if (distancesOnTopCheckbox) {
                distancesOnTopCheckbox.checked = gameState.distancesOnTop;
            }
            
            // Handle distance preset dropdown - check if we have a custom preset loaded
            var distancePresetSelect = document.getElementById('distancePresetSelect');
            if (distancePresetSelect) {
                if (gameState.distancePreset === 'custom' && gameState.gameName) {
                    // Check if this matches a custom preset
                    var customPresets = JSON.parse(localStorage.getItem('walkbackCustomPresets') || '{}');
                    var customPresetName = gameState.gameName;
                    if (customPresets[customPresetName]) {
                        distancePresetSelect.value = 'custom_' + customPresetName;
                    } else {
                        distancePresetSelect.value = 'custom';
                    }
                } else if (gameState.distancePreset && gameState.distancePreset !== 'amateur' && gameState.distancePreset !== 'professional') {
                    // Handle new default presets
                    distancePresetSelect.value = gameState.distancePreset;
                } else {
                    distancePresetSelect.value = gameState.distancePreset || 'amateur';
                }
            }
            document.getElementById('tiebreakerSelect').value = gameState.tiebreakerMode || 'sudden-death-podium-match';
            
            updateCustomDistanceInputs();
            
            var warning = document.getElementById('gameStartedWarning');
            if (warning) {
                warning.style.display = gameStarted ? 'block' : 'none';
            }
            
            // Disable inputs if game started
            var inputs = ['gameNameInput', 'roundsSelect', 'throwsPerRoundSelect', 'numDistancesSelect', 'maxScoreSelect', 'playModeSelect', 'distancePresetSelect', 'tiebreakerSelect'];
            inputs.forEach(function(inputId) {
                var input = document.getElementById(inputId);
                if (input) {
                    input.disabled = gameStarted;
                    input.style.opacity = gameStarted ? '0.5' : '1';
                }
            });
            
            // Disable distance inputs if game started or not custom
            var customDistanceInputs = document.querySelectorAll('#customDistanceInputs input');
            customDistanceInputs.forEach(function(input) {
                var selectedValue = document.getElementById('distancePresetSelect').value;
                var isCustomPreset = selectedValue === 'custom' || selectedValue.startsWith('custom_');
                input.disabled = gameStarted || !isCustomPreset;
                input.style.opacity = (gameStarted || !isCustomPreset) ? '0.5' : '1';
            });
            
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn) {
                applyBtn.disabled = gameStarted;
                applyBtn.style.opacity = gameStarted ? '0.5' : '1';
                applyBtn.classList.remove('apply-glow');
            }
            
            var savePresetBtn = document.getElementById('savePresetBtn');
            if (savePresetBtn) {
                savePresetBtn.disabled = gameStarted;
                savePresetBtn.style.opacity = gameStarted ? '0.5' : '1';
            }
            
            // Remove preset button is always enabled since it doesn't affect game state
            
            // Show/hide tournament status section if players were imported
            var tournamentStatusSection = document.getElementById('tournamentStatusSection');
            if (tournamentStatusSection) {
                tournamentStatusSection.style.display = (gameState.playersImported && gameState.gameName) ? 'block' : 'none';
            }
        }

        function updateCustomDistanceInputs() {
            var container = document.getElementById('customDistanceInputs');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Use the actual number of distances from the distances array
            var numDistances = gameState.distances.length;
            
            for (var i = 0; i < numDistances; i++) {
                var inputDiv = document.createElement('div');
                inputDiv.style.cssText = 'display: flex; flex-direction: column;';
                
                var label = document.createElement('label');
                label.style.cssText = 'font-size: 0.8rem; color: #94a3b8; margin-bottom: 5px;';
                label.textContent = 'Distance ' + (i + 1);
                
                var input = document.createElement('input');
                input.type = 'text';
                input.id = 'distance' + (i + 1);
                input.placeholder = 'e.g., ' + (i + 2) + ' Meters';
                input.maxLength = 20;
                input.style.cssText = 'background: #475569; border: 1px solid #64748b; color: white; padding: 8px; border-radius: 6px; font-size: 0.8rem; outline: none;';
                
                // Use the actual saved distance value, not a placeholder
                input.value = gameState.distances[i] || '';
                
                inputDiv.appendChild(label);
                inputDiv.appendChild(input);
                container.appendChild(inputDiv);
            }
        }

        // Generate target rings based on max score
        function generateTargetRings() {
            var rings = [];
            for (var i = gameState.maxScore; i >= 0; i--) {
                rings.push(i);
            }
            return rings;
        }

        // Generate unique colors for each score value
        function getScoreColor(score) {
            var colors = {
                0: '#ef4444',   // Red (miss)
                1: '#f87171',   // Light Red
                2: '#fb923c',   // Orange
                3: '#fbbf24',   // Yellow
                4: '#84cc16',   // Lime
                5: '#22c55e',   // Green (traditional bullseye)
                6: '#10b981',   // Emerald
                7: '#06b6d4',   // Cyan
                8: '#3b82f6',   // Blue
                9: '#6366f1',   // Indigo
                10: '#8b5cf6',  // Violet
                11: '#a855f7',  // Purple
                12: '#c026d3',  // Fuchsia
                13: '#e11d48',  // Rose
                14: '#dc2626',  // Red
                15: '#ea580c',  // Orange
                16: '#ca8a04',  // Yellow
                17: '#65a30d',  // Green
                18: '#059669',  // Emerald
                19: '#0891b2',  // Cyan
                20: '#7c3aed'   // Violet
            };
            
            return colors[score] || '#6b7280'; // Default gray for undefined scores
        }

        function getScoreTextColor(score) {
            // All numbers should be white for consistent appearance
            return 'white';
        }

        function updatePlayerName(playerId, newName) {
            var player = gameState.players.find(function(p) { return p.id === playerId; });
            if (player) {
                player.name = newName || 'Player ' + playerId;
                saveGameState(); // Auto-save after name change
            }
        }

        function updateMaxScore() {
            if (hasGameStarted()) {
                alert('Cannot change max score after game has started! Reset the game to change this setting.');
                document.getElementById('maxScoreSelect').value = gameState.maxScore;
                return;
            }
            
            var newMaxScore = parseInt(document.getElementById('maxScoreSelect').value);
            if (newMaxScore === gameState.maxScore) return;
            
            gameState.maxScore = newMaxScore;
            gameState.targetRings = generateTargetRings();
            
            // Recalculate all player stats since max score changed
            gameState.players.forEach(function(player) {
                recalculatePlayerStats(player);
            });
            
            updateGameDisplay();
            renderPlayers();
        }

        function updateThrowsPerRound() {
            if (hasGameStarted()) {
                alert('Cannot change throws per round after game has started! Reset the game to change this setting.');
                document.getElementById('throwsPerRoundSelect').value = gameState.throwsPerRound;
                return;
            }
            
            var newThrowsPerRound = parseInt(document.getElementById('throwsPerRoundSelect').value);
            if (newThrowsPerRound === gameState.throwsPerRound) return;
            
            gameState.throwsPerRound = newThrowsPerRound;
            
            // Update all player scores arrays to match new throws per round
            gameState.players.forEach(function(player) {
                for (var r = 0; r < gameState.rounds; r++) {
                    if (player.scores[r]) {
                        for (var d = 0; d < player.scores[r].length; d++) {
                            if (player.scores[r][d]) {
                                // Adjust existing distance scores to match new throws per round
                                if (player.scores[r][d].length > newThrowsPerRound) {
                                    player.scores[r][d] = player.scores[r][d].slice(0, newThrowsPerRound);
                                } else if (player.scores[r][d].length < newThrowsPerRound) {
                                    for (var t = player.scores[r][d].length; t < newThrowsPerRound; t++) {
                                        player.scores[r][d].push(null);
                                    }
                                }
                            } else {
                                player.scores[r][d] = Array(newThrowsPerRound).fill(null);
                            }
                        }
                    }
                }
                
                // Reset player throw position if they're beyond the new throws per round
                if (player.currentThrow > newThrowsPerRound) {
                    player.currentThrow = newThrowsPerRound;
                }
                
                // Recalculate stats
                recalculatePlayerStats(player);
            });
            
            updateGameDisplay();
            renderPlayers();
            
            // Settings notification removed
        }

        function updateNumDistances() {
            if (hasGameStarted()) {
                alert('Cannot change number of distances after game has started! Reset the game to change this setting.');
                document.getElementById('numDistancesSelect').value = gameState.numDistances;
                return;
            }
            
            var newNumDistances = parseInt(document.getElementById('numDistancesSelect').value);
            if (newNumDistances === gameState.numDistances) return;
            
            gameState.numDistances = newNumDistances;
            
            // Update distances based on current preset
            var preset = document.getElementById('distancePresetSelect').value;
            if (preset !== 'custom') {
                gameState.distances = getDefaultDistances(preset, newNumDistances);
            } else {
                // For custom, adjust the distances array length
                if (gameState.distances.length > newNumDistances) {
                    gameState.distances = gameState.distances.slice(0, newNumDistances);
                } else if (gameState.distances.length < newNumDistances) {
                    for (var i = gameState.distances.length; i < newNumDistances; i++) {
                        gameState.distances.push((i + 2) + ' Meters');
                    }
                }
            }
            
            // Update all player scores arrays
            gameState.players.forEach(function(player) {
                for (var r = 0; r < gameState.rounds; r++) {
                    if (!player.scores[r]) {
                        player.scores[r] = Array(newNumDistances).fill(null).map(function() { return Array(gameState.throwsPerRound).fill(null); });
                    } else {
                        // Adjust existing round to match new distance count
                        if (player.scores[r].length > newNumDistances) {
                            player.scores[r] = player.scores[r].slice(0, newNumDistances);
                        } else if (player.scores[r].length < newNumDistances) {
                            for (var d = player.scores[r].length; d < newNumDistances; d++) {
                                player.scores[r].push(Array(gameState.throwsPerRound).fill(null));
                            }
                        }
                    }
                }
                
                // Reset player position if they're beyond the new number of distances
                if (player.currentDistance > newNumDistances) {
                    player.currentDistance = newNumDistances;
                    player.viewingDistance = newNumDistances;
                }
                
                // Recalculate stats
                recalculatePlayerStats(player);
            });
            
            updateCustomDistanceInputs();
            updateGameDisplay();
            renderPlayers();
            
            // Settings notification removed
        }

        function updateDistancesOnTop() {
            var checkbox = document.getElementById('distancesOnTopCheckbox');
            if (checkbox) {
                gameState.distancesOnTop = checkbox.checked;
                renderPlayers();
            }
        }

        function updatePlayMode() {
            if (hasGameStarted()) {
                alert('Cannot change play mode after game has started! Reset the game to change this setting.');
                document.getElementById('playModeSelect').value = gameState.playMode;
                return;
            }
            
            var newPlayMode = document.getElementById('playModeSelect').value;
            if (newPlayMode === gameState.playMode) return;
            
            gameState.playMode = newPlayMode;
            
            // Set default checkbox state based on play mode
            // Sequential mode: checked by default, Consecutive mode: unchecked by default
            if (newPlayMode === 'sequential') {
                gameState.distancesOnTop = true;
            } else {
                gameState.distancesOnTop = false;
            }
            
            // Update checkbox to reflect the new state
            var distancesOnTopCheckbox = document.getElementById('distancesOnTopCheckbox');
            if (distancesOnTopCheckbox) {
                distancesOnTopCheckbox.checked = gameState.distancesOnTop;
            }
            
            // Reset all players to starting position since play mode affects progression
            gameState.players.forEach(function(player) {
                player.currentRound = 1;
                player.currentDistance = 1;
                player.currentThrow = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
            });
            
            updateGameDisplay();
            renderPlayers();
            
            var modeDescription = newPlayMode === 'consecutive' ? 
                'Consecutive Rounds (complete all rounds at each distance)' : 
                'Sequential Distance (cycle through all distances each round)';
            
            // Settings notification removed
        }

        function updateRoundsCount() {
            if (hasGameStarted()) {
                alert('Cannot change number of rounds after game has started! Reset the game to change this setting.');
                document.getElementById('roundsSelect').value = gameState.rounds;
                return;
            }
            
            var newRounds = parseInt(document.getElementById('roundsSelect').value);
            if (newRounds === gameState.rounds) return;
            
            gameState.rounds = newRounds;
            
            // Update all player scores arrays - rounds are cycles through all distances
            gameState.players.forEach(function(player) {
                if (player.scores.length > newRounds) {
                    player.scores = player.scores.slice(0, newRounds);
                } else if (player.scores.length < newRounds) {
                    for (var i = player.scores.length; i < newRounds; i++) {
                        player.scores.push(Array(gameState.distances.length).fill(null).map(function() { return Array(gameState.throwsPerRound).fill(null); }));
                    }
                }
                
                // Reset player position if they're beyond the new number of rounds
                if (player.currentRound > newRounds) {
                    player.currentRound = newRounds;
                    player.currentDistance = 1;
                    player.viewingRound = newRounds;
                    player.viewingDistance = 1;
                }
                
                // Recalculate stats
                recalculatePlayerStats(player);
            });
            
            updateGameDisplay();
            renderPlayers();
            
            // Settings notification removed
        }

        function updateDistancePreset() {
            var preset = document.getElementById('distancePresetSelect').value;
            var customGroup = document.getElementById('customDistanceGroup');
            
            // Check if this is a custom preset (starts with "custom_")
            if (preset && preset.startsWith('custom_')) {
                var presetName = preset.substring(7); // Remove "custom_" prefix
                loadCustomPreset(presetName);
                return;
            }
            
            if (customGroup) {
                // Show custom distance inputs for both 'custom' and custom presets
                var shouldShowCustom = preset === 'custom' || preset.startsWith('custom_');
                customGroup.style.display = shouldShowCustom ? 'block' : 'none';
            }
            
            if (preset === 'custom') {
                // Handle custom preset selection
                if (!hasGameStarted()) {
                    // Set the Game Name to Custom
                    gameState.gameName = 'Custom (Set your own)';
                    gameState.distancePreset = 'custom';
                    
                    // Update the Game Name input field
                    var gameNameInput = document.getElementById('gameNameInput');
                    if (gameNameInput) {
                        gameNameInput.value = 'Custom (Set your own)';
                    }
                    
                    // Update custom distance inputs to show current distances
                    updateCustomDistanceInputs();
                }
                return;
            }
            
            if (!hasGameStarted() && preset !== 'custom') {
                // Get the distances for this preset
                var presetDistances = getDefaultDistances(preset);
                
                // Update gameState with the preset distances and number of distances
                gameState.distances = presetDistances;
                gameState.numDistances = presetDistances.length;
                gameState.distancePreset = preset;
                
                // Set the Game Name to the selected preset
                var presetDisplayName = getPresetDisplayName(preset);
                gameState.gameName = presetDisplayName;
                
                // Update the Game Name input field
                var gameNameInput = document.getElementById('gameNameInput');
                if (gameNameInput) {
                    gameNameInput.value = presetDisplayName;
                }
                
                // Set throws per round to 3 for all default presets
                gameState.throwsPerRound = 3;
                // Update the throws per round dropdown to reflect this
                var throwsSelect = document.getElementById('throwsPerRoundSelect');
                if (throwsSelect) {
                    throwsSelect.value = 3;
                }
                
                // Set specific rounds and max score for Dangerfest presets
                if (preset.startsWith('dangerfest_')) {
                    gameState.rounds = 4;
                    gameState.maxScore = 5;
                    
                    // Update the rounds dropdown
                    var roundsSelect = document.getElementById('roundsSelect');
                    if (roundsSelect) {
                        roundsSelect.value = 4;
                    }
                    
                    // Update the max score dropdown
                    var maxScoreSelect = document.getElementById('maxScoreSelect');
                    if (maxScoreSelect) {
                        maxScoreSelect.value = 5;
                    }
                }
                
                // Set specific settings for AKTA preset
                if (preset === 'akta') {
                    gameState.rounds = 4;
                    gameState.throwsPerRound = 5;
                    gameState.maxScore = 5;
                    
                    // Update the rounds dropdown
                    var roundsSelect = document.getElementById('roundsSelect');
                    if (roundsSelect) {
                        roundsSelect.value = 4;
                    }
                    
                    // Update the throws per round dropdown
                    var throwsSelect = document.getElementById('throwsPerRoundSelect');
                    if (throwsSelect) {
                        throwsSelect.value = 5;
                    }
                    
                    // Update the max score dropdown
                    var maxScoreSelect = document.getElementById('maxScoreSelect');
                    if (maxScoreSelect) {
                        maxScoreSelect.value = 5;
                    }
                }
                
                // Set specific settings for Blade Aces presets
                if (preset === 'blade_aces_am_knife' || preset === 'blade_aces_pro_knife' || preset === 'blade_aces_am_hawk' || preset === 'blade_aces_pro_hawk') {
                    gameState.rounds = 4;
                    gameState.maxScore = 5;
                    
                    // Update the rounds dropdown
                    var roundsSelect = document.getElementById('roundsSelect');
                    if (roundsSelect) {
                        roundsSelect.value = 4;
                    }
                    
                    // Update the max score dropdown
                    var maxScoreSelect = document.getElementById('maxScoreSelect');
                    if (maxScoreSelect) {
                        maxScoreSelect.value = 5;
                    }
                }
                
                // Update the number of distances dropdown to reflect the preset
                var numDistancesSelect = document.getElementById('numDistancesSelect');
                if (numDistancesSelect) {
                    numDistancesSelect.value = presetDistances.length;
                }
                
                // Update player scores arrays to match new distances and throws per round
                gameState.players.forEach(function(player) {
                    for (var r = 0; r < gameState.rounds; r++) {
                        if (!player.scores[r]) {
                            player.scores[r] = Array(gameState.distances.length).fill(null).map(function() { return Array(gameState.throwsPerRound).fill(null); });
                        } else {
                            // Adjust existing round to match new distance count
                            if (player.scores[r].length > gameState.distances.length) {
                                player.scores[r] = player.scores[r].slice(0, gameState.distances.length);
                            } else if (player.scores[r].length < gameState.distances.length) {
                                for (var d = player.scores[r].length; d < gameState.distances.length; d++) {
                                    player.scores[r].push(Array(gameState.throwsPerRound).fill(null));
                                }
                            }
                            
                            // Adjust existing distances to match new throws per round
                            for (var d = 0; d < player.scores[r].length; d++) {
                                if (player.scores[r][d]) {
                                    if (player.scores[r][d].length > gameState.throwsPerRound) {
                                        player.scores[r][d] = player.scores[r][d].slice(0, gameState.throwsPerRound);
                                    } else if (player.scores[r][d].length < gameState.throwsPerRound) {
                                        for (var t = player.scores[r][d].length; t < gameState.throwsPerRound; t++) {
                                            player.scores[r][d].push(null);
                                        }
                                    }
                                } else {
                                    player.scores[r][d] = Array(gameState.throwsPerRound).fill(null);
                                }
                            }
                        }
                    }
                    
                    // Reset player position if they're beyond the new number of distances
                    if (player.currentDistance > gameState.distances.length) {
                        player.currentDistance = gameState.distances.length;
                        player.viewingDistance = gameState.distances.length;
                    }
                    
                    // Recalculate stats
                    recalculatePlayerStats(player);
                });
                
                updateCustomDistanceInputs();
                renderPlayers();
                updateGameDisplay();
                // Settings notification removed
            } else if (hasGameStarted() && preset !== 'custom') {
                showTimedNotification('‚ö†Ô∏è Cannot change preset after game starts. Use custom distances or reset game.', 3000);
                document.getElementById('distancePresetSelect').value = 'custom';
                if (customGroup) customGroup.style.display = 'block';
            }
        }

        function getPresetDisplayName(preset) {
            var displayNames = {
                'custom': 'Custom (Set your own)',
                'dangerfest_am_knife': 'Dangerfest Am Knife',
                'dangerfest_pro_knife': 'Dangerfest Pro Knife',
                'dangerfest_am_hawk': 'Dangerfest Am Hawk',
                'dangerfest_pro_hawk': 'Dangerfest Pro Hawk',
                'akta': 'AKTA',
                'blade_aces_am_knife': 'Blade Aces Am Knife',
                'blade_aces_pro_knife': 'Blade Aces Pro Knife',
                'blade_aces_am_hawk': 'Blade Aces Am Hawk',
                'blade_aces_pro_hawk': 'Blade Aces Pro Hawk'
            };
            
            return displayNames[preset] || preset;
        }

        function getDefaultDistances(preset, numDistances) {
            var distances = [];
            
            if (preset === 'dangerfest_am_knife') {
                distances = ['2 Meters', '3 Meters', '4 Meters', '5 Meters', '6 Meters'];
            } else if (preset === 'dangerfest_pro_knife') {
                distances = ['3 Meters', '4 Meters', '5 Meters', '6 Meters', '7 Meters'];
            } else if (preset === 'dangerfest_am_hawk') {
                distances = ['3 Meters', '4 Meters', '5 Meters', '7 Meters'];
            } else if (preset === 'dangerfest_pro_hawk') {
                distances = ['3 Meters', '4 Meters', '5 Meters', '7 Meters', '9 Meters'];
            } else if (preset === 'akta') {
                distances = ['7 Feet', '10 Feet', '13 Feet', '16 Feet'];
            } else if (preset === 'blade_aces_am_knife') {
                distances = ['2 Meters', '3 Meters', '4 Meters', '5 Meters'];
            } else if (preset === 'blade_aces_pro_knife') {
                distances = ['3 Meters', '4 Meters', '5 Meters', '6 Meters', '7 Meters'];
            } else if (preset === 'blade_aces_am_hawk') {
                distances = ['3 Meters', '4 Meters', '5 Meters'];
            } else if (preset === 'blade_aces_pro_hawk') {
                distances = ['3 Meters', '4 Meters', '5 Meters', '7 Meters', '9 Meters'];
            } else {
                // Return current distances or generate default
                return gameState.distances.slice(0, numDistances || gameState.numDistances);
            }
            
            return distances;
        }

        function recalculatePlayerStats(player) {
            var total = 0;
            var completedThrows = 0;
            var bullseyes = 0;
            var tripleNickels = 0;
            var noDrops = 0;
            var completedSets = 0;
            var pointsInCompletedSets = 0;
            
            player.scores.forEach(function(round) {
                if (round) {
                    round.forEach(function(distance) {
                        if (distance) {
                            var distanceBullseyes = 0;
                            var distanceComplete = true;
                            var distanceHasZero = false;
                            var distanceTotal = 0;
                            
                            distance.forEach(function(throwScore) {
                                if (throwScore !== null) {
                                    total += throwScore;
                                    completedThrows++;
                                    distanceTotal += throwScore;
                                    
                                    if (throwScore === gameState.maxScore) {
                                        bullseyes++;
                                        distanceBullseyes++;
                                    }
                                    
                                    if (throwScore === 0) {
                                        distanceHasZero = true;
                                    }
                                } else {
                                    distanceComplete = false;
                                }
                            });
                            
                            // Only count completed sets/distances for efficiency
                            if (distanceComplete) {
                                completedSets++;
                                pointsInCompletedSets += distanceTotal;
                                
                                // Triple Nickels: all throws at this distance are max score
                                if (distanceBullseyes === gameState.throwsPerRound) {
                                    tripleNickels++;
                                }
                                
                                // No Drops: all throws at this distance are > 0
                                if (!distanceHasZero) {
                                    noDrops++;
                                }
                            }
                        }
                    });
                }
            });
            
            player.total = total;
            player.average = completedThrows > 0 ? (total / completedThrows).toFixed(2) : 0;
            player.bullseyes = bullseyes;
            player.tripleNickels = tripleNickels;
            player.noDrops = noDrops;
            
            // Calculate efficiency based on completed sets (distances) only
            var maxPossiblePerSet = gameState.throwsPerRound * gameState.maxScore;
            var maxPossibleInCompletedSets = completedSets * maxPossiblePerSet;
            player.percentage = maxPossibleInCompletedSets > 0 ? 
                ((pointsInCompletedSets / maxPossibleInCompletedSets) * 100).toFixed(1) : 0;
        }

        function markSettingsChanged() {
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn && !applyBtn.disabled) {
                applyBtn.classList.add('apply-glow');
            }
        }
        
        function resetSettingsToDefaultsInPanel() {
            if (hasGameStarted()) {
                alert('Cannot reset settings after game has started! Reset the game to change settings.');
                return;
            }
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn) applyBtn.classList.remove('apply-glow');
            var newRounds = 4;
            var newNumDistances = 5;
            var newMaxScore = 5;
            var newPlayMode = 'consecutive';
            var newDistancePreset = 'amateur';
            var newTiebreakerMode = 'sudden-death-podium-match';
            var newGameName = '';
            gameState.rounds = newRounds;
            gameState.throwsPerRound = 3;
            gameState.numDistances = newNumDistances;
            gameState.maxScore = newMaxScore;
            gameState.playMode = newPlayMode;
            gameState.distancePreset = newDistancePreset;
            gameState.tiebreakerMode = newTiebreakerMode;
            gameState.gameName = newGameName;
            gameState.targetRings = generateTargetRings();
            gameState.distances = getDefaultDistances(newDistancePreset, newNumDistances);
            gameState.players.forEach(function(player) {
                if (player.scores.length > newRounds) {
                    player.scores = player.scores.slice(0, newRounds);
                } else if (player.scores.length < newRounds) {
                    for (var i = player.scores.length; i < newRounds; i++) {
                        player.scores.push(Array(newNumDistances).fill(null).map(function() { return Array(gameState.throwsPerRound).fill(null); }));
                    }
                }
                for (var r = 0; r < newRounds; r++) {
                    if (!player.scores[r]) {
                        player.scores[r] = Array(newNumDistances).fill(null).map(function() { return Array(gameState.throwsPerRound).fill(null); });
                    } else {
                        if (player.scores[r].length > newNumDistances) {
                            player.scores[r] = player.scores[r].slice(0, newNumDistances);
                        } else if (player.scores[r].length < newNumDistances) {
                            for (var d = player.scores[r].length; d < newNumDistances; d++) {
                                player.scores[r].push(Array(gameState.throwsPerRound).fill(null));
                            }
                        } else {
                            for (var d = 0; d < newNumDistances; d++) {
                                player.scores[r][d] = Array(gameState.throwsPerRound).fill(null);
                            }
                        }
                    }
                }
                player.currentRound = 1;
                player.currentDistance = 1;
                player.currentThrow = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
                recalculatePlayerStats(player);
            });
            updateGameDisplay();
            renderPlayers();
            updateSettingsPanel();
            updateCustomDistanceInputs();
            refreshLeaderboardIfOpen();
            refreshTrackProgressIfOpen();
            saveGameState();
            showTimedNotification('Settings reset to defaults.', 2000);
        }
        
        function applySettings() {
            var applyBtn = document.getElementById('applySettingsBtn');
            if (applyBtn) applyBtn.classList.remove('apply-glow');
            var newRounds = parseInt(document.getElementById('roundsSelect').value);
            var newNumDistances = parseInt(document.getElementById('numDistancesSelect').value);
            var newMaxScore = parseInt(document.getElementById('maxScoreSelect').value);
            var newPlayMode = document.getElementById('playModeSelect').value;
            var newDistancePreset = document.getElementById('distancePresetSelect').value;
            var newTiebreakerMode = document.getElementById('tiebreakerSelect').value;
            var newGameName = document.getElementById('gameNameInput').value.trim();
            // Check if game has started
            if (hasGameStarted()) {
                alert('Cannot change settings after game has started! Reset the game to change settings.');
                return;
            }
            
            // Update game state
            gameState.rounds = newRounds;
            gameState.numDistances = newNumDistances;
            gameState.maxScore = newMaxScore;
            gameState.playMode = newPlayMode;
            gameState.distancePreset = newDistancePreset;
            gameState.tiebreakerMode = newTiebreakerMode;
            gameState.gameName = newGameName;
            
            // Update target rings
            gameState.targetRings = generateTargetRings();
            
            // Update distances based on preset
            if (newDistancePreset === 'custom') {
                var customDistances = [];
                var distanceInputs = document.querySelectorAll('#customDistanceInputs input');
                distanceInputs.forEach(function(input) {
                    var value = parseInt(input.value);
                    if (!isNaN(value) && value > 0) {
                        customDistances.push(value + ' Meters');
                    }
                });
                if (customDistances.length > 0) {
                    gameState.distances = customDistances;
                } else {
                    gameState.distances = getDefaultDistances(newDistancePreset, newNumDistances);
                    gameState.distancePreset = newDistancePreset;
                }
            } else {
                gameState.distances = getDefaultDistances(newDistancePreset, newNumDistances);
                gameState.distancePreset = newDistancePreset;
            }
            
            // Update player scores arrays for new rounds and distances count
            gameState.players.forEach(function(player) {
                // Update rounds
                if (player.scores.length > newRounds) {
                    player.scores = player.scores.slice(0, newRounds);
                } else if (player.scores.length < newRounds) {
                    for (var i = player.scores.length; i < newRounds; i++) {
                        player.scores.push(Array(newNumDistances).fill(null).map(function() { return Array(gameState.throwsPerRound).fill(null); }));
                    }
                }
                
                // Update each round to match new distance count
                for (var r = 0; r < newRounds; r++) {
                    if (!player.scores[r]) {
                        player.scores[r] = Array(newNumDistances).fill(null).map(function() { return Array(gameState.throwsPerRound).fill(null); });
                    } else {
                        if (player.scores[r].length > newNumDistances) {
                            player.scores[r] = player.scores[r].slice(0, newNumDistances);
                        } else if (player.scores[r].length < newNumDistances) {
                            for (var d = player.scores[r].length; d < newNumDistances; d++) {
                                player.scores[r].push(Array(gameState.throwsPerRound).fill(null));
                            }
                        }
                    }
                }
                
                // Reset player position if they're beyond the new limits
                if (player.currentRound > newRounds) {
                    player.currentRound = newRounds;
                    player.viewingRound = newRounds;
                }
                if (player.currentDistance > newNumDistances) {
                    player.currentDistance = newNumDistances;
                    player.viewingDistance = newNumDistances;
                }
                
                // Reset positions for mode/setting changes
                player.currentRound = 1;
                player.currentDistance = 1;
                player.currentThrow = 1;
                player.viewingRound = 1;
                player.viewingDistance = 1;
                player.gameComplete = false;
                
                // Recalculate stats
                recalculatePlayerStats(player);
            });
            
            updateGameDisplay();
            renderPlayers();
            
            // Update leaderboard if open
            refreshLeaderboardIfOpen();
            
            // Update track progress if open
            refreshTrackProgressIfOpen();
            
            saveGameState(); // Auto-save after settings change
            // Settings notification removed
            
            // Close settings panel after applying
            document.getElementById('settingsPanel').style.display = 'none';
        }

        function clearScores() {
            showClearScoresConfirm('Clear all scores? This will reset all player scores to zero. Game settings and players will be kept.', function() {
                // Clear all scores for all players (keep current game settings)
                gameState.players.forEach(function(player) {
                    // Reset all scores to null
                    for (var r = 0; r < gameState.rounds; r++) {
                        if (!player.scores[r]) {
                            player.scores[r] = Array(gameState.numDistances).fill(null).map(function() { 
                                return Array(gameState.throwsPerRound).fill(null); 
                            });
                        } else {
                            for (var d = 0; d < gameState.numDistances; d++) {
                                if (!player.scores[r][d]) {
                                    player.scores[r][d] = Array(gameState.throwsPerRound).fill(null);
                                } else {
                                    player.scores[r][d] = Array(gameState.throwsPerRound).fill(null);
                                }
                            }
                        }
                    }
                    
                    // Reset player stats and position
                    player.total = 0;
                    player.average = 0;
                    player.bullseyes = 0;
                    player.tripleNickels = 0;
                    player.noDrops = 0;
                    player.percentage = 0;
                    player.currentRound = 1;
                    player.currentDistance = 1;
                    player.currentThrow = 1;
                    player.viewingRound = 1;
                    player.viewingDistance = 1;
                    player.gameComplete = false;
                    player.tiebreakerScores = [];
                    player.tiebreakerTotal = 0;
                    player.tiebreakerComplete = false;
                    player.tiebreakerCurrentThrow = 1;
                    player.podiumTiebreakerPoints = 0;
                    player.podiumTiebreakerPosition = null;
                    player.podiumTiebreakerInfo = null;
                    player.podiumTiebreakerData = [];
                    player.originalRegulationScore = undefined;
                });
                
                // Reset game state
                gameState.editingThrow = null;
                gameState.gameFinalized = false;
                gameState.inTiebreaker = false;
                gameState.tiebreakerPlayers = [];
                gameState.tiedPlayers = [];
                gameState.tiebreakerRound = 0;
                gameState.podiumTiebreakers = null;
                gameState.podiumTiebreakersBackup = null;
                gameState.allTiebreakerParticipants = null;
                gameState.originalRegulationScoresStored = false;
                gameState.eventSetToInProgress = false; // Reset event status flag so it can be set again
                gameFinalizedOnce = false; // Reset finalization guard
                
                // Update UI
                renderPlayers();
                updateGameDisplay();
                updateAddPlayerButton();
                updateSettingsPanel(); // Re-enable game options since scores are cleared
                updateCustomDistanceInputs(); // Update custom distance inputs
                
                // Update finalize button visibility based on current game state
                updateFinalizeButtonVisibility();
                
                // Update leaderboard if open
                refreshLeaderboardIfOpen();
                
                // Update track progress if open
                refreshTrackProgressIfOpen();
                
                // Close any open popup windows
                if (leaderboardWindow && !leaderboardWindow.closed) {
                    leaderboardWindow.close();
                    leaderboardWindow = null;
                    localStorage.removeItem('walkbackLeaderboardOpen');
                }
                if (victoryWindow && !victoryWindow.closed) {
                    victoryWindow.close();
                    victoryWindow = null;
                }
                if (trackProgressWindow && !trackProgressWindow.closed) {
                    trackProgressWindow.close();
                    trackProgressWindow = null;
                    localStorage.removeItem('walkbackTrackProgressOpen');
                }
                
                // Save the cleared state
                saveGameState();
                
                showTimedNotification('üßπ All scores cleared! Game settings and players preserved.', 3000);
            });
        }

        function clearPlayers() {
            showClearPlayersConfirm('Remove all players? This will delete all players and their data and return all settings to default.', function() {
                // Reset all settings to default values
                gameState.rounds = 4;
                gameState.throwsPerRound = 3;
                gameState.maxScore = 5;
                gameState.targetRings = generateTargetRings();
                gameState.distances = ['2 Meters', '3 Meters', '4 Meters', '5 Meters', '6 Meters'];
                gameState.distancePreset = 'amateur';
                gameState.numDistances = 5;
                gameState.playMode = 'consecutive';
                gameState.gameName = '';
                gameState.tiebreakerMode = 'sudden-death-podium-match';
                
                // Clear all players
                gameState.players = [];
                gameState.editingThrow = null;
                gameState.gameFinalized = false;
                gameState.inTiebreaker = false;
                gameState.tiebreakerPlayers = [];
                gameState.tiedPlayers = [];
                gameState.tiebreakerRound = 0;
                gameState.podiumTiebreakers = null;
                gameState.podiumTiebreakersBackup = null;
                gameState.allTiebreakerParticipants = null;
                gameState.originalRegulationScoresStored = false;
                gameState.playersImported = false; // Reset import flag
                gameState.eventSetToInProgress = false; // Reset event status flag
                gameFinalizedOnce = false; // Reset finalization guard
                // Reset pagination settings
                gameState.currentPage = 1;
                gameState.playersPerPage = 20;
                gameState.totalPages = 1;
                // Reset player ID counter
                playerId = 1;
                // Update UI
                renderPlayers();
                updateSettingsPanel(); // Ensure settings panel is refreshed after rendering
                updateGameDisplay();
                updateSettingsPanel(); // Ensure settings panel is refreshed after game display update
                updateAddPlayerButton();
                updateCustomDistanceInputs(); // Update custom distance inputs
                
                // Update leaderboard if open
                refreshLeaderboardIfOpen();
                
                // Update track progress if open
                refreshTrackProgressIfOpen();
                
                // Close any open popup windows
                if (leaderboardWindow && !leaderboardWindow.closed) {
                    leaderboardWindow.close();
                    leaderboardWindow = null;
                    localStorage.removeItem('walkbackLeaderboardOpen');
                }
                if (victoryWindow && !victoryWindow.closed) {
                    victoryWindow.close();
                    victoryWindow = null;
                }
                if (trackProgressWindow && !trackProgressWindow.closed) {
                    trackProgressWindow.close();
                    trackProgressWindow = null;
                    localStorage.removeItem('walkbackTrackProgressOpen');
                }
                
                // Save the cleared state
                saveGameState();
                showTimedNotification('üë• All players removed and settings reset to default! You can now add new players.', 3000);
            });
        }

        // Helper function to check if game has started
        function hasGameStarted() {
            if (gameState.players.length === 0) return false;
            return gameState.players.some(function(player) {
                return player.scores.some(function(round) {
                    return round && round.some(function(distance) {
                        return distance && distance.some(function(score) {
                            return score !== null;
                        });
                    });
                });
            });
        }

        // Helper function to check if entire game is complete
        function isEntireGameComplete() {
            return gameState.players.length > 0 && gameState.players.every(function(player) {
                return player.gameComplete;
            });
        }
        
        // Helper function to update finalize button visibility
        function updateFinalizeButtonVisibility() {
            var finalizeBtn = document.getElementById('finalizeBtn');
            if (finalizeBtn) {
                if (isEntireGameComplete() && hasGameStarted()) {
                    finalizeBtn.style.display = 'inline-block';
                } else {
                    finalizeBtn.style.display = 'none';
                }
            }
        }

        // Calculate game statistics function
        function calculateGameStatistics(gameState) {
            var stats = {
                highestScore: 0,
                highestScorePlayer: '',
                lowestScore: Infinity,
                lowestScorePlayer: '',
                averageScore: 0,
                totalBullseyes: 0,
                totalTripleNickels: 0,
                perfectRounds: 0,
                zeroRounds: 0
            };
            
            var totalScore = 0;
            
            gameState.players.forEach(function(player) {
                var playerTotal = player.total + (player.tiebreakerTotal || 0);
                
                if (playerTotal > stats.highestScore) {
                    stats.highestScore = playerTotal;
                    stats.highestScorePlayer = player.name;
                }
                
                if (playerTotal < stats.lowestScore) {
                    stats.lowestScore = playerTotal;
                    stats.lowestScorePlayer = player.name;
                }
                
                totalScore += playerTotal;
                stats.totalBullseyes += player.bullseyes;
                stats.totalTripleNickels += player.tripleNickels;
                
                // Count perfect and zero rounds
                player.scores.forEach(function(round) {
                    if (round) {
                        round.forEach(function(distance) {
                            if (distance) {
                                var distanceTotal = distance.reduce(function(sum, score) { return sum + (score || 0); }, 0);
                                var maxDistanceScore = gameState.throwsPerRound * gameState.maxScore;
                                
                                if (distanceTotal === maxDistanceScore) {
                                    stats.perfectRounds++;
                                } else if (distanceTotal === 0) {
                                    stats.zeroRounds++;
                                }
                            }
                        });
                    }
                });
            });
            
            stats.averageScore = gameState.players.length > 0 ? 
                (totalScore / gameState.players.length).toFixed(1) : 0;
            
            if (stats.lowestScore === Infinity) {
                stats.lowestScore = 0;
                stats.lowestScorePlayer = 'N/A';
            }
            
            return stats;
        }

        // Download text file helper function
        function downloadTextFile(content, filename) {
            var blob = new Blob([content], { type: 'text/html' });
            var url = URL.createObjectURL(blob);
            var link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Shared notification function - needs to be defined or imported
        function showTimedNotification(message, duration) {
            // Create notification element
            var notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(30, 41, 59, 0.95);
                color: #e2e8f0;
                padding: 15px 20px;
                border-radius: 10px;
                border: 1px solid #475569;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                z-index: 10000;
                font-size: 0.9rem;
                font-weight: 500;
                max-width: 300px;
                word-wrap: break-word;
                backdrop-filter: blur(10px);
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove notification after duration
            setTimeout(function() {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, duration || 3000);
        }

        // Initialize the game when page loads
        window.addEventListener('load', function() {
            initializeGame();
        });

        // --- IMPORT FROM MANAGEMENT LOGIC ---
        // Import functionality from management.html
        function importFromManagement() {
            // Check if game has started
            if (hasGameStarted()) {
                alert('Cannot import players after scoring has begun! Reset the game to import players.');
                return;
            }
            // Try to get data from the new format first (competitorImportData)
            let importData = localStorage.getItem('competitorImportData');
            // If not found, try to get from the old format (tournamentPlayers)
            if (!importData) {
                const tournamentPlayers = localStorage.getItem('tournamentPlayers');
                if (tournamentPlayers) {
                    try {
                        const players = JSON.parse(tournamentPlayers);
                        if (players.length > 0) {
                            // Show class/division selection modal
                            showImportSelectionModal(players);
                            return;
                        }
                    } catch (e) {
                        console.error('Error converting tournament players:', e);
                    }
                }
            }
            if (!importData) {
                showTimedNotification('‚ùå No players found in import data. Please add players in Management first.', 4000);
                return;
            }
            try {
                const players = JSON.parse(importData);
                if (players.length === 0) {
                    showTimedNotification('‚ùå No players found in import data.', 3000);
                    return;
                }
                
                // Set game name for imported players
                const tournamentName = localStorage.getItem('tournamentName') || 'Tournament';
                gameState.gameName = `${tournamentName} - Imported Players`;
                
                // Update the game name input field
                const gameNameInput = document.getElementById('gameNameInput');
                if (gameNameInput) {
                    gameNameInput.value = gameState.gameName;
                }
                
                // Save the game state to persist the game name
                saveGameState();
                
                // Clear the import data
                localStorage.removeItem('competitorImportData');
                // Use the common import function
                performImport(players);
                
                // Update track progress if open
                refreshTrackProgressIfOpen();
                
                // Import success notification removed
            } catch (error) {
                console.error('Import error:', error);
                showTimedNotification('‚ùå Error importing players. Please try again.', 4000);
            }
        }
        // Import selection modal to choose class and division
        function showImportSelectionModal(allPlayers) {
            const classes = [...new Set(allPlayers.map(p => p.className).filter(className => className && className.trim() !== ''))].sort();
            const divisions = [...new Set(allPlayers.map(p => p.divisionName).filter(divisionName => divisionName && divisionName.trim() !== ''))].sort();
            const playerCounts = {};
            allPlayers.forEach(player => {
                const key = `${player.className} - ${player.divisionName}`;
                playerCounts[key] = (playerCounts[key] || 0) + 1;
            });
            const modal = document.createElement('div');
            modal.style.cssText = `position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0, 0, 0, 0.8);display: flex;align-items: center;justify-content: center;z-index: 10002;padding: 20px;`;
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%);border: 2px solid #8b5cf6;border-radius: 15px;padding: 30px;max-width: 600px;max-height: 80vh;overflow-y: auto;color: #e2e8f0;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;`;
            modalContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <h2 style="color: #8b5cf6; font-size: 1.5rem; margin-bottom: 10px;">üì• Select Players to Import</h2>
                    <p style="color: #94a3b8; font-size: 0.9rem;">Choose class and division to import from Management</p>
                </div>
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #334155;">
                    <h3 style="color: #f1f5f9; margin-bottom: 15px; font-size: 1.1rem;">üéØ Select Class and Division:</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 8px; color: #cbd5e1; font-weight: 500; font-size: 0.9rem;">Class:</label>
                            <select id="importClassSelect" onchange="updateImportDivisionOptions()" style="width: 100%; background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                                <option value="">Select Class...</option>
                                ${classes.map(className => `<option value="${className}">${className}</option>`).join('')}
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 8px; color: #cbd5e1; font-weight: 500; font-size: 0.9rem;">Division:</label>
                            <select id="importDivisionSelect" style="width: 100%; background: #475569; border: 1px solid #64748b; color: white; padding: 10px; border-radius: 8px; font-size: 0.9rem; outline: none;">
                                <option value="">Select Division...</option>
                            </select>
                        </div>
                    </div>
                    <div id="importPlayerCount" style="background: rgba(30, 41, 59, 0.8); padding: 15px; border-radius: 8px; border: 1px solid #475569; margin-bottom: 15px; display: none;">
                        <div style="text-align: center; color: #f1f5f9; font-weight: 500;">
                            <span id="selectedPlayerCount">0</span> players available for import
                        </div>
                    </div>
                    <button id="importSelectedBtn" onclick="importFromDropdown()" style="background: linear-gradient(45deg, #8b5cf6, #a855f7); border: none; color: white; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-weight: 500; width: 100%; font-size: 1rem; transition: all 0.3s ease; opacity: 0.5; pointer-events: none;">üì• Import Selected Players</button>
                </div>
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #334155;">
                    <h3 style="color: #f1f5f9; margin-bottom: 15px; font-size: 1.1rem;">üìä Quick Import Options:</h3>
                    <div style="display: grid; gap: 10px;">
                        <button onclick="importAllPlayers();" style="background: linear-gradient(45deg, #10b981, #059669); border: none; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.3s ease;">üì• Import All ${allPlayers.length} Players</button>
                        <button onclick="showAvailableGroups();" style="background: linear-gradient(45deg, #f59e0b, #d97706); border: none; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.3s ease;">üìã View All Available Groups</button>
                        <button onclick="showEventImportOptions();" style="background: linear-gradient(45deg, #3b82f6, #1d4ed8); border: none; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.3s ease;">üéØ Import by Event</button>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="closeMainImportModal();" style="background: #64748b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">Cancel</button>
                </div>
            `;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            window.importModalAllPlayers = allPlayers;
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                    delete window.importModalAllPlayers;
                }
            });
        }
        function updateImportDivisionOptions() {
            const classSelect = document.getElementById('importClassSelect');
            const divisionSelect = document.getElementById('importDivisionSelect');
            const playerCountDiv = document.getElementById('importPlayerCount');
            const importBtn = document.getElementById('importSelectedBtn');
            if (!classSelect || !divisionSelect || !window.importModalAllPlayers) return;
            const selectedClass = classSelect.value;
            divisionSelect.innerHTML = '<option value="">Select Division...</option>';
            playerCountDiv.style.display = 'none';
            importBtn.style.opacity = '0.5';
            importBtn.style.pointerEvents = 'none';
            if (!selectedClass) return;
            const divisionsForClass = [...new Set(window.importModalAllPlayers.filter(player => player.className === selectedClass).map(player => player.divisionName))].sort();
            divisionsForClass.forEach(division => {
                const option = document.createElement('option');
                option.value = division;
                option.textContent = division;
                divisionSelect.appendChild(option);
            });
            divisionSelect.onchange = function() { updateImportPlayerCount(); };
        }
        function updateImportPlayerCount() {
            const classSelect = document.getElementById('importClassSelect');
            const divisionSelect = document.getElementById('importDivisionSelect');
            const playerCountDiv = document.getElementById('importPlayerCount');
            const playerCountSpan = document.getElementById('selectedPlayerCount');
            const importBtn = document.getElementById('importSelectedBtn');
            if (!classSelect || !divisionSelect || !window.importModalAllPlayers) return;
            const selectedClass = classSelect.value;
            const selectedDivision = divisionSelect.value;
            if (!selectedClass || !selectedDivision) {
                playerCountDiv.style.display = 'none';
                importBtn.style.opacity = '0.5';
                importBtn.style.pointerEvents = 'none';
                return;
            }
            const playerCount = window.importModalAllPlayers.filter(player => player.className === selectedClass && player.divisionName === selectedDivision).length;
            if (playerCount > 0) {
                playerCountSpan.textContent = playerCount;
                playerCountDiv.style.display = 'block';
                importBtn.style.opacity = '1';
                importBtn.style.pointerEvents = 'auto';
            } else {
                playerCountDiv.style.display = 'none';
                importBtn.style.opacity = '0.5';
                importBtn.style.pointerEvents = 'none';
            }
        }
        function importFromDropdown() {
            const classSelect = document.getElementById('importClassSelect');
            const divisionSelect = document.getElementById('importDivisionSelect');
            if (!classSelect || !divisionSelect || !window.importModalAllPlayers) return;
            const selectedClass = classSelect.value;
            const selectedDivision = divisionSelect.value;
            if (!selectedClass || !selectedDivision) {
                showTimedNotification('‚ùå Please select both class and division.', 3000);
                return;
            }
            importSelectedPlayers(selectedClass, selectedDivision);
            
            // Update track progress if open
            refreshTrackProgressIfOpen();
            
            const modal = document.querySelector('div[style*="z-index: 10002"]');
            if (modal) {
                modal.remove();
                delete window.importModalAllPlayers;
            }
        }
        function showAvailableGroups() {
            if (!window.importModalAllPlayers) return;
            const playerCounts = {};
            window.importModalAllPlayers.forEach(player => {
                const key = `${player.className} - ${player.divisionName}`;
                playerCounts[key] = (playerCounts[key] || 0) + 1;
            });
            const filterOptions = [];
            Object.entries(playerCounts).forEach(([key, count]) => {
                const [className, divisionName] = key.split(' - ');
                filterOptions.push({ className, divisionName, count, key });
            });
            filterOptions.sort((a, b) => b.count - a.count);
            const groupsModal = document.createElement('div');
            groupsModal.style.cssText = `position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0, 0, 0, 0.8);display: flex;align-items: center;justify-content: center;z-index: 10003;padding: 20px;`;
            const groupsContent = document.createElement('div');
            groupsContent.style.cssText = `background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%);border: 2px solid #f59e0b;border-radius: 15px;padding: 30px;max-width: 600px;max-height: 80vh;overflow-y: auto;color: #e2e8f0;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;`;
            groupsContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <h2 style="color: #f59e0b; font-size: 1.5rem; margin-bottom: 10px;">üìã Available Groups</h2>
                    <p style="color: #94a3b8; font-size: 0.9rem;">All class and division combinations with player counts</p>
                </div>
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #334155;">
                    <div style="display: grid; gap: 10px;">
                        ${filterOptions.map(option => `
                            <div style="background: linear-gradient(45deg, #475569, #64748b); border: 1px solid #64748b; color: white; padding: 15px; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-size: 1.1rem; font-weight: bold; color: #f1f5f9;">${option.className} - ${option.divisionName}</div>
                                    <div style="font-size: 0.9rem; color: #94a3b8; margin-top: 4px;">${option.count} player${option.count !== 1 ? 's' : ''}</div>
                                </div>
                                <div style="font-size: 1.2rem; color: #f59e0b;">üìä</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="closeAvailableGroupsModal();" style="background: #64748b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">Close</button>
                </div>
            `;
            groupsModal.appendChild(groupsContent);
            document.body.appendChild(groupsModal);
            groupsModal.addEventListener('click', function(e) {
                if (e.target === groupsModal) {
                    groupsModal.remove();
                }
            });
        }
        function importSelectedPlayers(className, divisionName) {
            const tournamentPlayers = localStorage.getItem('tournamentPlayers');
            if (!tournamentPlayers) {
                showTimedNotification('‚ùå No player data found.', 3000);
                return;
            }
            try {
                const allPlayers = JSON.parse(tournamentPlayers);
                const selectedPlayers = allPlayers.filter(player => player.className === className && player.divisionName === divisionName);
                if (selectedPlayers.length === 0) {
                    showTimedNotification('‚ùå No players found for selected class and division.', 3000);
                    return;
                }
                const convertedData = selectedPlayers.map(player => ({ name: player.name, class: player.className, division: player.divisionName }));
                
                // Set game name to the class and division combination
                const gameName = `${className} - ${divisionName}`;
                gameState.gameName = gameName;
                
                // Update the game name input field
                const gameNameInput = document.getElementById('gameNameInput');
                if (gameNameInput) {
                    gameNameInput.value = gameName;
                }
                
                // Save the game state to persist the game name
                saveGameState();
                
                performImport(convertedData);
                
                // Update track progress if open
                refreshTrackProgressIfOpen();
                
                // Import success notification removed
            } catch (error) {
                console.error('Import error:', error);
                showTimedNotification('‚ùå Error importing players. Please try again.', 4000);
            }
        }
        function importAllPlayers() {
            const tournamentPlayers = localStorage.getItem('tournamentPlayers');
            if (!tournamentPlayers) {
                showTimedNotification('‚ùå No player data found.', 3000);
                return;
            }
            try {
                const allPlayers = JSON.parse(tournamentPlayers);
                const convertedData = allPlayers.map(player => ({ name: player.name, class: player.className, division: player.divisionName }));
                
                // Set game name to indicate all players were imported
                const tournamentName = localStorage.getItem('tournamentName') || 'Tournament';
                gameState.gameName = `${tournamentName} - All Players`;
                
                // Update the game name input field
                const gameNameInput = document.getElementById('gameNameInput');
                if (gameNameInput) {
                    gameNameInput.value = gameState.gameName;
                }
                
                // Save the game state to persist the game name
                saveGameState();
                
                performImport(convertedData);
                
                // Update track progress if open
                refreshTrackProgressIfOpen();
                
                // Import success notification removed
            } catch (error) {
                console.error('Import error:', error);
                showTimedNotification('‚ùå Error importing players. Please try again.', 4000);
            }
        }

        function showEventImportOptions() {
            if (!window.importModalAllPlayers) return;
            
            // Check if there are events stored in localStorage
            const events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
            
            if (events.length === 0) {
                alert('No events found in the tournament data.\n\nTo use event-based importing:\n1. Go to Management.html\n2. Create events in the Events section\n3. Assign players to events\n4. Then try importing by event again.');
                return;
            }
            
            // Create event-player mapping using the participants array in each event
            const eventPlayerCounts = {};
            events.forEach(event => {
                if (event.participants && event.participants.length > 0) {
                    // Count how many participants from this event are in the available players
                    const eventPlayers = window.importModalAllPlayers.filter(player => 
                        event.participants.some(participant => participant.id === player.id)
                    );
                    eventPlayerCounts[event.name] = eventPlayers.length;
                } else {
                    eventPlayerCounts[event.name] = 0;
                }
            });
            
            // Filter out events with no players
            const eventsWithPlayers = events.filter(event => eventPlayerCounts[event.name] > 0);
            
            if (eventsWithPlayers.length === 0) {
                alert('No players are assigned to events.\n\nTo assign players to events:\n1. Go to Management.html\n2. Go to the Events section\n3. Click "Manage Participants" on an event\n4. Add players to the event\n5. Then try importing by event again.');
                return;
            }
            
            const eventModal = document.createElement('div');
            eventModal.style.cssText = `position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0, 0, 0, 0.8);display: flex;align-items: center;justify-content: center;z-index: 10004;padding: 20px;`;
            
            const eventContent = document.createElement('div');
            eventContent.style.cssText = `background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%);border: 2px solid #3b82f6;border-radius: 15px;padding: 30px;max-width: 600px;max-height: 80vh;overflow-y: auto;color: #e2e8f0;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;`;
            
            // Create simple event buttons like in custom.html
            const eventButtonsHtml = eventsWithPlayers.map(event => {
                const playerCount = eventPlayerCounts[event.name];
                const eventIcon = getEventIcon(event.type);
                const eventTypeLabel = getEventTypeLabel(event.type);
                return `<button onclick="importEventPlayers('${event.name.replace(/'/g, "\\'")}', 'event');" style="background: linear-gradient(45deg, #3b82f6, #1d4ed8); border: none; color: white; padding: 15px; border-radius: 10px; cursor: pointer; font-weight: 500; transition: all 0.3s ease; text-align: left; width: 100%;">
                    <div style="font-size: 1.1rem; margin-bottom: 5px;">${eventIcon} ${event.name}</div>
                    <div style="font-size: 0.85rem; color: #cbd5e1; opacity: 0.8;">${eventTypeLabel}</div>
                    <div style="font-size: 0.9rem; color: #cbd5e1; margin-top: 4px;">${playerCount} player${playerCount !== 1 ? 's' : ''} available</div>
                </button>`;
            }).join('');
            
            eventContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <h2 style="color: #3b82f6; font-size: 1.5rem; margin-bottom: 10px;">üéØ Import by Event</h2>
                    <p style="color: #94a3b8; font-size: 0.9rem;">Select an event to import all its participants</p>
                </div>
                <div style="background: rgba(15, 23, 42, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #334155;">
                    <div style="display: grid; gap: 10px;">
                        ${eventButtonsHtml}
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="closeEventImportModal();" style="background: #64748b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">Cancel</button>
                </div>
            `;
            
            eventModal.appendChild(eventContent);
            document.body.appendChild(eventModal);
            eventModal.addEventListener('click', function(e) {
                if (e.target === eventModal) {
                    eventModal.remove();
                }
            });
        }

        function importEventPlayers(eventName, eventProperty = 'event') {
            const tournamentPlayers = localStorage.getItem('tournamentPlayers');
            const events = JSON.parse(localStorage.getItem('tournamentEvents') || '[]');
            
            if (!tournamentPlayers) {
                showTimedNotification('‚ùå No player data found.', 3000);
                return;
            }
            
            // Find the event by name
            const event = events.find(e => e.name === eventName);
            if (!event || !event.participants || event.participants.length === 0) {
                showTimedNotification('‚ùå No players found for the selected event.', 3000);
                return;
            }
            
            try {
                const allPlayers = JSON.parse(tournamentPlayers);
                const eventPlayers = allPlayers.filter(player => 
                    event.participants.some(participant => participant.id === player.id)
                );
                
                if (eventPlayers.length === 0) {
                    showTimedNotification('‚ùå No players found for the selected event.', 3000);
                    return;
                }
                
                const convertedData = eventPlayers.map(player => ({ 
                    name: player.name, 
                    class: player.className, 
                    division: player.divisionName,
                    event: eventName
                }));
                
                // Set game name to the event name
                gameState.gameName = eventName;
                
                // Update the game name input field
                const gameNameInput = document.getElementById('gameNameInput');
                if (gameNameInput) {
                    gameNameInput.value = eventName;
                }
                
                // Save the game state to persist the game name
                saveGameState();
                
                performImport(convertedData);
                
                // Update track progress if open
                refreshTrackProgressIfOpen();
                
                // Import success notification removed
            } catch (error) {
                console.error('Import error:', error);
                showTimedNotification('‚ùå Error importing players. Please try again.', 4000);
            }
        }
        function closeMainImportModal() {
            // Find and remove the main import modal (z-index: 10002)
            const mainModal = document.querySelector('div[style*="z-index: 10002"]');
            if (mainModal) {
                mainModal.remove();
            }
            
            // Also clear any stuck backdrops
            const backdrops = document.querySelectorAll('div[style*="background: rgba(0, 0, 0, 0.8)"]');
            backdrops.forEach(backdrop => {
                if (backdrop.style.position === 'fixed' && backdrop.style.zIndex === '10002') {
                    backdrop.remove();
                }
            });
            
            // Clear import modal data
            delete window.importModalAllPlayers;
        }

        function closeEventImportModal() {
            // Find and remove the event import modal (z-index: 10004)
            const eventModal = document.querySelector('div[style*="z-index: 10004"]');
            if (eventModal) {
                eventModal.remove();
            }
            
            // Also clear any stuck backdrops
            const backdrops = document.querySelectorAll('div[style*="background: rgba(0, 0, 0, 0.8)"]');
            backdrops.forEach(backdrop => {
                if (backdrop.style.position === 'fixed' && backdrop.style.zIndex === '10004') {
                    backdrop.remove();
                }
            });
        }

        function closeAvailableGroupsModal() {
            // Find and remove the available groups modal (z-index: 10003)
            const groupsModal = document.querySelector('div[style*="z-index: 10003"]');
            if (groupsModal) {
                groupsModal.remove();
            }
            
            // Also clear any stuck backdrops
            const backdrops = document.querySelectorAll('div[style*="background: rgba(0, 0, 0, 0.8)"]');
            backdrops.forEach(backdrop => {
                if (backdrop.style.position === 'fixed' && backdrop.style.zIndex === '10003') {
                    backdrop.remove();
                }
            });
        }

        function closeAllImportModals() {
            // Close all import-related modals by removing them from the DOM
            const importModals = document.querySelectorAll('div[style*="z-index: 10002"], div[style*="z-index: 10003"], div[style*="z-index: 10004"]');
            importModals.forEach(modal => {
                modal.remove();
            });
            
            // Clear import modal data
            delete window.importModalAllPlayers;
        }

        function performImport(players) {
            if (players.length === 0) {
                showTimedNotification('‚ùå No players to import.', 3000);
                return;
            }
            
            // Clear existing players if any
            if (gameState.players.length > 0) {
                showImportConfirm(`Import will replace ${gameState.players.length} existing players with ${players.length} imported players. Continue?`, function() {
                    gameState.players = [];
                    // Continue with import logic
                    importPlayersLogic();
                }, function() {
                    return; // Cancel import
                });
                return;
            }
            
            // If no existing players, proceed directly
            importPlayersLogic();
            
            function importPlayersLogic() {
            
            // Import players
            players.forEach(function(playerData, index) {
                const newPlayer = {
                    id: playerId++,
                    name: playerData.name || `Player ${index + 1}`,
                    class: playerData.class || 'Open',
                    division: playerData.division || 'Open',
                    event: playerData.event || 'No Event',
                    scores: [],
                    total: 0,
                    bullseyes: 0,
                    tripleNickels: 0,
                    noDrops: 0,
                    average: 0,
                    percentage: 0,
                    currentRound: 1,
                    currentDistance: 1,
                    currentThrow: 1,
                    viewingRound: 1,
                    viewingDistance: 1,
                    gameComplete: false,
                    tiebreakerScores: [],
                    tiebreakerTotal: 0,
                    podiumTiebreakerPoints: 0,
                    podiumTiebreakerPosition: null,
                    podiumTiebreakerInfo: null
                };
                
                // Initialize scores array for the player
                for (var r = 0; r < gameState.rounds; r++) {
                    newPlayer.scores.push([]);
                    for (var d = 0; d < gameState.numDistances; d++) {
                        newPlayer.scores[r].push(Array(gameState.throwsPerRound).fill(null));
                    }
                }
                
                gameState.players.push(newPlayer);
            });
            
            // Mark that players were imported
            gameState.playersImported = true;
            
            // Reset pagination to show imported players
            gameState.currentPage = 1;
            
            // Update display
            renderPlayers();
            updateGameDisplay();
            updateAddPlayerButton(); // Update button state after import
            
            // Update track progress if open
            refreshTrackProgressIfOpen();
            
            saveGameState(); // Auto-save after import
            
            // Close all import modals
            closeAllImportModals();
            
            // Import success notification removed
            }
        }


        // Team-related functions
        function getPlayerTeam(playerName) {
            try {
                const teams = JSON.parse(localStorage.getItem('tournamentTeams') || '[]');
                console.log('Walkback: Found', teams.length, 'teams in localStorage');
                teams.forEach(team => {
                    console.log('Team:', team.name, 'color:', team.color, 'members:', team.members ? team.members.length : 0);
                });
                const foundTeam = teams.find(team => 
                    team.members && team.members.some(member => member.name === playerName)
                );
                if (foundTeam) {
                    console.log('Found team for', playerName, ':', foundTeam.name, 'color:', foundTeam.color);
                }
                return foundTeam;
            } catch (e) {
                console.error('Error getting player team:', e);
                return null;
            }
        }

        function getTeamScore(teamName) {
            try {
                const teams = JSON.parse(localStorage.getItem('tournamentTeams') || '[]');
                const team = teams.find(t => t.name === teamName);
                if (!team || !team.members) return 0;
                
                let teamTotal = 0;
                team.members.forEach(member => {
                    const player = gameState.players.find(p => p.name === member.name);
                    if (player) {
                        teamTotal += player.total;
                    }
                });
                return teamTotal;
            } catch (e) {
                console.error('Error calculating team score:', e);
                return 0;
            }
        }

        function getAllTeams() {
            try {
                return JSON.parse(localStorage.getItem('tournamentTeams') || '[]');
            } catch (e) {
                console.error('Error getting teams:', e);
                return [];
            }
        }

        // Helper function to format player name with team info for export
        function getPlayerNameWithTeam(playerName) {
            var playerTeam = getPlayerTeam(playerName);
            if (playerTeam) {
                var teamColor = playerTeam.color || '#3b82f6';
                return `${playerName} <span style="color: ${teamColor}; font-weight: 500; font-size: 0.9em;">(${playerTeam.name})</span>`;
            }
            return playerName;
        }

        // Reset Game Functions
        function showResetGameWarning() {
            const modal = document.createElement('div');
            modal.style.cssText = `position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0, 0, 0, 0.8);display: flex;align-items: center;justify-content: center;z-index: 10004;padding: 20px;`;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `background: linear-gradient(135deg, #1e293b 0%, #dc2626 50%, #1e293b 100%);border: 2px solid #ef4444;border-radius: 15px;padding: 30px;max-width: 500px;color: #e2e8f0;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;text-align: center;`;
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">‚ö†Ô∏è</div>
                    <h2 style="color: #ef4444; font-size: 1.5rem; margin-bottom: 15px;">Reset Game</h2>
                    <p style="color: #fca5a5; font-size: 1rem; line-height: 1.6;">
                        This will remove all current players and scores.
                    </p>
                    <div style="background: rgba(15, 23, 42, 0.6); padding: 15px; border-radius: 10px; margin: 15px 0; border: 1px solid #334155;">
                        <p style="color: #94a3b8; font-size: 0.9rem; margin: 0;">
                            <strong>Note:</strong> To clear scores and leave the players, use the "Clear Scores" button in the Options menu.
                        </p>
                    </div>
                    <p style="color: #fca5a5; font-size: 0.9rem;">
                        This action cannot be undone.
                    </p>
                </div>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button onclick="this.parentElement.parentElement.parentElement.remove();" style="background: #64748b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">Cancel</button>
                    <button onclick="resetGame(); this.parentElement.parentElement.parentElement.remove();" style="background: #ef4444; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">Reset Game</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        function resetGame() {
            // Automatically revert tournament status when resetting if game is linked to tournament
            if (gameState.playersImported && gameState.gameName) {
                revertTournamentEventStatus();
            }
            
            // Reset game state to initial values
            gameState = {
                type: 'Walkback',
                rounds: 4,
                throwsPerRound: 3,
                maxScore: 5,
                targetRings: [5, 4, 3, 2, 1, 0],
                distances: ['2 Meters', '3 Meters', '4 Meters', '5 Meters', '6 Meters'],
                distancePreset: 'amateur',
                numDistances: 5,
                playMode: 'consecutive',
                isWalkback: true,
                isGolf: false,
                players: [],
                editingThrow: null,
                currentRound: 1,
                currentDistance: 1,
                currentThrow: 1,
                viewingRound: 1,
                viewingDistance: 1,
                gameFinalized: false,
                gameName: '',
                tiebreakerMode: 'sudden-death-podium-match',
                podiumTiebreakers: null,
                inTiebreaker: false,
                tiebreakerPlayers: [],
                tiebreakerRound: 1,
                preTiebreakerStandings: null,
                allTiebreakerParticipants: [],
                playersImported: false,
                eventSetToInProgress: false,
                trackProgress: true, // Track progress feature always enabled
                numLanes: 4, // Number of lanes for progress tracking
                // Pagination settings
                currentPage: 1,
                playersPerPage: 20,
                totalPages: 1
            };
            
            // Reset player ID counter
            playerId = 1;
            
            // Reset finalization guard
            gameFinalizedOnce = false;
            
            // Hide reset button and show finalize button
            var resetGameBtn = document.getElementById('resetGameBtn');
            if (resetGameBtn) {
                resetGameBtn.style.display = 'none';
            }
            
            var finalizeBtn = document.getElementById('finalizeBtn');
            if (finalizeBtn) {
                finalizeBtn.style.display = 'none';
            }
            
            // Update displays
            updateGameDisplay();
            renderPlayers();
            updateAddPlayerButton();
            
            // Update settings panel if it's visible
            if (settingsVisible) {
                updateSettingsPanel();
            }
            
            // Clear saved game state
            localStorage.removeItem('walkbackGameState');
            
            // Show notification
            showTimedNotification('üîÑ Game reset successfully! Ready for a new game.', 3000);
        }

        // Custom Preset Functions

        function saveGamePreset() {
            if (hasGameStarted()) {
                showCustomAlert('Cannot save preset after game has started! Reset the game to save settings.');
                return;
            }
            
            // Get the game name from the input field
            var gameNameInput = document.getElementById('gameNameInput');
            var presetName = gameNameInput ? gameNameInput.value.trim() : '';
            
            if (!presetName) {
                showCustomAlert('Please enter a Game Name first before saving a preset.');
                return;
            }
            
            // Check if name already exists in custom presets
            var customPresets = JSON.parse(localStorage.getItem('walkbackCustomPresets') || '{}');
            if (customPresets[presetName]) {
                showCustomConfirm('A preset with this name already exists. Do you want to overwrite it?', function() {
                    // Continue with saving
                    savePresetLogic();
                });
                return;
            }
            
            // If no conflict, proceed directly
            savePresetLogic();
            
            function savePresetLogic() {
            
            // Get current distances from custom distance input fields if they exist
            var currentDistances = [...gameState.distances]; // Start with current distances
            
            // Check if custom distance inputs are visible and get their values
            var customDistanceInputs = document.querySelectorAll('#customDistanceInputs input');
            if (customDistanceInputs.length > 0) {
                // Custom distance inputs are visible, get their current values
                currentDistances = [];
                for (var i = 0; i < customDistanceInputs.length; i++) {
                    var inputValue = customDistanceInputs[i].value.trim();
                    if (inputValue) {
                        currentDistances.push(inputValue);
                    } else {
                        // If input is empty, use the original distance or a default
                        currentDistances.push(gameState.distances[i] || 'Distance ' + (i + 1));
                    }
                }
            }
            
            // Create preset object with current settings
            var newPreset = {
                rounds: gameState.rounds,
                throwsPerRound: gameState.throwsPerRound,
                maxScore: gameState.maxScore,
                numDistances: currentDistances.length,
                distances: currentDistances,
                distancePreset: 'custom', // Always save as custom when saving custom preset
                playMode: gameState.playMode,
                tiebreakerMode: gameState.tiebreakerMode,
                gameName: presetName // Save the game name in the preset
            };
            
            try {
                // Save to localStorage as custom preset
                var customPresets = JSON.parse(localStorage.getItem('walkbackCustomPresets') || '{}');
                customPresets[presetName] = newPreset;
                localStorage.setItem('walkbackCustomPresets', JSON.stringify(customPresets));
                
                // Update the dropdown to include the new preset
                updatePresetDropdown();
                
                showTimedNotification('üíæ Preset saved: ' + presetName, 2000);
            } catch (error) {
                showCustomAlert('Error saving preset: ' + error.message);
            }
            }
        }

        function updatePresetDropdown() {
            var select = document.getElementById('distancePresetSelect');
            var currentValue = select.value;
            
            // Clear existing options and add the new default presets first
            select.innerHTML = '<option value="" disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Default Presets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>' +
                             '<option value="dangerfest_am_knife">Dangerfest Am Knife (2m, 3m, 4m, 5m, 6m)</option>' +
                             '<option value="dangerfest_pro_knife">Dangerfest Pro Knife (3m, 4m, 5m, 6m, 7m)</option>' +
                             '<option value="dangerfest_am_hawk">Dangerfest Am Hawk (3m, 4m, 5m, 7m)</option>' +
                             '<option value="dangerfest_pro_hawk">Dangerfest Pro Hawk (3m, 4m, 5m, 7m, 9m)</option>' +
                             '<option value="akta">AKTA (7ft, 10ft, 13ft, 16ft)</option>' +
                             '<option value="blade_aces_am_knife">Blade Aces Am Knife (2m, 3m, 4m, 5m)</option>' +
                             '<option value="blade_aces_pro_knife">Blade Aces Pro Knife (3m, 4m, 5m, 6m, 7m)</option>' +
                             '<option value="blade_aces_am_hawk">Blade Aces Am Hawk (3m, 4m, 5m)</option>' +
                             '<option value="blade_aces_pro_hawk">Blade Aces Pro Hawk (3m, 4m, 5m, 7m, 9m)</option>';
            
            // Add Custom option at the bottom
            select.innerHTML += '<option value="" disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Custom Presets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>' +
                              '<option value="custom">Custom (Set your own)</option>';
            
            // Add custom presets after the separator
            var customPresets = JSON.parse(localStorage.getItem('walkbackCustomPresets') || '{}');
            Object.keys(customPresets).forEach(function(presetName) {
                var option = document.createElement('option');
                option.value = 'custom_' + presetName;
                option.textContent = presetName + ' (Custom)';
                select.appendChild(option);
            });
            
            // Restore current selection if it still exists
            if (currentValue) {
                select.value = currentValue;
            }
        }

        // Load custom presets on page load
        function loadCustomPresets() {
            updatePresetDropdown();
        }

        function loadCustomPreset(presetName) {
            if (hasGameStarted()) {
                alert('Cannot load preset after game has started! Reset the game to change settings.');
                document.getElementById('distancePresetSelect').value = 'custom';
                return;
            }
            
            var customPresets = JSON.parse(localStorage.getItem('walkbackCustomPresets') || '{}');
            var preset = customPresets[presetName];
            if (!preset) {
                alert('Preset not found!');
                document.getElementById('distancePresetSelect').value = 'custom';
                return;
            }
            
            // Apply preset settings
            gameState.rounds = preset.rounds;
            gameState.throwsPerRound = preset.throwsPerRound;
            gameState.maxScore = preset.maxScore;
            gameState.numDistances = preset.numDistances;
            gameState.distances = preset.distances;
            gameState.distancePreset = preset.distancePreset;
            gameState.playMode = preset.playMode;
            gameState.tiebreakerMode = preset.tiebreakerMode;
            gameState.gameName = preset.gameName || presetName; // Use saved game name or preset name
            gameState.targetRings = generateTargetRings();
            
            // Set the Game Name to the custom preset name
            var customPresetDisplayName = presetName + ' (Custom Preset)';
            gameState.gameName = customPresetDisplayName;
            
            // Update UI elements manually to avoid conflicts
            updateCustomDistanceInputs();
            updateGameDisplay();
            renderPlayers();
            
            // Update game name input field
            var gameNameInput = document.getElementById('gameNameInput');
            if (gameNameInput) {
                gameNameInput.value = customPresetDisplayName;
            }
            
            // Set the distance preset dropdown to show the selected custom preset
            var presetSelect = document.getElementById('distancePresetSelect');
            if (presetSelect) {
                presetSelect.value = 'custom_' + presetName;
            }
            
            // Update other settings fields manually
            document.getElementById('roundsSelect').value = gameState.rounds || 4;
            document.getElementById('throwsPerRoundSelect').value = gameState.throwsPerRound || 3;
            document.getElementById('numDistancesSelect').value = gameState.distances.length; // Use actual distances length
            document.getElementById('maxScoreSelect').value = gameState.maxScore || 5;
            document.getElementById('playModeSelect').value = gameState.playMode || 'consecutive';
            document.getElementById('tiebreakerSelect').value = gameState.tiebreakerMode || 'sudden-death-podium-match';
            
            showTimedNotification('üéØ Loaded custom preset: ' + presetName, 2000);
        }



        function removeSelectedPreset() {
            // Get the currently selected preset from the distance preset dropdown
            var presetSelect = document.getElementById('distancePresetSelect');
            var selectedPresetValue = presetSelect.value;
            
            // Check if anything is selected
            if (!selectedPresetValue) {
                showCustomAlert('Please select a preset from the dropdown to remove.');
                return;
            }
            
            var selectedPresetName = '';
            var isCustomPreset = false;
            
            // Handle different types of presets
            if (selectedPresetValue.startsWith('custom_')) {
                // Custom preset
                selectedPresetName = selectedPresetValue.substring(7); // Remove "custom_" prefix
                isCustomPreset = true;
                
                // Check if the custom preset exists
                var customPresets = JSON.parse(localStorage.getItem('walkbackCustomPresets') || '{}');
                if (!customPresets[selectedPresetName]) {
                    showCustomAlert('Custom preset not found.');
                    return;
                }
            } else {
                // Default preset (amateur, professional, custom, or new default presets)
                selectedPresetName = selectedPresetValue;
                isCustomPreset = false;
            }
            
            // Confirm removal
            var confirmMessage = 'Are you sure you want to remove the preset "' + selectedPresetName + '"?\n\n';
            if (isCustomPreset) {
                confirmMessage += 'This will also reset all settings to defaults.';
            } else {
                confirmMessage += 'This will reset all settings to defaults.';
            }
            
            showCustomConfirm(confirmMessage, function() {
                if (isCustomPreset) {
                    // Remove custom preset from localStorage
                    var customPresets = JSON.parse(localStorage.getItem('walkbackCustomPresets') || '{}');
                    delete customPresets[selectedPresetName];
                    localStorage.setItem('walkbackCustomPresets', JSON.stringify(customPresets));
                    
                    // Update the dropdown first
                    updatePresetDropdown();
                    
                    showTimedNotification('üóëÔ∏è Custom preset removed: ' + selectedPresetName, 3000);
                } else {
                    // For default presets, just reset settings
                    showTimedNotification('üîÑ Settings reset to defaults', 3000);
                }
                
                // Reset settings to defaults
                resetSettingsToDefaults();
            });
        }

        function resetSettingsToDefaults() {
            // Reset game state to default values
            gameState.rounds = 4;
            gameState.throwsPerRound = 3;
            gameState.maxScore = 5;
            gameState.numDistances = 5;
            gameState.distances = ['2 Meters', '3 Meters', '4 Meters', '5 Meters', '6 Meters'];
            gameState.distancePreset = 'dangerfest_am_knife';
            gameState.playMode = 'consecutive';
            gameState.tiebreakerMode = 'sudden-death-podium-match';
            gameState.gameName = '';
            gameState.targetRings = generateTargetRings();
            
            // Update UI to reflect default settings
            updateSettingsPanel();
            updateCustomDistanceInputs();
            updateGameDisplay();
            renderPlayers();
            
            // Reset distance preset dropdown to dangerfest_am_knife
            document.getElementById('distancePresetSelect').value = 'dangerfest_am_knife';
            
            // Reset throws per round dropdown to 3
            var throwsSelect = document.getElementById('throwsPerRoundSelect');
            if (throwsSelect) {
                throwsSelect.value = 3;
            }
            
            // Set the Game Name to the default preset
            var gameNameInput = document.getElementById('gameNameInput');
            if (gameNameInput) {
                gameNameInput.value = 'Dangerfest Am Knife';
            }
            gameState.gameName = 'Dangerfest Am Knife';
        }





        // Custom confirmation modal function
        function showCustomConfirm(message, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10005; padding: 20px;';
            
            // Add a flag to prevent double-processing
            let modalProcessed = false;
            
            // Generate unique IDs for this modal instance
            const modalId = 'confirmModal_' + Date.now();
            const confirmBtnId = 'confirmBtn_' + Date.now();
            const cancelBtnId = 'cancelBtn_' + Date.now();
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #3b82f6; border-radius: 15px; padding: 30px; max-width: 500px; width: 100%; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; text-align: center;';
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">‚ùì</div>
                    <h2 style="margin: 0; color: #3b82f6; font-size: 1.5rem; margin-bottom: 15px;">Triple Nickel</h2>
                    <p style="margin: 0; color: #cbd5e1; font-size: 1rem; line-height: 1.5;">${message}</p>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="${confirmBtnId}" style="background: linear-gradient(45deg, #10b981, #059669); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚úÖ Confirm</button>
                    <button id="${cancelBtnId}" style="background: linear-gradient(45deg, #64748b, #475569); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚ùå Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Get button references after adding to DOM using unique IDs
            const confirmBtn = document.getElementById(confirmBtnId);
            const cancelBtn = document.getElementById(cancelBtnId);
            
            // Ensure buttons exist before adding event listeners
            if (confirmBtn && cancelBtn) {
                // Add hover effects
                confirmBtn.addEventListener('mouseenter', () => {
                    confirmBtn.style.transform = 'scale(1.05)';
                    confirmBtn.style.boxShadow = '0 4px 12px rgba(16, 185, 129, 0.3)';
                });
                
                confirmBtn.addEventListener('mouseleave', () => {
                    confirmBtn.style.transform = 'scale(1)';
                    confirmBtn.style.boxShadow = 'none';
                });
                
                cancelBtn.addEventListener('mouseenter', () => {
                    cancelBtn.style.transform = 'scale(1.05)';
                    cancelBtn.style.boxShadow = '0 4px 12px rgba(100, 116, 139, 0.3)';
                });
                
                cancelBtn.addEventListener('mouseleave', () => {
                    cancelBtn.style.transform = 'scale(1)';
                    cancelBtn.style.boxShadow = 'none';
                });
                
                // Handle button clicks
                confirmBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    // Remove modal
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    // Call confirm callback
                    if (onConfirm) {
                        onConfirm();
                    }
                });
                
                cancelBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        return;
                    }
                    modalProcessed = true;
                    
                    // Remove modal
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    
                    // Call cancel callback
                    if (onCancel) {
                        onCancel();
                    }
                });
                
                // Focus the confirm button
                confirmBtn.focus();
                
                // Handle escape key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        if (onCancel) {
                            onCancel();
                        }
                        modal.remove();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                
                document.addEventListener('keydown', handleEscape);
            }
        }

        // Custom alert modal function
        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10005; padding: 20px;';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #ef4444; border-radius: 15px; padding: 30px; max-width: 500px; text-align: center; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);';
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 2rem; margin-bottom: 10px;">‚ö†Ô∏è</div>
                    <h2 style="color: #ef4444; font-size: 1.3rem; margin-bottom: 15px; font-weight: 600;">Triple Nickel</h2>
                </div>
                <div style="margin-bottom: 25px; line-height: 1.6; font-size: 1rem;">
                    ${message}
                </div>
                <button id="alertOkBtn" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1rem; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);">OK</button>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            const okBtn = modal.querySelector('#alertOkBtn');
            
            // Focus the OK button
            okBtn.focus();
            
            // Event listeners
            okBtn.addEventListener('click', function() {
                modal.remove();
            });
            
            okBtn.addEventListener('mouseenter', function() {
                this.style.transform = 'translateY(-2px) scale(1.05)';
                this.style.boxShadow = '0 6px 20px rgba(239, 68, 68, 0.4)';
            });
            
            okBtn.addEventListener('mouseleave', function() {
                this.style.transform = 'translateY(0) scale(1)';
                this.style.boxShadow = '0 4px 15px rgba(239, 68, 68, 0.3)';
            });
            
            // Close on outside click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
            
            // Close on Escape key
            document.addEventListener('keydown', function closeOnEscape(e) {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', closeOnEscape);
                }
            });
            
            // Close on Enter key
            document.addEventListener('keydown', function closeOnEnter(e) {
                if (e.key === 'Enter') {
                    modal.remove();
                    document.removeEventListener('keydown', closeOnEnter);
                }
            });
        }

        // Clear scores confirmation modal function
        function showClearScoresConfirm(message, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10005; padding: 20px;';
            
            // Add a flag to prevent double-processing
            let modalProcessed = false;
            
            // Generate unique IDs for this modal instance
            const modalId = 'clearScoresModal_' + Date.now();
            const confirmBtnId = 'clearScoresConfirmBtn_' + Date.now();
            const cancelBtnId = 'clearScoresCancelBtn_' + Date.now();
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #3b82f6; border-radius: 15px; padding: 30px; max-width: 500px; width: 100%; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; text-align: center;';
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">‚ùì</div>
                    <h2 style="margin: 0; color: #3b82f6; font-size: 1.5rem; margin-bottom: 15px;">Triple Nickel</h2>
                    <p style="margin: 0; color: #cbd5e1; font-size: 1rem; line-height: 1.5;">${message}</p>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="${confirmBtnId}" style="background: linear-gradient(45deg, #10b981, #059669); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚úÖ Confirm</button>
                    <button id="${cancelBtnId}" style="background: linear-gradient(45deg, #64748b, #475569); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚ùå Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Get button references after adding to DOM using unique IDs
            const confirmBtn = document.getElementById(confirmBtnId);
            const cancelBtn = document.getElementById(cancelBtnId);
            
            // Ensure buttons exist before adding event listeners
            if (confirmBtn && cancelBtn) {
                console.log('‚úÖ Found both clear scores buttons successfully:', confirmBtn, cancelBtn);
                // Add hover effects
                confirmBtn.addEventListener('mouseenter', () => {
                    confirmBtn.style.transform = 'scale(1.05)';
                    confirmBtn.style.boxShadow = '0 4px 12px rgba(16, 185, 129, 0.3)';
                });
                
                confirmBtn.addEventListener('mouseleave', () => {
                    confirmBtn.style.transform = 'scale(1)';
                    confirmBtn.style.boxShadow = 'none';
                });
                
                cancelBtn.addEventListener('mouseenter', () => {
                    cancelBtn.style.transform = 'scale(1.05)';
                    cancelBtn.style.boxShadow = '0 4px 12px rgba(100, 116, 139, 0.3)';
                });
                
                cancelBtn.addEventListener('mouseleave', () => {
                    cancelBtn.style.transform = 'scale(1)';
                    cancelBtn.style.boxShadow = 'none';
                });
                
                // Handle button clicks
                confirmBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear scores modal already processed, ignoring click');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Clear scores confirm button clicked - calling onConfirm');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear scores modal removed successfully');
                    } catch (error) {
                        console.error('‚ùå Error removing clear scores modal:', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onConfirm) {
                        onConfirm();
                    } else {
                        console.log('‚ùå onConfirm callback is null or undefined');
                    }
                });
                
                cancelBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear scores modal already processed, ignoring click');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Clear scores cancel button clicked - calling onCancel');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear scores modal removed successfully');
                    } catch (error) {
                        console.error('‚ùå Error removing clear scores modal:', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) {
                        onCancel();
                    } else {
                        console.log('‚ùå onCancel callback is null or undefined');
                    }
                });
                
                // Focus the confirm button for keyboard navigation
                setTimeout(() => confirmBtn.focus(), 100);
            } else {
                console.error('‚ùå Could not find clear scores confirm or cancel buttons in modal');
            }
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear scores modal already processed, ignoring outside click');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Clicked outside clear scores modal - closing');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear scores modal removed successfully (outside click)');
                    } catch (error) {
                        console.error('‚ùå Error removing clear scores modal (outside click):', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) onCancel();
                }
            });
            
            // Handle keyboard events
            modal.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear scores modal already processed, ignoring escape key');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Escape key pressed - closing clear scores modal');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear scores modal removed successfully (escape)');
                    } catch (error) {
                        console.error('‚ùå Error removing clear scores modal (escape):', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) onCancel();
                } else if (e.key === 'Enter') {
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear scores modal already processed, ignoring enter key');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Enter key pressed - confirming clear scores');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear scores modal removed successfully (enter)');
                    } catch (error) {
                        console.error('‚ùå Error removing clear scores modal (enter):', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onConfirm) onConfirm();
                }
            });
        }

        // Clear players confirmation modal function
        function showClearPlayersConfirm(message, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10005; padding: 20px;';
            
            // Add a flag to prevent double-processing
            let modalProcessed = false;
            
            // Generate unique IDs for this modal instance
            const modalId = 'clearModal_' + Date.now();
            const confirmBtnId = 'clearConfirmBtn_' + Date.now();
            const cancelBtnId = 'clearCancelBtn_' + Date.now();
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #3b82f6; border-radius: 15px; padding: 30px; max-width: 500px; width: 100%; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; text-align: center;';
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">‚ùì</div>
                    <h2 style="margin: 0; color: #3b82f6; font-size: 1.5rem; margin-bottom: 15px;">Triple Nickel</h2>
                    <p style="margin: 0; color: #cbd5e1; font-size: 1rem; line-height: 1.5;">${message}</p>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="${confirmBtnId}" style="background: linear-gradient(45deg, #10b981, #059669); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚úÖ Confirm</button>
                    <button id="${cancelBtnId}" style="background: linear-gradient(45deg, #64748b, #475569); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚ùå Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Get button references after adding to DOM using unique IDs
            const confirmBtn = document.getElementById(confirmBtnId);
            const cancelBtn = document.getElementById(cancelBtnId);
            
            // Ensure buttons exist before adding event listeners
            if (confirmBtn && cancelBtn) {
                console.log('‚úÖ Found both clear players buttons successfully:', confirmBtn, cancelBtn);
                // Add hover effects
                confirmBtn.addEventListener('mouseenter', () => {
                    confirmBtn.style.transform = 'scale(1.05)';
                    confirmBtn.style.boxShadow = '0 4px 12px rgba(16, 185, 129, 0.3)';
                });
                
                confirmBtn.addEventListener('mouseleave', () => {
                    confirmBtn.style.transform = 'scale(1)';
                    confirmBtn.style.boxShadow = 'none';
                });
                
                cancelBtn.addEventListener('mouseenter', () => {
                    cancelBtn.style.transform = 'scale(1.05)';
                    cancelBtn.style.boxShadow = '0 4px 12px rgba(100, 116, 139, 0.3)';
                });
                
                cancelBtn.addEventListener('mouseleave', () => {
                    cancelBtn.style.transform = 'scale(1)';
                    cancelBtn.style.boxShadow = 'none';
                });
                
                // Handle button clicks
                confirmBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear modal already processed, ignoring click');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Clear players confirm button clicked - calling onConfirm');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear modal removed successfully');
                    } catch (error) {
                        console.error('‚ùå Error removing clear modal:', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onConfirm) {
                        onConfirm();
                    } else {
                        console.log('‚ùå onConfirm callback is null or undefined');
                    }
                });
                
                cancelBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear modal already processed, ignoring click');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Clear players cancel button clicked - calling onCancel');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear modal removed successfully');
                    } catch (error) {
                        console.error('‚ùå Error removing clear modal:', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) {
                        onCancel();
                    } else {
                        console.log('‚ùå onCancel callback is null or undefined');
                    }
                });
                
                // Focus the confirm button for keyboard navigation
                setTimeout(() => confirmBtn.focus(), 100);
            } else {
                console.error('‚ùå Could not find clear players confirm or cancel buttons in modal');
            }
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear modal already processed, ignoring outside click');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Clicked outside clear modal - closing');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear modal removed successfully (outside click)');
                    } catch (error) {
                        console.error('‚ùå Error removing clear modal (outside click):', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) onCancel();
                }
            });
            
            // Handle keyboard events
            modal.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear modal already processed, ignoring escape key');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Escape key pressed - closing clear modal');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear modal removed successfully (escape)');
                    } catch (error) {
                        console.error('‚ùå Error removing clear modal (escape):', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) onCancel();
                } else if (e.key === 'Enter') {
                    // Prevent double-processing
                    if (modalProcessed) {
                        console.log('üîç Clear modal already processed, ignoring enter key');
                        return;
                    }
                    modalProcessed = true;
                    
                    console.log('üîç Enter key pressed - confirming clear');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Clear modal removed successfully (enter)');
                    } catch (error) {
                        console.error('‚ùå Error removing clear modal (enter):', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onConfirm) onConfirm();
                }
            });
        }

        // Import confirmation modal function
        function showImportConfirm(message, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10005; padding: 20px;';
            
            // Generate unique IDs for this modal instance
            const modalId = 'importModal_' + Date.now();
            const confirmBtnId = 'importConfirmBtn_' + Date.now();
            const cancelBtnId = 'importCancelBtn_' + Date.now();
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #8b5cf6; border-radius: 15px; padding: 30px; max-width: 500px; width: 100%; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; text-align: center;';
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">üì•</div>
                    <h2 style="margin: 0; color: #8b5cf6; font-size: 1.5rem; margin-bottom: 15px;">Triple Nickel</h2>
                    <p style="margin: 0; color: #cbd5e1; font-size: 1rem; line-height: 1.5;">${message}</p>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="${confirmBtnId}" style="background: linear-gradient(45deg, #8b5cf6, #a855f7); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">üì• Import Players</button>
                    <button id="${cancelBtnId}" style="background: #64748b; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">‚ùå Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Get button references after adding to DOM using unique IDs
            const confirmBtn = document.getElementById(confirmBtnId);
            const cancelBtn = document.getElementById(cancelBtnId);
            
            // Ensure buttons exist before adding event listeners
            if (confirmBtn && cancelBtn) {
                console.log('‚úÖ Found both import buttons successfully:', confirmBtn, cancelBtn);
                // Add hover effects
                confirmBtn.addEventListener('mouseenter', () => {
                    confirmBtn.style.transform = 'scale(1.05)';
                    confirmBtn.style.boxShadow = '0 4px 12px rgba(139, 92, 246, 0.3)';
                });
                
                confirmBtn.addEventListener('mouseleave', () => {
                    confirmBtn.style.transform = 'scale(1)';
                    confirmBtn.style.boxShadow = 'none';
                });
                
                cancelBtn.addEventListener('mouseenter', () => {
                    cancelBtn.style.transform = 'scale(1.05)';
                    cancelBtn.style.boxShadow = '0 4px 12px rgba(100, 116, 139, 0.3)';
                });
                
                cancelBtn.addEventListener('mouseleave', () => {
                    cancelBtn.style.transform = 'scale(1)';
                    cancelBtn.style.boxShadow = 'none';
                });
                
                // Handle button clicks
                confirmBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üîç Import confirm button clicked - calling onConfirm');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Import modal removed successfully');
                    } catch (error) {
                        console.error('‚ùå Error removing import modal:', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onConfirm) {
                        onConfirm();
                    } else {
                        console.log('‚ùå onConfirm callback is null or undefined');
                    }
                });
                
                cancelBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üîç Import cancel button clicked - calling onCancel');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Import modal removed successfully');
                    } catch (error) {
                        console.error('‚ùå Error removing import modal:', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) {
                        onCancel();
                    } else {
                        console.log('‚ùå onCancel callback is null or undefined');
                    }
                });
                
                // Focus the confirm button for keyboard navigation
                setTimeout(() => confirmBtn.focus(), 100);
            } else {
                console.error('‚ùå Could not find import confirm or cancel buttons in modal');
            }
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    console.log('üîç Clicked outside import modal - closing');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Import modal removed successfully (outside click)');
                    } catch (error) {
                        console.error('‚ùå Error removing import modal (outside click):', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) onCancel();
                }
            });
            
            // Handle keyboard events
            modal.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    console.log('üîç Escape key pressed - closing import modal');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Import modal removed successfully (escape)');
                    } catch (error) {
                        console.error('‚ùå Error removing import modal (escape):', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) onCancel();
                } else if (e.key === 'Enter') {
                    console.log('üîç Enter key pressed - confirming import');
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                        console.log('‚úÖ Import modal removed successfully (enter)');
                    } catch (error) {
                        console.error('‚ùå Error removing import modal (enter):', error);
                        // Last resort
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onConfirm) onConfirm();
                }
            });
        }

        // Finalization confirmation modal function with dynamic button text
        function showFinalizationConfirm(message, confirmButtonText, cancelButtonText, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10005; padding: 20px;';
            
            // Add a flag to prevent double-processing
            let modalProcessed = false;
            
            // Generate unique IDs for this modal instance
            const modalId = 'finalizationModal_' + Date.now();
            const confirmBtnId = 'finalizationConfirmBtn_' + Date.now();
            const cancelBtnId = 'finalizationCancelBtn_' + Date.now();
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%); border: 2px solid #f59e0b; border-radius: 15px; padding: 30px; max-width: 500px; width: 100%; color: #e2e8f0; font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; text-align: center;';
            
            modalContent.innerHTML = `
                <div style="margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">üèÜ</div>
                    <h2 style="margin: 0; color: #f1f5f9; font-size: 1.5rem; margin-bottom: 15px;">Triple Nickel</h2>
                    <p style="margin: 0; color: #cbd5e1; font-size: 1rem; line-height: 1.5;">${message}</p>
                </div>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="${confirmBtnId}" style="background: linear-gradient(45deg, #10b981, #059669); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">${confirmButtonText}</button>
                    <button id="${cancelBtnId}" style="background: linear-gradient(45deg, #3b82f6, #2563eb); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem; transition: all 0.3s ease;">${cancelButtonText}</button>
                </div>
            `;
            
            // Prevent clicks on modal content from bubbling to modal background
            modalContent.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Get button references after adding to DOM
            const confirmBtn = modal.querySelector('#' + confirmBtnId);
            const cancelBtn = modal.querySelector('#' + cancelBtnId);
            
            // Ensure buttons exist before adding event listeners
            if (confirmBtn && cancelBtn) {
                // Handle button clicks
                confirmBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    if (modalProcessed) return;
                    modalProcessed = true;
                    console.log('üîç DEBUG: Confirm button clicked, removing modal');
                    
                    // Immediately hide the modal visually
                    modal.style.display = 'none';
                    modal.style.visibility = 'hidden';
                    modal.style.opacity = '0';
                    modal.style.pointerEvents = 'none';
                    
                    // Force remove the modal from DOM immediately
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                            console.log('üîç DEBUG: Modal removed via parentNode');
                        } else if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                            console.log('üîç DEBUG: Modal removed via document.body');
                        } else {
                            modal.remove();
                            console.log('üîç DEBUG: Modal removed via remove()');
                        }
                    } catch (error) {
                        console.log('üîç DEBUG: Modal removal failed:', error);
                        // Force hide if removal fails
                        modal.style.display = 'none';
                    }
                    
                    // Force remove any other modals with the same z-index
                    const allModals = document.querySelectorAll('div[style*="z-index: 10005"]');
                    allModals.forEach(m => {
                        if (m !== modal) {
                            console.log('üîç DEBUG: Removing additional modal:', m);
                            m.style.display = 'none';
                            if (m.parentNode) m.parentNode.removeChild(m);
                            else if (document.body.contains(m)) document.body.removeChild(m);
                            else m.remove();
                        }
                    });
                    
                    console.log('üîç DEBUG: About to call onConfirm callback');
                    console.log('üîç DEBUG: Modal should be removed by now, checking DOM...');
                    const remainingModals = document.querySelectorAll('div[style*="z-index: 10005"]');
                    console.log('üîç DEBUG: Remaining modals after removal:', remainingModals.length);
                    
                    // Add a small delay to ensure modal is fully removed before callback
                    setTimeout(() => {
                        if (onConfirm) onConfirm();
                    }, 50);
                });
                
                cancelBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    if (modalProcessed) return;
                    modalProcessed = true;
                    console.log('üîç DEBUG: Cancel button clicked, removing modal');
                    
                    // Immediately hide the modal visually
                    modal.style.display = 'none';
                    modal.style.visibility = 'hidden';
                    modal.style.opacity = '0';
                    modal.style.pointerEvents = 'none';
                    
                    // Force remove the modal from DOM immediately
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                            console.log('üîç DEBUG: Modal removed via parentNode');
                        } else if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                            console.log('üîç DEBUG: Modal removed via document.body');
                        } else {
                            modal.remove();
                            console.log('üîç DEBUG: Modal removed via remove()');
                        }
                    } catch (error) {
                        console.log('üîç DEBUG: Modal removal failed:', error);
                        // Force hide if removal fails
                        modal.style.display = 'none';
                    }
                    
                    console.log('üîç DEBUG: About to call onCancel callback');
                    if (onCancel) onCancel();
                });
                
                // Focus the confirm button for keyboard navigation
                setTimeout(() => {
                    if (confirmBtn && !modalProcessed) {
                        confirmBtn.focus();
                    }
                }, 100);
            }
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                // Only close if clicking directly on the modal background, not on buttons or content
                if (e.target === modal && !modalProcessed) {
                    e.preventDefault();
                    e.stopPropagation();
                    modalProcessed = true;
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) onCancel();
                }
            });
            
            // Handle keyboard events
            modal.addEventListener('keydown', function(e) {
                if (modalProcessed) return;
                if (e.key === 'Escape') {
                    modalProcessed = true;
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onCancel) onCancel();
                } else if (e.key === 'Enter') {
                    modalProcessed = true;
                    try {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        } else {
                            modal.remove();
                        }
                    } catch (error) {
                        if (document.body.contains(modal)) {
                            document.body.removeChild(modal);
                        }
                    }
                    if (onConfirm) onConfirm();
                }
            });
        }



        // Sidebar toggle function
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const gameInterface = document.getElementById('gameInterface');
            const toggle = document.getElementById('sidebarToggle');
            
            sidebar.classList.toggle('collapsed');
            gameInterface.classList.toggle('expanded');
            
            // Update toggle button text
            if (sidebar.classList.contains('collapsed')) {
                toggle.textContent = '‚ò∞';
            } else {
                toggle.textContent = '‚úï';
            }
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeGame();
            // Glow Apply Changes when any setting is changed in the settings panel
            var settingsPanel = document.getElementById('settingsPanel');
            if (settingsPanel) {
                settingsPanel.addEventListener('change', function(e) {
                    if (e.target.matches('input, select, textarea')) markSettingsChanged();
                });
                settingsPanel.addEventListener('input', function(e) {
                    if (e.target.matches('input, select, textarea')) markSettingsChanged();
                });
            }
            // Initialize pagination controls and dropdown after a short delay to ensure DOM is ready
            setTimeout(function() {
                updatePaginationControls();
                initializePaginationDropdown();
            }, 100);
            // Try again after a longer delay to ensure everything is loaded
            setTimeout(function() {
                updatePaginationControls();
                initializePaginationDropdown();
            }, 500);
            setTimeout(function() {
                updatePaginationControls();
                initializePaginationDropdown();
            }, 1000);
        });

        // ... existing code ...
    </script>
    
    <script src="shared-sidebar.js"></script>
    <script>

        // Pagination Functions
        function updatePaginationControls() {
            try {
                const totalPlayers = gameState.players ? gameState.players.length : 0;
                console.log('üîÑ updatePaginationControls - Total players:', totalPlayers);
                
                // Always calculate pagination values first
                const playersPerPage = gameState.playersPerPage === 'all' ? totalPlayers : parseInt(gameState.playersPerPage);
                console.log('üîÑ Players per page:', playersPerPage, 'Type:', typeof playersPerPage, 'gameState.playersPerPage:', gameState.playersPerPage);
                
                // Calculate pagination
                gameState.totalPages = gameState.playersPerPage === 'all' ? 1 : Math.ceil(totalPlayers / playersPerPage);
                console.log('üîÑ Total pages calculated:', gameState.totalPages, 'Total players:', totalPlayers, 'Calculation:', totalPlayers, '/', playersPerPage, '=', totalPlayers / playersPerPage);
                
                // Keep current page within bounds
                if (gameState.currentPage > gameState.totalPages && gameState.totalPages > 0) {
                    gameState.currentPage = gameState.totalPages;
                }
                if (gameState.currentPage < 1) {
                    gameState.currentPage = 1;
                }
                
                // Get pagination controls elements (both top and bottom)
                const paginationControls = document.getElementById('paginationControls');
                const bottomPaginationControls = document.getElementById('bottomPaginationControls');
                
                // Show/hide pagination controls based on player count
                // Once there are 21+ players, always show pagination controls regardless of dropdown setting
                const shouldShowPagination = totalPlayers >= 21 && gameState.playersPerPage !== 'all';
                
                if (shouldShowPagination) {
                    if (paginationControls) {
                        paginationControls.style.display = 'block';
                    }
                    if (bottomPaginationControls) {
                        bottomPaginationControls.style.display = 'block';
                    }
                    console.log('üîÑ Pagination controls shown - Players:', totalPlayers, 'Per page:', gameState.playersPerPage);
                } else {
                    if (paginationControls) {
                        paginationControls.style.display = 'none';
                    }
                    if (bottomPaginationControls) {
                        bottomPaginationControls.style.display = 'none';
                    }
                    console.log('üîÑ Pagination controls hidden - Players:', totalPlayers, 'Per page:', gameState.playersPerPage);
                    return;
                }
                
                // Update display elements safely (both top and bottom)
                const playerCountEl = document.getElementById('playerCount');
                const bottomPlayerCountEl = document.getElementById('bottomPlayerCount');
                const pageInfoEl = document.getElementById('pageInfo');
                const bottomPageInfoEl = document.getElementById('bottomPageInfo');
                const prevBtn = document.getElementById('prevPageBtn');
                const bottomPrevBtn = document.getElementById('bottomPrevPageBtn');
                const nextBtn = document.getElementById('nextPageBtn');
                const bottomNextBtn = document.getElementById('bottomNextPageBtn');
                const playersPerPageEl = document.getElementById('playersPerPage');
                const bottomPlayersPerPageEl = document.getElementById('bottomPlayersPerPage');
                
                // Update player counts
                if (playerCountEl) {
                    playerCountEl.textContent = totalPlayers + ' players';
                }
                if (bottomPlayerCountEl) {
                    bottomPlayerCountEl.textContent = totalPlayers + ' players';
                }
                
                // Update page info
                const pageText = 'Page ' + gameState.currentPage + ' of ' + gameState.totalPages;
                if (pageInfoEl) {
                    pageInfoEl.textContent = pageText;
                }
                if (bottomPageInfoEl) {
                    bottomPageInfoEl.textContent = pageText;
                }
                
                // Update button states
                const prevDisabled = gameState.currentPage <= 1;
                const nextDisabled = gameState.currentPage >= gameState.totalPages;
                
                if (prevBtn) {
                    prevBtn.disabled = prevDisabled;
                }
                if (bottomPrevBtn) {
                    bottomPrevBtn.disabled = prevDisabled;
                }
                if (nextBtn) {
                    nextBtn.disabled = nextDisabled;
                }
                if (bottomNextBtn) {
                    bottomNextBtn.disabled = nextDisabled;
                }
                
                console.log('üîÑ Previous button disabled:', prevDisabled, 'Next button disabled:', nextDisabled);
                
                // Update dropdowns
                if (playersPerPageEl) {
                    playersPerPageEl.value = gameState.playersPerPage;
                    console.log('üîÑ Top dropdown value set to:', gameState.playersPerPage);
                }
                if (bottomPlayersPerPageEl) {
                    bottomPlayersPerPageEl.value = gameState.playersPerPage;
                    console.log('üîÑ Bottom dropdown value set to:', gameState.playersPerPage);
                }
            } catch (error) {
                console.error('Error updating pagination controls:', error);
            }
        }
        
        function changePage(direction) {
            const totalPlayers = gameState.players ? gameState.players.length : 0;
            const playersPerPage = parseInt(gameState.playersPerPage) || 20;
            
            // Calculate new page
            const newPage = gameState.currentPage + direction;
            
            // Validate page bounds
            if (newPage < 1 || newPage > gameState.totalPages) {
                showTimedNotification('Cannot go to page ' + newPage + '. Valid range: 1 to ' + gameState.totalPages, 2000);
                return;
            }
            
            gameState.currentPage = newPage;
            
            // Calculate expected start and end indices
            const startIndex = (gameState.currentPage - 1) * playersPerPage;
            const endIndex = Math.min(startIndex + playersPerPage, totalPlayers);
            
            showTimedNotification('Page ' + gameState.currentPage + ': Showing players ' + (startIndex + 1) + '-' + endIndex + ' of ' + totalPlayers, 2000);
            
            updatePaginationControls();
            renderPlayers();
        }
        
        function changePlayersPerPage() {
            console.log('üîÑ changePlayersPerPage called');
            
            // Check which dropdown was changed and get the new value
            const topDropdown = document.getElementById('playersPerPage');
            const bottomDropdown = document.getElementById('bottomPlayersPerPage');
            
            let newValue;
            if (topDropdown && topDropdown.value !== gameState.playersPerPage) {
                newValue = topDropdown.value;
                // Sync bottom dropdown
                if (bottomDropdown) {
                    bottomDropdown.value = newValue;
                }
            } else if (bottomDropdown && bottomDropdown.value !== gameState.playersPerPage) {
                newValue = bottomDropdown.value;
                // Sync top dropdown
                if (topDropdown) {
                    topDropdown.value = newValue;
                }
            } else {
                // Fallback to top dropdown value
                newValue = topDropdown ? topDropdown.value : '20';
            }
            
            console.log('üîÑ New value:', newValue);
            
            gameState.playersPerPage = newValue;
            gameState.currentPage = 1; // Reset to first page
            console.log('üîÑ Updated gameState.playersPerPage to:', gameState.playersPerPage);
            
            updatePaginationControls();
            renderPlayers();
        }
        
        function getPaginatedPlayers() {
            try {
                const totalPlayers = gameState.players ? gameState.players.length : 0;
                
                if (gameState.playersPerPage === 'all' || totalPlayers === 0) {
                    return gameState.players || [];
                }
                
                const playersPerPage = parseInt(gameState.playersPerPage);
                const startIndex = (gameState.currentPage - 1) * playersPerPage;
                const endIndex = Math.min(startIndex + playersPerPage, totalPlayers);
                
                return gameState.players.slice(startIndex, endIndex);
            } catch (error) {
                console.error('Error getting paginated players:', error);
                return gameState.players || [];
            }
        }

        // Initialize pagination dropdown on page load
        function initializePaginationDropdown() {
            console.log('üîÑ initializePaginationDropdown called');
            const topDropdown = document.getElementById('playersPerPage');
            const bottomDropdown = document.getElementById('bottomPlayersPerPage');
            
            if (topDropdown) {
                // Ensure the top dropdown value matches gameState
                topDropdown.value = gameState.playersPerPage.toString();
                console.log('üîÑ Top pagination dropdown initialized to:', gameState.playersPerPage);
                console.log('üîÑ Top dropdown value after setting:', topDropdown.value);
            } else {
                console.error('üîÑ Top dropdown element not found!');
            }
            
            if (bottomDropdown) {
                // Ensure the bottom dropdown value matches gameState
                bottomDropdown.value = gameState.playersPerPage.toString();
                console.log('üîÑ Bottom pagination dropdown initialized to:', gameState.playersPerPage);
                console.log('üîÑ Bottom dropdown value after setting:', bottomDropdown.value);
            } else {
                console.log('üîÑ Bottom dropdown element not found (expected during initial load)');
            }
        }
        
        // Make functions globally accessible
        window.changePage = changePage;
        window.changePlayersPerPage = changePlayersPerPage;
    </script>
</body>
</html>
